"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@e2b";
exports.ids = ["vendor-chunks/@e2b"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@e2b/desktop/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@e2b/desktop/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.ApiClient),\n/* harmony export */   AuthenticationError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.AuthenticationError),\n/* harmony export */   CommandExitError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.CommandExitError),\n/* harmony export */   ConnectionConfig: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.ConnectionConfig),\n/* harmony export */   FileType: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.FileType),\n/* harmony export */   FilesystemEventType: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.FilesystemEventType),\n/* harmony export */   InvalidArgumentError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError),\n/* harmony export */   NotEnoughSpaceError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.NotEnoughSpaceError),\n/* harmony export */   NotFoundError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.NotFoundError),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.RateLimitError),\n/* harmony export */   Sandbox: () => (/* binding */ Sandbox),\n/* harmony export */   SandboxError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.SandboxError),\n/* harmony export */   TemplateError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.TemplateError),\n/* harmony export */   TimeoutError: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.TimeoutError),\n/* harmony export */   getSignature: () => (/* reexport safe */ e2b__WEBPACK_IMPORTED_MODULE_0__.getSignature)\n/* harmony export */ });\n/* harmony import */ var e2b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! e2b */ \"(action-browser)/./node_modules/e2b/dist/index.mjs\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/index.ts\n\n\n// src/sandbox.ts\n\n\n// src/utils.ts\n\nfunction generateRandomString(length = 16) {\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const bytes = (0,crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(length);\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += characters[bytes[i] % characters.length];\n  }\n  return result;\n}\n\n// src/sandbox.ts\nvar MOUSE_BUTTONS = {\n  left: 1,\n  right: 3,\n  middle: 2\n};\nvar KEYS = {\n  alt: \"Alt_L\",\n  alt_left: \"Alt_L\",\n  alt_right: \"Alt_R\",\n  backspace: \"BackSpace\",\n  break: \"Pause\",\n  caps_lock: \"Caps_Lock\",\n  cmd: \"Super_L\",\n  command: \"Super_L\",\n  control: \"Control_L\",\n  control_left: \"Control_L\",\n  control_right: \"Control_R\",\n  ctrl: \"Control_L\",\n  del: \"Delete\",\n  delete: \"Delete\",\n  down: \"Down\",\n  end: \"End\",\n  enter: \"Return\",\n  esc: \"Escape\",\n  escape: \"Escape\",\n  f1: \"F1\",\n  f2: \"F2\",\n  f3: \"F3\",\n  f4: \"F4\",\n  f5: \"F5\",\n  f6: \"F6\",\n  f7: \"F7\",\n  f8: \"F8\",\n  f9: \"F9\",\n  f10: \"F10\",\n  f11: \"F11\",\n  f12: \"F12\",\n  home: \"Home\",\n  insert: \"Insert\",\n  left: \"Left\",\n  menu: \"Menu\",\n  meta: \"Meta_L\",\n  num_lock: \"Num_Lock\",\n  page_down: \"Page_Down\",\n  page_up: \"Page_Up\",\n  pause: \"Pause\",\n  print: \"Print\",\n  right: \"Right\",\n  scroll_lock: \"Scroll_Lock\",\n  shift: \"Shift_L\",\n  shift_left: \"Shift_L\",\n  shift_right: \"Shift_R\",\n  space: \"space\",\n  super: \"Super_L\",\n  super_left: \"Super_L\",\n  super_right: \"Super_R\",\n  tab: \"Tab\",\n  up: \"Up\",\n  win: \"Super_L\",\n  windows: \"Super_L\"\n};\nfunction mapKey(key) {\n  const lowerKey = key.toLowerCase();\n  if (lowerKey in KEYS) {\n    return KEYS[lowerKey];\n  }\n  return lowerKey;\n}\nvar Sandbox = class extends e2b__WEBPACK_IMPORTED_MODULE_0__.Sandbox {\n  /**\n   * Use {@link Sandbox.create} to create a new Sandbox instead.\n   *\n   * @hidden\n   * @hide\n   * @internal\n   * @access protected\n   */\n  constructor(opts) {\n    super(opts);\n    this.lastXfce4Pid = null;\n    this.display = \":0\";\n    this.stream = new VNCServer(this);\n  }\n  static async create(templateOrOpts, opts) {\n    var _a, _b, _c;\n    const { template, sandboxOpts } = typeof templateOrOpts === \"string\" ? { template: templateOrOpts, sandboxOpts: opts } : { template: this.defaultTemplate, sandboxOpts: templateOrOpts };\n    const config = new e2b__WEBPACK_IMPORTED_MODULE_0__.ConnectionConfig(sandboxOpts);\n    const display = (opts == null ? void 0 : opts.display) || \":0\";\n    const sandboxOptsWithDisplay = __spreadProps(__spreadValues({}, sandboxOpts), {\n      envs: __spreadProps(__spreadValues({}, sandboxOpts == null ? void 0 : sandboxOpts.envs), {\n        DISPLAY: display\n      })\n    });\n    let sbx;\n    if (config.debug) {\n      sbx = new this(__spreadValues(__spreadValues({\n        sandboxId: \"desktop\"\n      }, sandboxOptsWithDisplay), config));\n    } else {\n      const sandbox = await this.createSandbox(\n        template,\n        (_a = sandboxOptsWithDisplay == null ? void 0 : sandboxOptsWithDisplay.timeoutMs) != null ? _a : this.defaultSandboxTimeoutMs,\n        sandboxOptsWithDisplay\n      );\n      sbx = new this(__spreadValues(__spreadValues(__spreadValues({}, sandbox), sandboxOptsWithDisplay), config));\n    }\n    sbx.display = display;\n    sbx.lastXfce4Pid = null;\n    sbx.stream = new VNCServer(sbx);\n    const [width, height] = (_b = sandboxOpts == null ? void 0 : sandboxOpts.resolution) != null ? _b : [1024, 768];\n    await sbx.commands.run(\n      `Xvfb ${sbx.display} -ac -screen 0 ${width}x${height}x24 -retro -dpi ${(_c = sandboxOpts == null ? void 0 : sandboxOpts.dpi) != null ? _c : 96} -nolisten tcp -nolisten unix`,\n      { background: true, timeoutMs: 0 }\n    );\n    let hasStarted = await sbx.waitAndVerify(\n      `xdpyinfo -display ${sbx.display}`,\n      (r) => r.exitCode === 0\n    );\n    if (!hasStarted) {\n      throw new e2b__WEBPACK_IMPORTED_MODULE_0__.TimeoutError(\"Could not start Xvfb\");\n    }\n    await sbx.startXfce4();\n    return sbx;\n  }\n  /**\n   * Wait for a command to return a specific result.\n   * @param cmd - The command to run.\n   * @param onResult - The function to check the result of the command.\n   * @param timeout - The maximum time to wait for the command to return the result.\n   * @param interval - The interval to wait between checks.\n   * @returns `true` if the command returned the result within the timeout, otherwise `false`.\n   */\n  async waitAndVerify(cmd, onResult, timeout = 10, interval = 0.5) {\n    let elapsed = 0;\n    while (elapsed < timeout) {\n      try {\n        if (onResult(await this.commands.run(cmd))) {\n          return true;\n        }\n      } catch (e) {\n        if (e instanceof e2b__WEBPACK_IMPORTED_MODULE_0__.CommandExitError) {\n          continue;\n        }\n        throw e;\n      }\n      await new Promise((resolve) => setTimeout(resolve, interval * 1e3));\n      elapsed += interval;\n    }\n    return false;\n  }\n  /**\n   * Start xfce4 session if logged out or not running.\n   */\n  async startXfce4() {\n    if (this.lastXfce4Pid === null || (await this.commands.run(\n      `ps aux | grep ${this.lastXfce4Pid} | grep -v grep | head -n 1`\n    )).stdout.trim().includes(\"[xfce4-session] <defunct>\")) {\n      const result = await this.commands.run(\"startxfce4\", {\n        background: true,\n        timeoutMs: 0\n      });\n      this.lastXfce4Pid = result.pid;\n    }\n  }\n  async screenshot(format = \"bytes\") {\n    const path = `/tmp/screenshot-${generateRandomString()}.png`;\n    await this.commands.run(`scrot --pointer ${path}`);\n    const file = await this.files.read(path, { format });\n    this.files.remove(path);\n    return file;\n  }\n  /**\n   * Left click on the mouse position.\n   */\n  async leftClick(x, y) {\n    if (x && y) {\n      await this.moveMouse(x, y);\n    }\n    await this.commands.run(\"xdotool click 1\");\n  }\n  /**\n   * Double left click on the mouse position.\n   */\n  async doubleClick(x, y) {\n    if (x && y) {\n      await this.moveMouse(x, y);\n    }\n    await this.commands.run(\"xdotool click --repeat 2 1\");\n  }\n  /**\n   * Right click on the mouse position.\n   */\n  async rightClick(x, y) {\n    if (x && y) {\n      await this.moveMouse(x, y);\n    }\n    await this.commands.run(\"xdotool click 3\");\n  }\n  /**\n   * Middle click on the mouse position.\n   */\n  async middleClick(x, y) {\n    if (x && y) {\n      await this.moveMouse(x, y);\n    }\n    await this.commands.run(\"xdotool click 2\");\n  }\n  /**\n   * Scroll the mouse wheel by the given amount.\n   * @param direction - The direction to scroll. Can be \"up\" or \"down\".\n   * @param amount - The amount to scroll.\n   */\n  async scroll(direction = \"down\", amount = 1) {\n    const button = direction === \"up\" ? \"4\" : \"5\";\n    await this.commands.run(`xdotool click --repeat ${amount} ${button}`);\n  }\n  /**\n   * Move the mouse to the given coordinates.\n   * @param x - The x coordinate.\n   * @param y - The y coordinate.\n   */\n  async moveMouse(x, y) {\n    await this.commands.run(`xdotool mousemove --sync ${x} ${y}`);\n  }\n  /**\n   * Press the mouse button.\n   */\n  async mousePress(button = \"left\") {\n    await this.commands.run(`xdotool mousedown ${MOUSE_BUTTONS[button]}`);\n  }\n  /**\n   * Release the mouse button.\n   */\n  async mouseRelease(button = \"left\") {\n    await this.commands.run(`xdotool mouseup ${MOUSE_BUTTONS[button]}`);\n  }\n  /**\n   * Get the current cursor position.\n   * @returns A object with the x and y coordinates\n   * @throws Error if cursor position cannot be determined\n   */\n  async getCursorPosition() {\n    const result = await this.commands.run(\"xdotool getmouselocation\");\n    const match = result.stdout.match(/x:(\\d+)\\s+y:(\\d+)/);\n    if (!match) {\n      throw new Error(\n        `Failed to parse cursor position from output: ${result.stdout}`\n      );\n    }\n    const [, x, y] = match;\n    if (!x || !y) {\n      throw new Error(`Invalid cursor position values: x=${x}, y=${y}`);\n    }\n    return { x: parseInt(x), y: parseInt(y) };\n  }\n  /**\n   * Get the current screen size.\n   * @returns An {@link ScreenSize} object\n   * @throws Error if screen size cannot be determined\n   */\n  async getScreenSize() {\n    const result = await this.commands.run(\"xrandr\");\n    const match = result.stdout.match(/(\\d+x\\d+)/);\n    if (!match) {\n      throw new Error(\n        `Failed to parse screen size from output: ${result.stdout}`\n      );\n    }\n    try {\n      const [width, height] = match[1].split(\"x\").map((val) => parseInt(val));\n      return { width, height };\n    } catch (error) {\n      throw new Error(`Invalid screen size format: ${match[1]}`);\n    }\n  }\n  *breakIntoChunks(text, n) {\n    for (let i = 0; i < text.length; i += n) {\n      yield text.slice(i, i + n);\n    }\n  }\n  quoteString(s) {\n    if (!s) {\n      return \"''\";\n    }\n    if (!/[^\\w@%+=:,./-]/.test(s)) {\n      return s;\n    }\n    return \"'\" + s.replace(/'/g, `'\"'\"'`) + \"'\";\n  }\n  /**\n   * Write the given text at the current cursor position.\n   * @param text - The text to write.\n   * @param options - An object containing the chunk size and delay between each chunk of text.\n   * @param options.chunkSize - The size of each chunk of text to write. Default is 25 characters.\n   * @param options.delayInMs - The delay between each chunk of text. Default is 75 ms.\n   */\n  async write(text, options = {\n    chunkSize: 25,\n    delayInMs: 75\n  }) {\n    const chunks = this.breakIntoChunks(text, options.chunkSize);\n    for (const chunk of chunks) {\n      await this.commands.run(\n        `xdotool type --delay ${options.delayInMs} ${this.quoteString(chunk)}`\n      );\n    }\n  }\n  /**\n   * Press a key.\n   * @param key - The key to press (e.g. \"enter\", \"space\", \"backspace\", etc.). Can be a single key or an array of keys.\n   */\n  async press(key) {\n    if (Array.isArray(key)) {\n      key = key.map(mapKey).join(\"+\");\n    } else {\n      key = mapKey(key);\n    }\n    await this.commands.run(`xdotool key ${key}`);\n  }\n  /**\n   * Drag the mouse from the given position to the given position.\n   * @param from - The starting position.\n   * @param to - The ending position.\n   */\n  async drag([x1, y1], [x2, y2]) {\n    await this.moveMouse(x1, y1);\n    await this.mousePress();\n    await this.moveMouse(x2, y2);\n    await this.mouseRelease();\n  }\n  /**\n   * Wait for the given amount of time.\n   * @param ms - The amount of time to wait in milliseconds.\n   */\n  async wait(ms) {\n    await this.commands.run(`sleep ${ms / 1e3}`);\n  }\n  /**\n   * Open a file or a URL in the default application.\n   * @param fileOrUrl - The file or URL to open.\n   */\n  async open(fileOrUrl) {\n    await this.commands.run(`xdg-open ${fileOrUrl}`, {\n      background: true\n    });\n  }\n  /**\n   * Get the current window ID.\n   * @returns The ID of the current window.\n   */\n  async getCurrentWindowId() {\n    const result = await this.commands.run(\"xdotool getwindowfocus\");\n    return result.stdout.trim();\n  }\n  /**\n   * Get the window ID of the window with the given title.\n   * @param title - The title of the window.\n   * @returns The ID of the window.\n   */\n  async getApplicationWindows(application) {\n    const result = await this.commands.run(\n      `xdotool search --onlyvisible --class ${application}`\n    );\n    return result.stdout.trim().split(\"\\n\");\n  }\n  /**\n   * Get the title of the window with the given ID.\n   * @param windowId - The ID of the window.\n   * @returns The title of the window.\n   */\n  async getWindowTitle(windowId) {\n    const result = await this.commands.run(`xdotool getwindowname ${windowId}`);\n    return result.stdout.trim();\n  }\n  /**\n   * Launch an application.\n   * @param application - The application to launch.\n   * @param uri - The URI to open in the application.\n   */\n  async launch(application, uri) {\n    await this.commands.run(`gtk-launch ${application} ${uri != null ? uri : \"\"}`, {\n      background: true,\n      timeoutMs: 0\n    });\n  }\n};\nSandbox.defaultTemplate = \"desktop\";\nvar VNCServer = class {\n  constructor(desktop) {\n    this.vncPort = 5900;\n    this.port = 6080;\n    this.novncAuthEnabled = false;\n    this.url = null;\n    this.novncHandle = null;\n    this.desktop = desktop;\n    this.novncCommand = `cd /opt/noVNC/utils && ./novnc_proxy --vnc localhost:${this.vncPort} --listen ${this.port} --web /opt/noVNC > /tmp/novnc.log 2>&1`;\n  }\n  getAuthKey() {\n    if (!this.password) {\n      throw new Error(\n        \"Unable to retrieve stream auth key, check if requireAuth is enabled\"\n      );\n    }\n    return this.password;\n  }\n  /**\n   * Set the VNC command to start the VNC server.\n   */\n  async getVNCCommand(windowId) {\n    let pwdFlag = \"-nopw\";\n    if (this.novncAuthEnabled) {\n      await this.desktop.commands.run(\"mkdir -p ~/.vnc\");\n      await this.desktop.commands.run(\n        `x11vnc -storepasswd ${this.password} ~/.vnc/passwd`\n      );\n      pwdFlag = \"-usepw\";\n    }\n    return `x11vnc -bg -display ${this.desktop.display} -forever -wait 50 -shared -rfbport ${this.vncPort} ${pwdFlag} 2>/tmp/x11vnc_stderr.log` + (windowId ? ` -id ${windowId}` : \"\");\n  }\n  async waitForPort(port) {\n    return await this.desktop.waitAndVerify(\n      `netstat -tuln | grep \":${port} \"`,\n      (r) => r.stdout.trim() !== \"\"\n    );\n  }\n  /**\n   * Check if the VNC server is running.\n   * @returns Whether the VNC server is running.\n   */\n  async checkVNCRunning() {\n    try {\n      const result = await this.desktop.commands.run(\"pgrep -x x11vnc\");\n      return result.stdout.trim() !== \"\";\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Get the URL to a web page with a stream of the desktop sandbox.\n   * @param autoConnect - Whether to automatically connect to the server after opening the URL.\n   * @param viewOnly - Whether to prevent user interaction through the client.\n   * @param resize - Whether to resize the view when the window resizes.\n   * @param authKey - The password to use to connect to the server.\n   * @returns The URL to connect to the VNC server.\n   */\n  getUrl({\n    autoConnect = true,\n    viewOnly = false,\n    resize = \"scale\",\n    authKey\n  } = {}) {\n    if (this.url === null) {\n      throw new Error(\"Server is not running\");\n    }\n    let url = new URL(this.url);\n    if (autoConnect) {\n      url.searchParams.set(\"autoconnect\", \"true\");\n    }\n    if (viewOnly) {\n      url.searchParams.set(\"view_only\", \"true\");\n    }\n    if (resize) {\n      url.searchParams.set(\"resize\", resize);\n    }\n    if (authKey) {\n      url.searchParams.set(\"password\", authKey);\n    }\n    return url.toString();\n  }\n  /**\n   * Start the VNC server.\n   */\n  async start(opts = {}) {\n    var _a, _b, _c;\n    if (await this.checkVNCRunning()) {\n      throw new Error(\"Stream is already running\");\n    }\n    this.vncPort = (_a = opts.vncPort) != null ? _a : this.vncPort;\n    this.port = (_b = opts.port) != null ? _b : this.port;\n    this.novncAuthEnabled = (_c = opts.requireAuth) != null ? _c : this.novncAuthEnabled;\n    this.password = this.novncAuthEnabled ? generateRandomString() : void 0;\n    this.url = new URL(`https://${this.desktop.getHost(this.port)}/vnc.html`);\n    const vncCommand = await this.getVNCCommand(opts.windowId);\n    await this.desktop.commands.run(vncCommand);\n    this.novncHandle = await this.desktop.commands.run(this.novncCommand, {\n      background: true,\n      timeoutMs: 0\n    });\n    if (!await this.waitForPort(this.port)) {\n      throw new Error(\"Could not start noVNC server\");\n    }\n  }\n  /**\n   * Stop the VNC server.\n   */\n  async stop() {\n    if (await this.checkVNCRunning()) {\n      await this.desktop.commands.run(\"pkill x11vnc\");\n    }\n    if (this.novncHandle) {\n      await this.novncHandle.kill();\n      this.novncHandle = null;\n    }\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZTJiL2Rlc2t0b3AvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ29COztBQUVwQjtBQU1hOztBQUViO0FBQ3FDO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQVc7QUFDM0I7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0NBQVc7QUFDdkM7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0IseUNBQXlDLDhDQUE4QyxJQUFJO0FBQy9ILHVCQUF1QixpREFBZ0I7QUFDdkM7QUFDQSxrRUFBa0U7QUFDbEUsMkNBQTJDO0FBQzNDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsZ0JBQWdCLE1BQU0sR0FBRyxPQUFPLGtCQUFrQix5RUFBeUU7QUFDdEosUUFBUTtBQUNSO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCLGlEQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0QsK0NBQStDLEtBQUs7QUFDcEQsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUSxFQUFFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRyxFQUFFLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUUsTUFBTSxFQUFFO0FBQ3JFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04scURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CLEVBQUUsd0JBQXdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWEsRUFBRSx1QkFBdUI7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWMsV0FBVyxXQUFXO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCLHFDQUFxQyxjQUFjLEVBQUUsU0FBUyxnREFBZ0QsU0FBUztBQUMvSztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0BlMmIvZGVza3RvcC9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcblxuLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiZTJiXCI7XG5cbi8vIHNyYy9zYW5kYm94LnRzXG5pbXBvcnQge1xuICBTYW5kYm94IGFzIFNhbmRib3hCYXNlLFxuICBDb21tYW5kRXhpdEVycm9yLFxuICBDb25uZWN0aW9uQ29uZmlnLFxuICBUaW1lb3V0RXJyb3Jcbn0gZnJvbSBcImUyYlwiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSBcImNyeXB0b1wiO1xuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdHJpbmcobGVuZ3RoID0gMTYpIHtcbiAgY29uc3QgY2hhcmFjdGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgY29uc3QgYnl0ZXMgPSByYW5kb21CeXRlcyhsZW5ndGgpO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzW2J5dGVzW2ldICUgY2hhcmFjdGVycy5sZW5ndGhdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9zYW5kYm94LnRzXG52YXIgTU9VU0VfQlVUVE9OUyA9IHtcbiAgbGVmdDogMSxcbiAgcmlnaHQ6IDMsXG4gIG1pZGRsZTogMlxufTtcbnZhciBLRVlTID0ge1xuICBhbHQ6IFwiQWx0X0xcIixcbiAgYWx0X2xlZnQ6IFwiQWx0X0xcIixcbiAgYWx0X3JpZ2h0OiBcIkFsdF9SXCIsXG4gIGJhY2tzcGFjZTogXCJCYWNrU3BhY2VcIixcbiAgYnJlYWs6IFwiUGF1c2VcIixcbiAgY2Fwc19sb2NrOiBcIkNhcHNfTG9ja1wiLFxuICBjbWQ6IFwiU3VwZXJfTFwiLFxuICBjb21tYW5kOiBcIlN1cGVyX0xcIixcbiAgY29udHJvbDogXCJDb250cm9sX0xcIixcbiAgY29udHJvbF9sZWZ0OiBcIkNvbnRyb2xfTFwiLFxuICBjb250cm9sX3JpZ2h0OiBcIkNvbnRyb2xfUlwiLFxuICBjdHJsOiBcIkNvbnRyb2xfTFwiLFxuICBkZWw6IFwiRGVsZXRlXCIsXG4gIGRlbGV0ZTogXCJEZWxldGVcIixcbiAgZG93bjogXCJEb3duXCIsXG4gIGVuZDogXCJFbmRcIixcbiAgZW50ZXI6IFwiUmV0dXJuXCIsXG4gIGVzYzogXCJFc2NhcGVcIixcbiAgZXNjYXBlOiBcIkVzY2FwZVwiLFxuICBmMTogXCJGMVwiLFxuICBmMjogXCJGMlwiLFxuICBmMzogXCJGM1wiLFxuICBmNDogXCJGNFwiLFxuICBmNTogXCJGNVwiLFxuICBmNjogXCJGNlwiLFxuICBmNzogXCJGN1wiLFxuICBmODogXCJGOFwiLFxuICBmOTogXCJGOVwiLFxuICBmMTA6IFwiRjEwXCIsXG4gIGYxMTogXCJGMTFcIixcbiAgZjEyOiBcIkYxMlwiLFxuICBob21lOiBcIkhvbWVcIixcbiAgaW5zZXJ0OiBcIkluc2VydFwiLFxuICBsZWZ0OiBcIkxlZnRcIixcbiAgbWVudTogXCJNZW51XCIsXG4gIG1ldGE6IFwiTWV0YV9MXCIsXG4gIG51bV9sb2NrOiBcIk51bV9Mb2NrXCIsXG4gIHBhZ2VfZG93bjogXCJQYWdlX0Rvd25cIixcbiAgcGFnZV91cDogXCJQYWdlX1VwXCIsXG4gIHBhdXNlOiBcIlBhdXNlXCIsXG4gIHByaW50OiBcIlByaW50XCIsXG4gIHJpZ2h0OiBcIlJpZ2h0XCIsXG4gIHNjcm9sbF9sb2NrOiBcIlNjcm9sbF9Mb2NrXCIsXG4gIHNoaWZ0OiBcIlNoaWZ0X0xcIixcbiAgc2hpZnRfbGVmdDogXCJTaGlmdF9MXCIsXG4gIHNoaWZ0X3JpZ2h0OiBcIlNoaWZ0X1JcIixcbiAgc3BhY2U6IFwic3BhY2VcIixcbiAgc3VwZXI6IFwiU3VwZXJfTFwiLFxuICBzdXBlcl9sZWZ0OiBcIlN1cGVyX0xcIixcbiAgc3VwZXJfcmlnaHQ6IFwiU3VwZXJfUlwiLFxuICB0YWI6IFwiVGFiXCIsXG4gIHVwOiBcIlVwXCIsXG4gIHdpbjogXCJTdXBlcl9MXCIsXG4gIHdpbmRvd3M6IFwiU3VwZXJfTFwiXG59O1xuZnVuY3Rpb24gbWFwS2V5KGtleSkge1xuICBjb25zdCBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobG93ZXJLZXkgaW4gS0VZUykge1xuICAgIHJldHVybiBLRVlTW2xvd2VyS2V5XTtcbiAgfVxuICByZXR1cm4gbG93ZXJLZXk7XG59XG52YXIgU2FuZGJveCA9IGNsYXNzIGV4dGVuZHMgU2FuZGJveEJhc2Uge1xuICAvKipcbiAgICogVXNlIHtAbGluayBTYW5kYm94LmNyZWF0ZX0gdG8gY3JlYXRlIGEgbmV3IFNhbmRib3ggaW5zdGVhZC5cbiAgICpcbiAgICogQGhpZGRlblxuICAgKiBAaGlkZVxuICAgKiBAaW50ZXJuYWxcbiAgICogQGFjY2VzcyBwcm90ZWN0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLmxhc3RYZmNlNFBpZCA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ID0gXCI6MFwiO1xuICAgIHRoaXMuc3RyZWFtID0gbmV3IFZOQ1NlcnZlcih0aGlzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKHRlbXBsYXRlT3JPcHRzLCBvcHRzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgc2FuZGJveE9wdHMgfSA9IHR5cGVvZiB0ZW1wbGF0ZU9yT3B0cyA9PT0gXCJzdHJpbmdcIiA/IHsgdGVtcGxhdGU6IHRlbXBsYXRlT3JPcHRzLCBzYW5kYm94T3B0czogb3B0cyB9IDogeyB0ZW1wbGF0ZTogdGhpcy5kZWZhdWx0VGVtcGxhdGUsIHNhbmRib3hPcHRzOiB0ZW1wbGF0ZU9yT3B0cyB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKHNhbmRib3hPcHRzKTtcbiAgICBjb25zdCBkaXNwbGF5ID0gKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGlzcGxheSkgfHwgXCI6MFwiO1xuICAgIGNvbnN0IHNhbmRib3hPcHRzV2l0aERpc3BsYXkgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzYW5kYm94T3B0cyksIHtcbiAgICAgIGVudnM6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHNhbmRib3hPcHRzID09IG51bGwgPyB2b2lkIDAgOiBzYW5kYm94T3B0cy5lbnZzKSwge1xuICAgICAgICBESVNQTEFZOiBkaXNwbGF5XG4gICAgICB9KVxuICAgIH0pO1xuICAgIGxldCBzYng7XG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgc2J4ID0gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBzYW5kYm94SWQ6IFwiZGVza3RvcFwiXG4gICAgICB9LCBzYW5kYm94T3B0c1dpdGhEaXNwbGF5KSwgY29uZmlnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNhbmRib3ggPSBhd2FpdCB0aGlzLmNyZWF0ZVNhbmRib3goXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAoX2EgPSBzYW5kYm94T3B0c1dpdGhEaXNwbGF5ID09IG51bGwgPyB2b2lkIDAgOiBzYW5kYm94T3B0c1dpdGhEaXNwbGF5LnRpbWVvdXRNcykgIT0gbnVsbCA/IF9hIDogdGhpcy5kZWZhdWx0U2FuZGJveFRpbWVvdXRNcyxcbiAgICAgICAgc2FuZGJveE9wdHNXaXRoRGlzcGxheVxuICAgICAgKTtcbiAgICAgIHNieCA9IG5ldyB0aGlzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBzYW5kYm94KSwgc2FuZGJveE9wdHNXaXRoRGlzcGxheSksIGNvbmZpZykpO1xuICAgIH1cbiAgICBzYnguZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgc2J4Lmxhc3RYZmNlNFBpZCA9IG51bGw7XG4gICAgc2J4LnN0cmVhbSA9IG5ldyBWTkNTZXJ2ZXIoc2J4KTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAoX2IgPSBzYW5kYm94T3B0cyA9PSBudWxsID8gdm9pZCAwIDogc2FuZGJveE9wdHMucmVzb2x1dGlvbikgIT0gbnVsbCA/IF9iIDogWzEwMjQsIDc2OF07XG4gICAgYXdhaXQgc2J4LmNvbW1hbmRzLnJ1bihcbiAgICAgIGBYdmZiICR7c2J4LmRpc3BsYXl9IC1hYyAtc2NyZWVuIDAgJHt3aWR0aH14JHtoZWlnaHR9eDI0IC1yZXRybyAtZHBpICR7KF9jID0gc2FuZGJveE9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNhbmRib3hPcHRzLmRwaSkgIT0gbnVsbCA/IF9jIDogOTZ9IC1ub2xpc3RlbiB0Y3AgLW5vbGlzdGVuIHVuaXhgLFxuICAgICAgeyBiYWNrZ3JvdW5kOiB0cnVlLCB0aW1lb3V0TXM6IDAgfVxuICAgICk7XG4gICAgbGV0IGhhc1N0YXJ0ZWQgPSBhd2FpdCBzYngud2FpdEFuZFZlcmlmeShcbiAgICAgIGB4ZHB5aW5mbyAtZGlzcGxheSAke3NieC5kaXNwbGF5fWAsXG4gICAgICAocikgPT4gci5leGl0Q29kZSA9PT0gMFxuICAgICk7XG4gICAgaWYgKCFoYXNTdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKFwiQ291bGQgbm90IHN0YXJ0IFh2ZmJcIik7XG4gICAgfVxuICAgIGF3YWl0IHNieC5zdGFydFhmY2U0KCk7XG4gICAgcmV0dXJuIHNieDtcbiAgfVxuICAvKipcbiAgICogV2FpdCBmb3IgYSBjb21tYW5kIHRvIHJldHVybiBhIHNwZWNpZmljIHJlc3VsdC5cbiAgICogQHBhcmFtIGNtZCAtIFRoZSBjb21tYW5kIHRvIHJ1bi5cbiAgICogQHBhcmFtIG9uUmVzdWx0IC0gVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHRoZSByZXN1bHQgb2YgdGhlIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB0aW1lb3V0IC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgY29tbWFuZCB0byByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIGludGVydmFsIC0gVGhlIGludGVydmFsIHRvIHdhaXQgYmV0d2VlbiBjaGVja3MuXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29tbWFuZCByZXR1cm5lZCB0aGUgcmVzdWx0IHdpdGhpbiB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqL1xuICBhc3luYyB3YWl0QW5kVmVyaWZ5KGNtZCwgb25SZXN1bHQsIHRpbWVvdXQgPSAxMCwgaW50ZXJ2YWwgPSAwLjUpIHtcbiAgICBsZXQgZWxhcHNlZCA9IDA7XG4gICAgd2hpbGUgKGVsYXBzZWQgPCB0aW1lb3V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob25SZXN1bHQoYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oY21kKSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbW1hbmRFeGl0RXJyb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwgKiAxZTMpKTtcbiAgICAgIGVsYXBzZWQgKz0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgeGZjZTQgc2Vzc2lvbiBpZiBsb2dnZWQgb3V0IG9yIG5vdCBydW5uaW5nLlxuICAgKi9cbiAgYXN5bmMgc3RhcnRYZmNlNCgpIHtcbiAgICBpZiAodGhpcy5sYXN0WGZjZTRQaWQgPT09IG51bGwgfHwgKGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKFxuICAgICAgYHBzIGF1eCB8IGdyZXAgJHt0aGlzLmxhc3RYZmNlNFBpZH0gfCBncmVwIC12IGdyZXAgfCBoZWFkIC1uIDFgXG4gICAgKSkuc3Rkb3V0LnRyaW0oKS5pbmNsdWRlcyhcIlt4ZmNlNC1zZXNzaW9uXSA8ZGVmdW5jdD5cIikpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKFwic3RhcnR4ZmNlNFwiLCB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgICAgIHRpbWVvdXRNczogMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmxhc3RYZmNlNFBpZCA9IHJlc3VsdC5waWQ7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNjcmVlbnNob3QoZm9ybWF0ID0gXCJieXRlc1wiKSB7XG4gICAgY29uc3QgcGF0aCA9IGAvdG1wL3NjcmVlbnNob3QtJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfS5wbmdgO1xuICAgIGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKGBzY3JvdCAtLXBvaW50ZXIgJHtwYXRofWApO1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmZpbGVzLnJlYWQocGF0aCwgeyBmb3JtYXQgfSk7XG4gICAgdGhpcy5maWxlcy5yZW1vdmUocGF0aCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbiAgLyoqXG4gICAqIExlZnQgY2xpY2sgb24gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICAgKi9cbiAgYXN5bmMgbGVmdENsaWNrKHgsIHkpIHtcbiAgICBpZiAoeCAmJiB5KSB7XG4gICAgICBhd2FpdCB0aGlzLm1vdmVNb3VzZSh4LCB5KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oXCJ4ZG90b29sIGNsaWNrIDFcIik7XG4gIH1cbiAgLyoqXG4gICAqIERvdWJsZSBsZWZ0IGNsaWNrIG9uIHRoZSBtb3VzZSBwb3NpdGlvbi5cbiAgICovXG4gIGFzeW5jIGRvdWJsZUNsaWNrKHgsIHkpIHtcbiAgICBpZiAoeCAmJiB5KSB7XG4gICAgICBhd2FpdCB0aGlzLm1vdmVNb3VzZSh4LCB5KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oXCJ4ZG90b29sIGNsaWNrIC0tcmVwZWF0IDIgMVwiKTtcbiAgfVxuICAvKipcbiAgICogUmlnaHQgY2xpY2sgb24gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICAgKi9cbiAgYXN5bmMgcmlnaHRDbGljayh4LCB5KSB7XG4gICAgaWYgKHggJiYgeSkge1xuICAgICAgYXdhaXQgdGhpcy5tb3ZlTW91c2UoeCwgeSk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKFwieGRvdG9vbCBjbGljayAzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBNaWRkbGUgY2xpY2sgb24gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICAgKi9cbiAgYXN5bmMgbWlkZGxlQ2xpY2soeCwgeSkge1xuICAgIGlmICh4ICYmIHkpIHtcbiAgICAgIGF3YWl0IHRoaXMubW92ZU1vdXNlKHgsIHkpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmNvbW1hbmRzLnJ1bihcInhkb3Rvb2wgY2xpY2sgMlwiKTtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xsIHRoZSBtb3VzZSB3aGVlbCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiB0byBzY3JvbGwuIENhbiBiZSBcInVwXCIgb3IgXCJkb3duXCIuXG4gICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIHNjcm9sbC5cbiAgICovXG4gIGFzeW5jIHNjcm9sbChkaXJlY3Rpb24gPSBcImRvd25cIiwgYW1vdW50ID0gMSkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRpcmVjdGlvbiA9PT0gXCJ1cFwiID8gXCI0XCIgOiBcIjVcIjtcbiAgICBhd2FpdCB0aGlzLmNvbW1hbmRzLnJ1bihgeGRvdG9vbCBjbGljayAtLXJlcGVhdCAke2Ftb3VudH0gJHtidXR0b259YCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgdGhlIG1vdXNlIHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHggLSBUaGUgeCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5IGNvb3JkaW5hdGUuXG4gICAqL1xuICBhc3luYyBtb3ZlTW91c2UoeCwgeSkge1xuICAgIGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKGB4ZG90b29sIG1vdXNlbW92ZSAtLXN5bmMgJHt4fSAke3l9YCk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXNzIHRoZSBtb3VzZSBidXR0b24uXG4gICAqL1xuICBhc3luYyBtb3VzZVByZXNzKGJ1dHRvbiA9IFwibGVmdFwiKSB7XG4gICAgYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oYHhkb3Rvb2wgbW91c2Vkb3duICR7TU9VU0VfQlVUVE9OU1tidXR0b25dfWApO1xuICB9XG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBtb3VzZSBidXR0b24uXG4gICAqL1xuICBhc3luYyBtb3VzZVJlbGVhc2UoYnV0dG9uID0gXCJsZWZ0XCIpIHtcbiAgICBhd2FpdCB0aGlzLmNvbW1hbmRzLnJ1bihgeGRvdG9vbCBtb3VzZXVwICR7TU9VU0VfQlVUVE9OU1tidXR0b25dfWApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyBBIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgY3Vyc29yIHBvc2l0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gICAqL1xuICBhc3luYyBnZXRDdXJzb3JQb3NpdGlvbigpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbW1hbmRzLnJ1bihcInhkb3Rvb2wgZ2V0bW91c2Vsb2NhdGlvblwiKTtcbiAgICBjb25zdCBtYXRjaCA9IHJlc3VsdC5zdGRvdXQubWF0Y2goL3g6KFxcZCspXFxzK3k6KFxcZCspLyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIGN1cnNvciBwb3NpdGlvbiBmcm9tIG91dHB1dDogJHtyZXN1bHQuc3Rkb3V0fWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IFssIHgsIHldID0gbWF0Y2g7XG4gICAgaWYgKCF4IHx8ICF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY3Vyc29yIHBvc2l0aW9uIHZhbHVlczogeD0ke3h9LCB5PSR7eX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogcGFyc2VJbnQoeCksIHk6IHBhcnNlSW50KHkpIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzY3JlZW4gc2l6ZS5cbiAgICogQHJldHVybnMgQW4ge0BsaW5rIFNjcmVlblNpemV9IG9iamVjdFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHNjcmVlbiBzaXplIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gICAqL1xuICBhc3luYyBnZXRTY3JlZW5TaXplKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKFwieHJhbmRyXCIpO1xuICAgIGNvbnN0IG1hdGNoID0gcmVzdWx0LnN0ZG91dC5tYXRjaCgvKFxcZCt4XFxkKykvKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc2NyZWVuIHNpemUgZnJvbSBvdXRwdXQ6ICR7cmVzdWx0LnN0ZG91dH1gXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gbWF0Y2hbMV0uc3BsaXQoXCJ4XCIpLm1hcCgodmFsKSA9PiBwYXJzZUludCh2YWwpKTtcbiAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjcmVlbiBzaXplIGZvcm1hdDogJHttYXRjaFsxXX1gKTtcbiAgICB9XG4gIH1cbiAgKmJyZWFrSW50b0NodW5rcyh0ZXh0LCBuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSArPSBuKSB7XG4gICAgICB5aWVsZCB0ZXh0LnNsaWNlKGksIGkgKyBuKTtcbiAgICB9XG4gIH1cbiAgcXVvdGVTdHJpbmcocykge1xuICAgIGlmICghcykge1xuICAgICAgcmV0dXJuIFwiJydcIjtcbiAgICB9XG4gICAgaWYgKCEvW15cXHdAJSs9OiwuLy1dLy50ZXN0KHMpKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcmV0dXJuIFwiJ1wiICsgcy5yZXBsYWNlKC8nL2csIGAnXCInXCInYCkgKyBcIidcIjtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgdGhlIGdpdmVuIHRleHQgYXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIHdyaXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaHVuayBzaXplIGFuZCBkZWxheSBiZXR3ZWVuIGVhY2ggY2h1bmsgb2YgdGV4dC5cbiAgICogQHBhcmFtIG9wdGlvbnMuY2h1bmtTaXplIC0gVGhlIHNpemUgb2YgZWFjaCBjaHVuayBvZiB0ZXh0IHRvIHdyaXRlLiBEZWZhdWx0IGlzIDI1IGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlbGF5SW5NcyAtIFRoZSBkZWxheSBiZXR3ZWVuIGVhY2ggY2h1bmsgb2YgdGV4dC4gRGVmYXVsdCBpcyA3NSBtcy5cbiAgICovXG4gIGFzeW5jIHdyaXRlKHRleHQsIG9wdGlvbnMgPSB7XG4gICAgY2h1bmtTaXplOiAyNSxcbiAgICBkZWxheUluTXM6IDc1XG4gIH0pIHtcbiAgICBjb25zdCBjaHVua3MgPSB0aGlzLmJyZWFrSW50b0NodW5rcyh0ZXh0LCBvcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKFxuICAgICAgICBgeGRvdG9vbCB0eXBlIC0tZGVsYXkgJHtvcHRpb25zLmRlbGF5SW5Nc30gJHt0aGlzLnF1b3RlU3RyaW5nKGNodW5rKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJlc3MgYSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHByZXNzIChlLmcuIFwiZW50ZXJcIiwgXCJzcGFjZVwiLCBcImJhY2tzcGFjZVwiLCBldGMuKS4gQ2FuIGJlIGEgc2luZ2xlIGtleSBvciBhbiBhcnJheSBvZiBrZXlzLlxuICAgKi9cbiAgYXN5bmMgcHJlc3Moa2V5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAga2V5ID0ga2V5Lm1hcChtYXBLZXkpLmpvaW4oXCIrXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBtYXBLZXkoa2V5KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oYHhkb3Rvb2wga2V5ICR7a2V5fWApO1xuICB9XG4gIC8qKlxuICAgKiBEcmFnIHRoZSBtb3VzZSBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZW5kaW5nIHBvc2l0aW9uLlxuICAgKi9cbiAgYXN5bmMgZHJhZyhbeDEsIHkxXSwgW3gyLCB5Ml0pIHtcbiAgICBhd2FpdCB0aGlzLm1vdmVNb3VzZSh4MSwgeTEpO1xuICAgIGF3YWl0IHRoaXMubW91c2VQcmVzcygpO1xuICAgIGF3YWl0IHRoaXMubW92ZU1vdXNlKHgyLCB5Mik7XG4gICAgYXdhaXQgdGhpcy5tb3VzZVJlbGVhc2UoKTtcbiAgfVxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIGdpdmVuIGFtb3VudCBvZiB0aW1lLlxuICAgKiBAcGFyYW0gbXMgLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBhc3luYyB3YWl0KG1zKSB7XG4gICAgYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oYHNsZWVwICR7bXMgLyAxZTN9YCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gYSBmaWxlIG9yIGEgVVJMIGluIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0gZmlsZU9yVXJsIC0gVGhlIGZpbGUgb3IgVVJMIHRvIG9wZW4uXG4gICAqL1xuICBhc3luYyBvcGVuKGZpbGVPclVybCkge1xuICAgIGF3YWl0IHRoaXMuY29tbWFuZHMucnVuKGB4ZGctb3BlbiAke2ZpbGVPclVybH1gLCB7XG4gICAgICBiYWNrZ3JvdW5kOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB3aW5kb3cgSUQuXG4gICAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgY3VycmVudCB3aW5kb3cuXG4gICAqL1xuICBhc3luYyBnZXRDdXJyZW50V2luZG93SWQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oXCJ4ZG90b29sIGdldHdpbmRvd2ZvY3VzXCIpO1xuICAgIHJldHVybiByZXN1bHQuc3Rkb3V0LnRyaW0oKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB3aW5kb3cgSUQgb2YgdGhlIHdpbmRvdyB3aXRoIHRoZSBnaXZlbiB0aXRsZS5cbiAgICogQHBhcmFtIHRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSB3aW5kb3cuXG4gICAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgd2luZG93LlxuICAgKi9cbiAgYXN5bmMgZ2V0QXBwbGljYXRpb25XaW5kb3dzKGFwcGxpY2F0aW9uKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oXG4gICAgICBgeGRvdG9vbCBzZWFyY2ggLS1vbmx5dmlzaWJsZSAtLWNsYXNzICR7YXBwbGljYXRpb259YFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdGRvdXQudHJpbSgpLnNwbGl0KFwiXFxuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpdGxlIG9mIHRoZSB3aW5kb3cgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqIEBwYXJhbSB3aW5kb3dJZCAtIFRoZSBJRCBvZiB0aGUgd2luZG93LlxuICAgKiBAcmV0dXJucyBUaGUgdGl0bGUgb2YgdGhlIHdpbmRvdy5cbiAgICovXG4gIGFzeW5jIGdldFdpbmRvd1RpdGxlKHdpbmRvd0lkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oYHhkb3Rvb2wgZ2V0d2luZG93bmFtZSAke3dpbmRvd0lkfWApO1xuICAgIHJldHVybiByZXN1bHQuc3Rkb3V0LnRyaW0oKTtcbiAgfVxuICAvKipcbiAgICogTGF1bmNoIGFuIGFwcGxpY2F0aW9uLlxuICAgKiBAcGFyYW0gYXBwbGljYXRpb24gLSBUaGUgYXBwbGljYXRpb24gdG8gbGF1bmNoLlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSB0byBvcGVuIGluIHRoZSBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGFzeW5jIGxhdW5jaChhcHBsaWNhdGlvbiwgdXJpKSB7XG4gICAgYXdhaXQgdGhpcy5jb21tYW5kcy5ydW4oYGd0ay1sYXVuY2ggJHthcHBsaWNhdGlvbn0gJHt1cmkgIT0gbnVsbCA/IHVyaSA6IFwiXCJ9YCwge1xuICAgICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgIHRpbWVvdXRNczogMFxuICAgIH0pO1xuICB9XG59O1xuU2FuZGJveC5kZWZhdWx0VGVtcGxhdGUgPSBcImRlc2t0b3BcIjtcbnZhciBWTkNTZXJ2ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlc2t0b3ApIHtcbiAgICB0aGlzLnZuY1BvcnQgPSA1OTAwO1xuICAgIHRoaXMucG9ydCA9IDYwODA7XG4gICAgdGhpcy5ub3ZuY0F1dGhFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMubm92bmNIYW5kbGUgPSBudWxsO1xuICAgIHRoaXMuZGVza3RvcCA9IGRlc2t0b3A7XG4gICAgdGhpcy5ub3ZuY0NvbW1hbmQgPSBgY2QgL29wdC9ub1ZOQy91dGlscyAmJiAuL25vdm5jX3Byb3h5IC0tdm5jIGxvY2FsaG9zdDoke3RoaXMudm5jUG9ydH0gLS1saXN0ZW4gJHt0aGlzLnBvcnR9IC0td2ViIC9vcHQvbm9WTkMgPiAvdG1wL25vdm5jLmxvZyAyPiYxYDtcbiAgfVxuICBnZXRBdXRoS2V5KCkge1xuICAgIGlmICghdGhpcy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlVuYWJsZSB0byByZXRyaWV2ZSBzdHJlYW0gYXV0aCBrZXksIGNoZWNrIGlmIHJlcXVpcmVBdXRoIGlzIGVuYWJsZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFzc3dvcmQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgVk5DIGNvbW1hbmQgdG8gc3RhcnQgdGhlIFZOQyBzZXJ2ZXIuXG4gICAqL1xuICBhc3luYyBnZXRWTkNDb21tYW5kKHdpbmRvd0lkKSB7XG4gICAgbGV0IHB3ZEZsYWcgPSBcIi1ub3B3XCI7XG4gICAgaWYgKHRoaXMubm92bmNBdXRoRW5hYmxlZCkge1xuICAgICAgYXdhaXQgdGhpcy5kZXNrdG9wLmNvbW1hbmRzLnJ1bihcIm1rZGlyIC1wIH4vLnZuY1wiKTtcbiAgICAgIGF3YWl0IHRoaXMuZGVza3RvcC5jb21tYW5kcy5ydW4oXG4gICAgICAgIGB4MTF2bmMgLXN0b3JlcGFzc3dkICR7dGhpcy5wYXNzd29yZH0gfi8udm5jL3Bhc3N3ZGBcbiAgICAgICk7XG4gICAgICBwd2RGbGFnID0gXCItdXNlcHdcIjtcbiAgICB9XG4gICAgcmV0dXJuIGB4MTF2bmMgLWJnIC1kaXNwbGF5ICR7dGhpcy5kZXNrdG9wLmRpc3BsYXl9IC1mb3JldmVyIC13YWl0IDUwIC1zaGFyZWQgLXJmYnBvcnQgJHt0aGlzLnZuY1BvcnR9ICR7cHdkRmxhZ30gMj4vdG1wL3gxMXZuY19zdGRlcnIubG9nYCArICh3aW5kb3dJZCA/IGAgLWlkICR7d2luZG93SWR9YCA6IFwiXCIpO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JQb3J0KHBvcnQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXNrdG9wLndhaXRBbmRWZXJpZnkoXG4gICAgICBgbmV0c3RhdCAtdHVsbiB8IGdyZXAgXCI6JHtwb3J0fSBcImAsXG4gICAgICAocikgPT4gci5zdGRvdXQudHJpbSgpICE9PSBcIlwiXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIFZOQyBzZXJ2ZXIgaXMgcnVubmluZy5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgVk5DIHNlcnZlciBpcyBydW5uaW5nLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tWTkNSdW5uaW5nKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRlc2t0b3AuY29tbWFuZHMucnVuKFwicGdyZXAgLXggeDExdm5jXCIpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdGRvdXQudHJpbSgpICE9PSBcIlwiO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIFVSTCB0byBhIHdlYiBwYWdlIHdpdGggYSBzdHJlYW0gb2YgdGhlIGRlc2t0b3Agc2FuZGJveC5cbiAgICogQHBhcmFtIGF1dG9Db25uZWN0IC0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGNvbm5lY3QgdG8gdGhlIHNlcnZlciBhZnRlciBvcGVuaW5nIHRoZSBVUkwuXG4gICAqIEBwYXJhbSB2aWV3T25seSAtIFdoZXRoZXIgdG8gcHJldmVudCB1c2VyIGludGVyYWN0aW9uIHRocm91Z2ggdGhlIGNsaWVudC5cbiAgICogQHBhcmFtIHJlc2l6ZSAtIFdoZXRoZXIgdG8gcmVzaXplIHRoZSB2aWV3IHdoZW4gdGhlIHdpbmRvdyByZXNpemVzLlxuICAgKiBAcGFyYW0gYXV0aEtleSAtIFRoZSBwYXNzd29yZCB0byB1c2UgdG8gY29ubmVjdCB0byB0aGUgc2VydmVyLlxuICAgKiBAcmV0dXJucyBUaGUgVVJMIHRvIGNvbm5lY3QgdG8gdGhlIFZOQyBzZXJ2ZXIuXG4gICAqL1xuICBnZXRVcmwoe1xuICAgIGF1dG9Db25uZWN0ID0gdHJ1ZSxcbiAgICB2aWV3T25seSA9IGZhbHNlLFxuICAgIHJlc2l6ZSA9IFwic2NhbGVcIixcbiAgICBhdXRoS2V5XG4gIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnVybCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmVyIGlzIG5vdCBydW5uaW5nXCIpO1xuICAgIH1cbiAgICBsZXQgdXJsID0gbmV3IFVSTCh0aGlzLnVybCk7XG4gICAgaWYgKGF1dG9Db25uZWN0KSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImF1dG9jb25uZWN0XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgaWYgKHZpZXdPbmx5KSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInZpZXdfb25seVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicmVzaXplXCIsIHJlc2l6ZSk7XG4gICAgfVxuICAgIGlmIChhdXRoS2V5KSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInBhc3N3b3JkXCIsIGF1dGhLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBWTkMgc2VydmVyLlxuICAgKi9cbiAgYXN5bmMgc3RhcnQob3B0cyA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKGF3YWl0IHRoaXMuY2hlY2tWTkNSdW5uaW5nKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgfVxuICAgIHRoaXMudm5jUG9ydCA9IChfYSA9IG9wdHMudm5jUG9ydCkgIT0gbnVsbCA/IF9hIDogdGhpcy52bmNQb3J0O1xuICAgIHRoaXMucG9ydCA9IChfYiA9IG9wdHMucG9ydCkgIT0gbnVsbCA/IF9iIDogdGhpcy5wb3J0O1xuICAgIHRoaXMubm92bmNBdXRoRW5hYmxlZCA9IChfYyA9IG9wdHMucmVxdWlyZUF1dGgpICE9IG51bGwgPyBfYyA6IHRoaXMubm92bmNBdXRoRW5hYmxlZDtcbiAgICB0aGlzLnBhc3N3b3JkID0gdGhpcy5ub3ZuY0F1dGhFbmFibGVkID8gZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSA6IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IG5ldyBVUkwoYGh0dHBzOi8vJHt0aGlzLmRlc2t0b3AuZ2V0SG9zdCh0aGlzLnBvcnQpfS92bmMuaHRtbGApO1xuICAgIGNvbnN0IHZuY0NvbW1hbmQgPSBhd2FpdCB0aGlzLmdldFZOQ0NvbW1hbmQob3B0cy53aW5kb3dJZCk7XG4gICAgYXdhaXQgdGhpcy5kZXNrdG9wLmNvbW1hbmRzLnJ1bih2bmNDb21tYW5kKTtcbiAgICB0aGlzLm5vdm5jSGFuZGxlID0gYXdhaXQgdGhpcy5kZXNrdG9wLmNvbW1hbmRzLnJ1bih0aGlzLm5vdm5jQ29tbWFuZCwge1xuICAgICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgIHRpbWVvdXRNczogMFxuICAgIH0pO1xuICAgIGlmICghYXdhaXQgdGhpcy53YWl0Rm9yUG9ydCh0aGlzLnBvcnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc3RhcnQgbm9WTkMgc2VydmVyXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGUgVk5DIHNlcnZlci5cbiAgICovXG4gIGFzeW5jIHN0b3AoKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuY2hlY2tWTkNSdW5uaW5nKCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVza3RvcC5jb21tYW5kcy5ydW4oXCJwa2lsbCB4MTF2bmNcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm5vdm5jSGFuZGxlKSB7XG4gICAgICBhd2FpdCB0aGlzLm5vdm5jSGFuZGxlLmtpbGwoKTtcbiAgICAgIHRoaXMubm92bmNIYW5kbGUgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIFNhbmRib3hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@e2b/desktop/dist/index.mjs\n");

/***/ })

};
;