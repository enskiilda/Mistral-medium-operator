"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch";
exports.ids = ["vendor-chunks/openapi-fetch"];
exports.modules = {

/***/ "(action-browser)/./node_modules/openapi-fetch/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFinalURL: () => (/* binding */ createFinalURL),\n/* harmony export */   createQuerySerializer: () => (/* binding */ createQuerySerializer),\n/* harmony export */   \"default\": () => (/* binding */ createClient),\n/* harmony export */   defaultBodySerializer: () => (/* binding */ defaultBodySerializer),\n/* harmony export */   defaultPathSerializer: () => (/* binding */ defaultPathSerializer),\n/* harmony export */   mergeHeaders: () => (/* binding */ mergeHeaders),\n/* harmony export */   serializeArrayParam: () => (/* binding */ serializeArrayParam),\n/* harmony export */   serializeObjectParam: () => (/* binding */ serializeObjectParam),\n/* harmony export */   serializePrimitiveParam: () => (/* binding */ serializePrimitiveParam)\n/* harmony export */ });\n// settings & const\nconst DEFAULT_HEADERS = {\n  \"Content-Type\": \"application/json\",\n};\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\n/**\n * Add custom parameters to Request object\n */\nclass CustomRequest extends Request {\n  constructor(input, init) {\n    super(input, init);\n\n    // add custom parameters\n    for (const key in init) {\n      if (!(key in this)) {\n        this[key] = init[key];\n      }\n    }\n  }\n}\n\n/**\n * Create an openapi-fetch client.\n * @type {import(\"./index.js\").default}\n */\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    ...baseOptions\n  } = { ...clientOptions };\n  if (baseUrl.endsWith(\"/\")) {\n    baseUrl = baseUrl.substring(0, baseUrl.length - 1);\n  }\n  baseHeaders = mergeHeaders(DEFAULT_HEADERS, baseHeaders);\n  const middlewares = [];\n\n  /**\n   * Per-request fetch (keeps settings created in createClient()\n   * @param {T} url\n   * @param {import('./index.js').FetchOptions<T>} fetchOptions\n   */\n  async function coreFetch(url, fetchOptions) {\n    const {\n      fetch = baseFetch,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      ...init\n    } = fetchOptions || {};\n\n    let querySerializer =\n      typeof globalQuerySerializer === \"function\"\n        ? globalQuerySerializer\n        : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer =\n        typeof requestQuerySerializer === \"function\"\n          ? requestQuerySerializer\n          : createQuerySerializer({\n              ...(typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {}),\n              ...requestQuerySerializer,\n            });\n    }\n\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      headers: mergeHeaders(baseHeaders, headers, params.header),\n    };\n    if (requestInit.body) {\n      requestInit.body = bodySerializer(requestInit.body);\n    }\n    // remove `Content-Type` if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n    if (requestInit.body instanceof FormData) {\n      requestInit.headers.delete(\"Content-Type\");\n    }\n    let request = new CustomRequest(createFinalURL(url, { baseUrl, params, querySerializer }), requestInit);\n    // middleware (request)\n    const mergedOptions = {\n      baseUrl,\n      fetch,\n      parseAs,\n      querySerializer,\n      bodySerializer,\n    };\n    for (const m of middlewares) {\n      if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n        request.schemaPath = url; // (re)attach original URL\n        request.params = params; // (re)attach params\n        const result = await m.onRequest(request, mergedOptions);\n        if (result) {\n          if (!(result instanceof Request)) {\n            throw new Error(\"Middleware must return new Request() when modifying the request\");\n          }\n          request = result;\n        }\n      }\n    }\n\n    // fetch!\n    let response = await fetch(request);\n\n    // middleware (response)\n    // execute in reverse-array order (first priority gets last transform)\n    for (let i = middlewares.length - 1; i >= 0; i--) {\n      const m = middlewares[i];\n      if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n        request.schemaPath = url; // (re)attach original URL\n        request.params = params; // (re)attach params\n        const result = await m.onResponse(response, mergedOptions, request);\n        if (result) {\n          if (!(result instanceof Response)) {\n            throw new Error(\"Middleware must return new Response() when modifying the response\");\n          }\n          response = result;\n        }\n      }\n    }\n\n    // handle empty content\n    // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed\n    if (response.status === 204 || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: {}, response } : { error: {}, response };\n    }\n\n    // parse response (falling back to .text() when necessary)\n    if (response.ok) {\n      // if \"stream\", skip parsing entirely\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n\n    // handle errors\n    let error = await response.text();\n    try {\n      error = JSON.parse(error); // attempt to parse as JSON\n    } catch {\n      // noop\n    }\n    return { error, response };\n  }\n\n  return {\n    /** Call a GET endpoint */\n    async GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    async PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    async POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    async DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    async OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    async HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    async PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    async TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()` or `onResponse()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    },\n  };\n}\n\n// utils\n\n/**\n * Serialize primitive param values\n * @type {import(\"./index.js\").serializePrimitiveParam}\n */\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === undefined || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.\",\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\n\n/**\n * Serialize object param (shallow only)\n * @type {import(\"./index.js\").serializeObjectParam}\n */\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner =\n    {\n      simple: \",\",\n      label: \".\",\n      matrix: \";\",\n    }[options.style] || \"&\";\n\n  // explode: false\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final = values.join(\",\"); // note: values are always joined by comma in explode: false (but joiner can prefix)\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final}`;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      default: {\n        return final;\n      }\n    }\n  }\n\n  // explode: true\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\n\n/**\n * Serialize array param (shallow only)\n * @type {import(\"./index.js\").serializeArrayParam}\n */\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n\n  // explode: false\n  if (options.explode === false) {\n    const joiner = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\"; // note: for arrays, joiners vary wildly based on style + explode behavior\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n\n  // explode: true\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\"\n    ? `${joiner}${values.join(joiner)}`\n    : values.join(joiner);\n}\n\n/**\n * Serialize query params to string\n * @type {import(\"./index.js\").createQuerySerializer}\n */\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === undefined || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\n\n/**\n * Handle different OpenAPI 3.x serialization styles\n * @type {import(\"./index.js\").defaultPathSerializer}\n * @see https://swagger.io/docs/specification/serialization/#path\n */\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === undefined || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${value}` : value);\n  }\n  return nextURL;\n}\n\n/**\n * Serialize body object to string\n * @type {import(\"./index.js\").defaultBodySerializer}\n */\nfunction defaultBodySerializer(body) {\n  return JSON.stringify(body);\n}\n\n/**\n * Construct URL string from baseUrl and handle path and query params\n * @type {import(\"./index.js\").createFinalURL}\n */\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\n\n/**\n * Merge headers a and b, with b taking priority\n * @type {import(\"./index.js\").mergeHeaders}\n */\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== undefined) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcGVuYXBpLWZldGNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLElBQUksSUFBSTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0NBQWtDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsNkJBQTZCLFFBQVEsYUFBYSxJQUFJLFNBQVM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEdBQUcsb0VBQW9FO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxHQUFHLE1BQU07QUFDaEM7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxLQUFLLEdBQUcsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxLQUFLLEdBQUcsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsT0FBTyxFQUFFLE1BQU07QUFDckY7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQXNELHdCQUF3QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsS0FBSyxHQUFHLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxHQUFHLE1BQU07QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1DQUFtQyxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPLEVBQUUsb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkJBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUscUNBQXFDO0FBQ2hGO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCLEVBQUUsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL29wZW5hcGktZmV0Y2gvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXR0aW5ncyAmIGNvbnN0XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7XG4gIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxufTtcblxuY29uc3QgUEFUSF9QQVJBTV9SRSA9IC9cXHtbXnt9XStcXH0vZztcblxuLyoqXG4gKiBBZGQgY3VzdG9tIHBhcmFtZXRlcnMgdG8gUmVxdWVzdCBvYmplY3RcbiAqL1xuY2xhc3MgQ3VzdG9tUmVxdWVzdCBleHRlbmRzIFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgaW5pdCkge1xuICAgIHN1cGVyKGlucHV0LCBpbml0KTtcblxuICAgIC8vIGFkZCBjdXN0b20gcGFyYW1ldGVyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluaXQpIHtcbiAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICB0aGlzW2tleV0gPSBpbml0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9wZW5hcGktZmV0Y2ggY2xpZW50LlxuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuZGVmYXVsdH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBiYXNlVXJsID0gXCJcIixcbiAgICBmZXRjaDogYmFzZUZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IGdsb2JhbFF1ZXJ5U2VyaWFsaXplcixcbiAgICBib2R5U2VyaWFsaXplcjogZ2xvYmFsQm9keVNlcmlhbGl6ZXIsXG4gICAgaGVhZGVyczogYmFzZUhlYWRlcnMsXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfSA9IHsgLi4uY2xpZW50T3B0aW9ucyB9O1xuICBpZiAoYmFzZVVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICBiYXNlVXJsID0gYmFzZVVybC5zdWJzdHJpbmcoMCwgYmFzZVVybC5sZW5ndGggLSAxKTtcbiAgfVxuICBiYXNlSGVhZGVycyA9IG1lcmdlSGVhZGVycyhERUZBVUxUX0hFQURFUlMsIGJhc2VIZWFkZXJzKTtcbiAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcblxuICAvKipcbiAgICogUGVyLXJlcXVlc3QgZmV0Y2ggKGtlZXBzIHNldHRpbmdzIGNyZWF0ZWQgaW4gY3JlYXRlQ2xpZW50KClcbiAgICogQHBhcmFtIHtUfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXguanMnKS5GZXRjaE9wdGlvbnM8VD59IGZldGNoT3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY29yZUZldGNoKHVybCwgZmV0Y2hPcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmV0Y2ggPSBiYXNlRmV0Y2gsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zID0ge30sXG4gICAgICBwYXJzZUFzID0gXCJqc29uXCIsXG4gICAgICBxdWVyeVNlcmlhbGl6ZXI6IHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIsXG4gICAgICBib2R5U2VyaWFsaXplciA9IGdsb2JhbEJvZHlTZXJpYWxpemVyID8/IGRlZmF1bHRCb2R5U2VyaWFsaXplcixcbiAgICAgIC4uLmluaXRcbiAgICB9ID0gZmV0Y2hPcHRpb25zIHx8IHt9O1xuXG4gICAgbGV0IHF1ZXJ5U2VyaWFsaXplciA9XG4gICAgICB0eXBlb2YgZ2xvYmFsUXVlcnlTZXJpYWxpemVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBnbG9iYWxRdWVyeVNlcmlhbGl6ZXJcbiAgICAgICAgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoZ2xvYmFsUXVlcnlTZXJpYWxpemVyKTtcbiAgICBpZiAocmVxdWVzdFF1ZXJ5U2VyaWFsaXplcikge1xuICAgICAgcXVlcnlTZXJpYWxpemVyID1cbiAgICAgICAgdHlwZW9mIHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcmVxdWVzdFF1ZXJ5U2VyaWFsaXplclxuICAgICAgICAgIDogY3JlYXRlUXVlcnlTZXJpYWxpemVyKHtcbiAgICAgICAgICAgICAgLi4uKHR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgOiB7fSksXG4gICAgICAgICAgICAgIC4uLnJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAuLi5pbml0LFxuICAgICAgaGVhZGVyczogbWVyZ2VIZWFkZXJzKGJhc2VIZWFkZXJzLCBoZWFkZXJzLCBwYXJhbXMuaGVhZGVyKSxcbiAgICB9O1xuICAgIGlmIChyZXF1ZXN0SW5pdC5ib2R5KSB7XG4gICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gYm9keVNlcmlhbGl6ZXIocmVxdWVzdEluaXQuYm9keSk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBgQ29udGVudC1UeXBlYCBpZiBzZXJpYWxpemVkIGJvZHkgaXMgRm9ybURhdGE7IGJyb3dzZXIgd2lsbCBjb3JyZWN0bHkgc2V0IENvbnRlbnQtVHlwZSAmIGJvdW5kYXJ5IGV4cHJlc3Npb25cbiAgICBpZiAocmVxdWVzdEluaXQuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzLmRlbGV0ZShcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICB9XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQ3VzdG9tUmVxdWVzdChjcmVhdGVGaW5hbFVSTCh1cmwsIHsgYmFzZVVybCwgcGFyYW1zLCBxdWVyeVNlcmlhbGl6ZXIgfSksIHJlcXVlc3RJbml0KTtcbiAgICAvLyBtaWRkbGV3YXJlIChyZXF1ZXN0KVxuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgICBiYXNlVXJsLFxuICAgICAgZmV0Y2gsXG4gICAgICBwYXJzZUFzLFxuICAgICAgcXVlcnlTZXJpYWxpemVyLFxuICAgICAgYm9keVNlcmlhbGl6ZXIsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZXMpIHtcbiAgICAgIGlmIChtICYmIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtLm9uUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlcXVlc3Quc2NoZW1hUGF0aCA9IHVybDsgLy8gKHJlKWF0dGFjaCBvcmlnaW5hbCBVUkxcbiAgICAgICAgcmVxdWVzdC5wYXJhbXMgPSBwYXJhbXM7IC8vIChyZSlhdHRhY2ggcGFyYW1zXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXF1ZXN0KHJlcXVlc3QsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgbXVzdCByZXR1cm4gbmV3IFJlcXVlc3QoKSB3aGVuIG1vZGlmeWluZyB0aGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdCA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZldGNoIVxuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuXG4gICAgLy8gbWlkZGxld2FyZSAocmVzcG9uc2UpXG4gICAgLy8gZXhlY3V0ZSBpbiByZXZlcnNlLWFycmF5IG9yZGVyIChmaXJzdCBwcmlvcml0eSBnZXRzIGxhc3QgdHJhbnNmb3JtKVxuICAgIGZvciAobGV0IGkgPSBtaWRkbGV3YXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbSA9IG1pZGRsZXdhcmVzW2ldO1xuICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlcXVlc3Quc2NoZW1hUGF0aCA9IHVybDsgLy8gKHJlKWF0dGFjaCBvcmlnaW5hbCBVUkxcbiAgICAgICAgcmVxdWVzdC5wYXJhbXMgPSBwYXJhbXM7IC8vIChyZSlhdHRhY2ggcGFyYW1zXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXNwb25zZShyZXNwb25zZSwgbWVyZ2VkT3B0aW9ucywgcmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgbXVzdCByZXR1cm4gbmV3IFJlc3BvbnNlKCkgd2hlbiBtb2RpZnlpbmcgdGhlIHJlc3BvbnNlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBlbXB0eSBjb250ZW50XG4gICAgLy8gbm90ZTogd2UgcmV0dXJuIGB7fWAgYmVjYXVzZSB3ZSB3YW50IHVzZXIgdHJ1dGh5IGNoZWNrcyBmb3IgYC5kYXRhYCBvciBgLmVycm9yYCB0byBzdWNjZWVkXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyB7IGRhdGE6IHt9LCByZXNwb25zZSB9IDogeyBlcnJvcjoge30sIHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgcmVzcG9uc2UgKGZhbGxpbmcgYmFjayB0byAudGV4dCgpIHdoZW4gbmVjZXNzYXJ5KVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgLy8gaWYgXCJzdHJlYW1cIiwgc2tpcCBwYXJzaW5nIGVudGlyZWx5XG4gICAgICBpZiAocGFyc2VBcyA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5ib2R5LCByZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogYXdhaXQgcmVzcG9uc2VbcGFyc2VBc10oKSwgcmVzcG9uc2UgfTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZXJyb3JzXG4gICAgbGV0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIHRyeSB7XG4gICAgICBlcnJvciA9IEpTT04ucGFyc2UoZXJyb3IpOyAvLyBhdHRlbXB0IHRvIHBhcnNlIGFzIEpTT05cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3IsIHJlc3BvbnNlIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKiBDYWxsIGEgR0VUIGVuZHBvaW50ICovXG4gICAgYXN5bmMgR0VUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkdFVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQVVQgZW5kcG9pbnQgKi9cbiAgICBhc3luYyBQVVQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUFVUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBPU1QgZW5kcG9pbnQgKi9cbiAgICBhc3luYyBQT1NUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBPU1RcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgREVMRVRFIGVuZHBvaW50ICovXG4gICAgYXN5bmMgREVMRVRFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBPUFRJT05TIGVuZHBvaW50ICovXG4gICAgYXN5bmMgT1BUSU9OUyh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJPUFRJT05TXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIEhFQUQgZW5kcG9pbnQgKi9cbiAgICBhc3luYyBIRUFEKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkhFQURcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUEFUQ0ggZW5kcG9pbnQgKi9cbiAgICBhc3luYyBQQVRDSCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQQVRDSFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBUUkFDRSBlbmRwb2ludCAqL1xuICAgIGFzeW5jIFRSQUNFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlRSQUNFXCIgfSk7XG4gICAgfSxcbiAgICAvKiogUmVnaXN0ZXIgbWlkZGxld2FyZSAqL1xuICAgIHVzZSguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG0gIT09IFwib2JqZWN0XCIgfHwgIShcIm9uUmVxdWVzdFwiIGluIG0gfHwgXCJvblJlc3BvbnNlXCIgaW4gbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggb25lIG9mIGBvblJlcXVlc3QoKWAgb3IgYG9uUmVzcG9uc2UoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWlkZGxld2FyZXMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBVbnJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICBlamVjdCguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBjb25zdCBpID0gbWlkZGxld2FyZXMuaW5kZXhPZihtKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgbWlkZGxld2FyZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cblxuLy8gdXRpbHNcblxuLyoqXG4gKiBTZXJpYWxpemUgcHJpbWl0aXZlIHBhcmFtIHZhbHVlc1xuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuc2VyaWFsaXplUHJpbWl0aXZlUGFyYW19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkRlZXBseS1uZXN0ZWQgYXJyYXlzL29iamVjdHMgYXJlbuKAmXQgc3VwcG9ydGVkLiBQcm92aWRlIHlvdXIgb3duIGBxdWVyeVNlcmlhbGl6ZXIoKWAgdG8gaGFuZGxlIHRoZXNlLlwiLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGAke25hbWV9PSR7b3B0aW9ucz8uYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHZhbHVlIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBvYmplY3QgcGFyYW0gKHNoYWxsb3cgb25seSlcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLnNlcmlhbGl6ZU9iamVjdFBhcmFtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgY29uc3Qgam9pbmVyID1cbiAgICB7XG4gICAgICBzaW1wbGU6IFwiLFwiLFxuICAgICAgbGFiZWw6IFwiLlwiLFxuICAgICAgbWF0cml4OiBcIjtcIixcbiAgICB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuXG4gIC8vIGV4cGxvZGU6IGZhbHNlXG4gIGlmIChvcHRpb25zLnN0eWxlICE9PSBcImRlZXBPYmplY3RcIiAmJiBvcHRpb25zLmV4cGxvZGUgPT09IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICB2YWx1ZXMucHVzaChrLCBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZVtrXSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtrXSkpO1xuICAgIH1cbiAgICBjb25zdCBmaW5hbCA9IHZhbHVlcy5qb2luKFwiLFwiKTsgLy8gbm90ZTogdmFsdWVzIGFyZSBhbHdheXMgam9pbmVkIGJ5IGNvbW1hIGluIGV4cGxvZGU6IGZhbHNlIChidXQgam9pbmVyIGNhbiBwcmVmaXgpXG4gICAgc3dpdGNoIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwiZm9ybVwiOiB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfT0ke2ZpbmFsfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGFiZWxcIjoge1xuICAgICAgICByZXR1cm4gYC4ke2ZpbmFsfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWF0cml4XCI6IHtcbiAgICAgICAgcmV0dXJuIGA7JHtuYW1lfT0ke2ZpbmFsfWA7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBmaW5hbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBleHBsb2RlOiB0cnVlXG4gIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IGZpbmFsTmFtZSA9IG9wdGlvbnMuc3R5bGUgPT09IFwiZGVlcE9iamVjdFwiID8gYCR7bmFtZX1bJHtrfV1gIDogaztcbiAgICB2YWx1ZXMucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShmaW5hbE5hbWUsIHZhbHVlW2tdLCBvcHRpb25zKSk7XG4gIH1cbiAgY29uc3QgZmluYWwgPSB2YWx1ZXMuam9pbihqb2luZXIpO1xuICByZXR1cm4gb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibWF0cml4XCIgPyBgJHtqb2luZXJ9JHtmaW5hbH1gIDogZmluYWw7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIGFycmF5IHBhcmFtIChzaGFsbG93IG9ubHkpXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5zZXJpYWxpemVBcnJheVBhcmFtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvLyBleHBsb2RlOiBmYWxzZVxuICBpZiAob3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGNvbnN0IGpvaW5lciA9IHsgZm9ybTogXCIsXCIsIHNwYWNlRGVsaW1pdGVkOiBcIiUyMFwiLCBwaXBlRGVsaW1pdGVkOiBcInxcIiB9W29wdGlvbnMuc3R5bGVdIHx8IFwiLFwiOyAvLyBub3RlOiBmb3IgYXJyYXlzLCBqb2luZXJzIHZhcnkgd2lsZGx5IGJhc2VkIG9uIHN0eWxlICsgZXhwbG9kZSBiZWhhdmlvclxuICAgIGNvbnN0IGZpbmFsID0gKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHZhbHVlIDogdmFsdWUubWFwKCh2KSA9PiBlbmNvZGVVUklDb21wb25lbnQodikpKS5qb2luKGpvaW5lcik7XG4gICAgc3dpdGNoIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwic2ltcGxlXCI6IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgLy8gY2FzZSBcInNwYWNlRGVsaW1pdGVkXCI6XG4gICAgICAvLyBjYXNlIFwicGlwZURlbGltaXRlZFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGV4cGxvZGU6IHRydWVcbiAgY29uc3Qgam9pbmVyID0geyBzaW1wbGU6IFwiLFwiLCBsYWJlbDogXCIuXCIsIG1hdHJpeDogXCI7XCIgfVtvcHRpb25zLnN0eWxlXSB8fCBcIiZcIjtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgIGlmIChvcHRpb25zLnN0eWxlID09PSBcInNpbXBsZVwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIikge1xuICAgICAgdmFsdWVzLnB1c2gob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdiA6IGVuY29kZVVSSUNvbXBvbmVudCh2KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcy5wdXNoKHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHYsIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiXG4gICAgPyBgJHtqb2luZXJ9JHt2YWx1ZXMuam9pbihqb2luZXIpfWBcbiAgICA6IHZhbHVlcy5qb2luKGpvaW5lcik7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIHF1ZXJ5IHBhcmFtcyB0byBzdHJpbmdcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmNyZWF0ZVF1ZXJ5U2VyaWFsaXplcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBxdWVyeVNlcmlhbGl6ZXIocXVlcnlQYXJhbXMpIHtcbiAgICBjb25zdCBzZWFyY2ggPSBbXTtcbiAgICBpZiAocXVlcnlQYXJhbXMgJiYgdHlwZW9mIHF1ZXJ5UGFyYW1zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVBhcmFtc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zPy5hcnJheSxcbiAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZDogb3B0aW9ucz8uYWxsb3dSZXNlcnZlZCB8fCBmYWxzZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHNlYXJjaC5wdXNoKFxuICAgICAgICAgICAgc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IFwiZGVlcE9iamVjdFwiLFxuICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zPy5vYmplY3QsXG4gICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQ6IG9wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaC5wdXNoKHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWFyY2guam9pbihcIiZcIik7XG4gIH07XG59XG5cbi8qKlxuICogSGFuZGxlIGRpZmZlcmVudCBPcGVuQVBJIDMueCBzZXJpYWxpemF0aW9uIHN0eWxlc1xuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuZGVmYXVsdFBhdGhTZXJpYWxpemVyfVxuICogQHNlZSBodHRwczovL3N3YWdnZXIuaW8vZG9jcy9zcGVjaWZpY2F0aW9uL3NlcmlhbGl6YXRpb24vI3BhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRQYXRoU2VyaWFsaXplcihwYXRobmFtZSwgcGF0aFBhcmFtcykge1xuICBsZXQgbmV4dFVSTCA9IHBhdGhuYW1lO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIHBhdGhuYW1lLm1hdGNoKFBBVEhfUEFSQU1fUkUpID8/IFtdKSB7XG4gICAgbGV0IG5hbWUgPSBtYXRjaC5zdWJzdHJpbmcoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGV4cGxvZGUgPSBmYWxzZTtcbiAgICBsZXQgc3R5bGUgPSBcInNpbXBsZVwiO1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgZXhwbG9kZSA9IHRydWU7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHN0eWxlID0gXCJsYWJlbFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKFwiO1wiKSkge1xuICAgICAgc3R5bGUgPSBcIm1hdHJpeFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoIXBhdGhQYXJhbXMgfHwgcGF0aFBhcmFtc1tuYW1lXSA9PT0gdW5kZWZpbmVkIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhdGhQYXJhbXNbbmFtZV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7IHN0eWxlLCBleHBsb2RlIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09PSBcIm1hdHJpeFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBgOyR7c2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIHN0eWxlID09PSBcImxhYmVsXCIgPyBgLiR7dmFsdWV9YCA6IHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV4dFVSTDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgYm9keSBvYmplY3QgdG8gc3RyaW5nXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5kZWZhdWx0Qm9keVNlcmlhbGl6ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIoYm9keSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IFVSTCBzdHJpbmcgZnJvbSBiYXNlVXJsIGFuZCBoYW5kbGUgcGF0aCBhbmQgcXVlcnkgcGFyYW1zXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVGaW5hbFVSTH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpbmFsVVJMKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGxldCBmaW5hbFVSTCA9IGAke29wdGlvbnMuYmFzZVVybH0ke3BhdGhuYW1lfWA7XG4gIGlmIChvcHRpb25zLnBhcmFtcz8ucGF0aCkge1xuICAgIGZpbmFsVVJMID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKGZpbmFsVVJMLCBvcHRpb25zLnBhcmFtcy5wYXRoKTtcbiAgfVxuICBsZXQgc2VhcmNoID0gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5wYXJhbXMucXVlcnkgPz8ge30pO1xuICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgfVxuICBpZiAoc2VhcmNoKSB7XG4gICAgZmluYWxVUkwgKz0gYD8ke3NlYXJjaH1gO1xuICB9XG4gIHJldHVybiBmaW5hbFVSTDtcbn1cblxuLyoqXG4gKiBNZXJnZSBoZWFkZXJzIGEgYW5kIGIsIHdpdGggYiB0YWtpbmcgcHJpb3JpdHlcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLm1lcmdlSGVhZGVyc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5hbGxIZWFkZXJzKSB7XG4gIGNvbnN0IGZpbmFsSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgaCBvZiBhbGxIZWFkZXJzKSB7XG4gICAgaWYgKCFoIHx8IHR5cGVvZiBoICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBoIGluc3RhbmNlb2YgSGVhZGVycyA/IGguZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaCk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgaXRlcmF0b3IpIHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5kZWxldGUoayk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCB2MiBvZiB2KSB7XG4gICAgICAgICAgZmluYWxIZWFkZXJzLmFwcGVuZChrLCB2Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEhlYWRlcnM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/openapi-fetch/dist/index.js\n");

/***/ })

};
;