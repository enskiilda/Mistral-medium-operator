"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/e2b";
exports.ids = ["vendor-chunks/e2b"];
exports.modules = {

/***/ "(action-browser)/./node_modules/e2b/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/e2b/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: () => (/* binding */ ApiClient),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   CommandExitError: () => (/* binding */ CommandExitError),\n/* harmony export */   ConnectionConfig: () => (/* binding */ ConnectionConfig),\n/* harmony export */   FileType: () => (/* binding */ FileType2),\n/* harmony export */   FilesystemEventType: () => (/* binding */ FilesystemEventType),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   NotEnoughSpaceError: () => (/* binding */ NotEnoughSpaceError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError),\n/* harmony export */   Sandbox: () => (/* binding */ Sandbox),\n/* harmony export */   SandboxError: () => (/* binding */ SandboxError),\n/* harmony export */   TemplateError: () => (/* binding */ TemplateError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   getSignature: () => (/* binding */ getSignature)\n/* harmony export */ });\n/* harmony import */ var openapi_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openapi-fetch */ \"(action-browser)/./node_modules/openapi-fetch/dist/index.js\");\n/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! platform */ \"(action-browser)/./node_modules/platform/platform.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/promise-client.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bufbuild/protobuf/codegenv2 */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/codegenv2/file.js\");\n/* harmony import */ var _bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @bufbuild/protobuf/codegenv2 */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/codegenv2/service.js\");\n/* harmony import */ var _bufbuild_protobuf_wkt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @bufbuild/protobuf/wkt */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/wkt/gen/google/protobuf/timestamp_pb.js\");\n/* harmony import */ var compare_versions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! compare-versions */ \"(action-browser)/./node_modules/compare-versions/lib/esm/compareVersions.js\");\n/* harmony import */ var _connectrpc_connect_web__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @connectrpc/connect-web */ \"(action-browser)/./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for(\"Symbol.\" + name);\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __await = function(promise, isYieldStar) {\n  this[0] = promise;\n  this[1] = isYieldStar;\n};\nvar __asyncGenerator = (__this, __arguments, generator) => {\n  var resume = (k, v, yes, no) => {\n    try {\n      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;\n      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === \"return\" ? k : \"next\", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume(\"throw\", e, yes, no));\n    } catch (e) {\n      no(e);\n    }\n  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};\n  return generator = generator.apply(__this, __arguments), it[__knownSymbol(\"asyncIterator\")] = () => it, method(\"next\"), method(\"throw\"), method(\"return\"), it;\n};\nvar __forAwait = (obj, it, method) => (it = obj[__knownSymbol(\"asyncIterator\")]) ? it.call(obj) : (obj = obj[__knownSymbol(\"iterator\")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method(\"next\"), method(\"return\"), it);\n\n// src/api/index.ts\n\n\n// src/api/metadata.ts\n\n\n// package.json\nvar version = \"1.13.2\";\n\n// src/api/metadata.ts\nfunction getRuntime() {\n  var _a2, _b, _c;\n  if (globalThis.Bun) {\n    return { runtime: \"bun\", version: globalThis.Bun.version };\n  }\n  if (globalThis.Deno) {\n    return { runtime: \"deno\", version: globalThis.Deno.version.deno };\n  }\n  if (((_b = (_a2 = globalThis.process) == null ? void 0 : _a2.release) == null ? void 0 : _b.name) === \"node\") {\n    return { runtime: \"node\", version: platform__WEBPACK_IMPORTED_MODULE_1__.version || \"unknown\" };\n  }\n  if (typeof EdgeRuntime === \"string\") {\n    return { runtime: \"vercel-edge\", version: \"unknown\" };\n  }\n  if (((_c = globalThis.navigator) == null ? void 0 : _c.userAgent) === \"Cloudflare-Workers\") {\n    return { runtime: \"cloudflare-worker\", version: \"unknown\" };\n  }\n  if (typeof window !== \"undefined\") {\n    return { runtime: \"browser\", version: platform__WEBPACK_IMPORTED_MODULE_1__.version || \"unknown\" };\n  }\n  return { runtime: \"unknown\", version: \"unknown\" };\n}\nvar { runtime, version: runtimeVersion } = getRuntime();\nvar _a;\nvar defaultHeaders = {\n  browser: typeof window !== \"undefined\" && platform__WEBPACK_IMPORTED_MODULE_1__.name || \"unknown\",\n  lang: \"js\",\n  lang_version: runtimeVersion,\n  package_version: version,\n  publisher: \"e2b\",\n  sdk_runtime: runtime,\n  system: ((_a = platform__WEBPACK_IMPORTED_MODULE_1__.os) == null ? void 0 : _a.family) || \"unknown\"\n};\nfunction getEnvVar(name) {\n  if (runtime === \"deno\") {\n    return Deno.env.get(name);\n  }\n  if (typeof process === \"undefined\") {\n    return \"\";\n  }\n  return process.env[name];\n}\n\n// src/errors.ts\nfunction formatSandboxTimeoutError(message) {\n  return new TimeoutError(\n    `${message}: This error is likely due to sandbox timeout. You can modify the sandbox timeout by passing 'timeoutMs' when starting the sandbox or calling '.setTimeout' on the sandbox with the desired timeout.`\n  );\n}\nvar SandboxError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SandboxError\";\n  }\n};\nvar TimeoutError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"TimeoutError\";\n  }\n};\nvar InvalidArgumentError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"InvalidArgumentError\";\n  }\n};\nvar NotEnoughSpaceError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"NotEnoughSpaceError\";\n  }\n};\nvar NotFoundError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"NotFoundError\";\n  }\n};\nvar AuthenticationError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"AuthenticationError\";\n  }\n};\nvar TemplateError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"TemplateError\";\n  }\n};\nvar RateLimitError = class extends SandboxError {\n  constructor(message) {\n    super(message);\n    this.name = \"RateLimitError\";\n  }\n};\n\n// src/logs.ts\nfunction formatLog(log) {\n  return JSON.parse(JSON.stringify(log));\n}\nfunction createRpcLogger(logger) {\n  function logEach(stream) {\n    return __asyncGenerator(this, null, function* () {\n      var _a2;\n      try {\n        for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {\n          const m = temp.value;\n          (_a2 = logger.debug) == null ? void 0 : _a2.call(logger, \"Response stream:\", formatLog(m));\n          yield m;\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && (yield new __await(temp.call(iter)));\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n    });\n  }\n  return (next) => async (req) => {\n    var _a2, _b;\n    (_a2 = logger.info) == null ? void 0 : _a2.call(logger, `Request: POST ${req.url}`);\n    const res = await next(req);\n    if (res.stream) {\n      return __spreadProps(__spreadValues({}, res), {\n        message: logEach(res.message)\n      });\n    } else {\n      (_b = logger.info) == null ? void 0 : _b.call(logger, \"Response:\", formatLog(res.message));\n    }\n    return res;\n  };\n}\nfunction createApiLogger(logger) {\n  return {\n    async onRequest(req) {\n      var _a2;\n      (_a2 = logger.info) == null ? void 0 : _a2.call(logger, `Request ${req.method} ${req.url}`);\n      return req;\n    },\n    async onResponse(res) {\n      var _a2, _b;\n      if (res.status >= 400) {\n        (_a2 = logger.error) == null ? void 0 : _a2.call(logger, \"Response:\", res.status, res.statusText);\n      } else {\n        (_b = logger.info) == null ? void 0 : _b.call(logger, \"Response:\", res.status, res.statusText);\n      }\n      return res;\n    }\n  };\n}\n\n// src/api/index.ts\nfunction handleApiError(response) {\n  var _a2, _b;\n  if (!response.error) {\n    return;\n  }\n  if (response.response.status === 429) {\n    return new RateLimitError(\"Rate limit exceeded, please try again later.\");\n  }\n  const message = (_b = (_a2 = response.error) == null ? void 0 : _a2.message) != null ? _b : response.error;\n  return new SandboxError(`${response.response.status}: ${message}`);\n}\nvar ApiClient = class {\n  constructor(config, opts = { requireAccessToken: false, requireApiKey: true }) {\n    if (!(opts == null ? void 0 : opts.requireApiKey) && !config.apiKey) {\n      throw new AuthenticationError(\n        \"API key is required, please visit the Team tab at https://e2b.dev/dashboard to get your API key. You can either set the environment variable `E2B_API_KEY` or you can pass it directly to the sandbox like Sandbox.create({ apiKey: 'e2b_...' })\"\n      );\n    }\n    if ((opts == null ? void 0 : opts.requireAccessToken) && !config.accessToken) {\n      throw new AuthenticationError(\n        \"Access token is required, please visit the Personal tab at https://e2b.dev/dashboard to get your access token. You can set the environment variable `E2B_ACCESS_TOKEN` or pass the `accessToken` in options.\"\n      );\n    }\n    this.api = (0,openapi_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      baseUrl: config.apiUrl,\n      // keepalive: true, // TODO: Return keepalive\n      headers: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultHeaders), config.apiKey && { \"X-API-KEY\": config.apiKey }), config.accessToken && {\n        Authorization: `Bearer ${config.accessToken}`\n      }), config.headers)\n    });\n    if (config.logger) {\n      this.api.use(createApiLogger(config.logger));\n    }\n  }\n};\n\n// src/connectionConfig.ts\nvar REQUEST_TIMEOUT_MS = 6e4;\nvar KEEPALIVE_PING_INTERVAL_SEC = 50;\nvar KEEPALIVE_PING_HEADER = \"Keepalive-Ping-Interval\";\nvar ConnectionConfig = class _ConnectionConfig {\n  constructor(opts) {\n    var _a2;\n    this.apiKey = (opts == null ? void 0 : opts.apiKey) || _ConnectionConfig.apiKey;\n    this.debug = (opts == null ? void 0 : opts.debug) || _ConnectionConfig.debug;\n    this.domain = (opts == null ? void 0 : opts.domain) || _ConnectionConfig.domain;\n    this.accessToken = (opts == null ? void 0 : opts.accessToken) || _ConnectionConfig.accessToken;\n    this.requestTimeoutMs = (_a2 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a2 : REQUEST_TIMEOUT_MS;\n    this.logger = opts == null ? void 0 : opts.logger;\n    this.headers = (opts == null ? void 0 : opts.headers) || {};\n    this.headers[\"User-Agent\"] = `e2b-js-sdk/${version}`;\n    this.apiUrl = this.debug ? \"http://localhost:3000\" : `https://api.${this.domain}`;\n  }\n  static get domain() {\n    return getEnvVar(\"E2B_DOMAIN\") || \"e2b.app\";\n  }\n  static get debug() {\n    return (getEnvVar(\"E2B_DEBUG\") || \"false\").toLowerCase() === \"true\";\n  }\n  static get apiKey() {\n    return getEnvVar(\"E2B_API_KEY\");\n  }\n  static get accessToken() {\n    return getEnvVar(\"E2B_ACCESS_TOKEN\");\n  }\n  getSignal(requestTimeoutMs) {\n    const timeout = requestTimeoutMs != null ? requestTimeoutMs : this.requestTimeoutMs;\n    return timeout ? AbortSignal.timeout(timeout) : void 0;\n  }\n};\nvar defaultUsername = \"user\";\n\n// src/utils.ts\nasync function sha256(data) {\n  if (typeof crypto !== \"undefined\") {\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(data);\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", dataBuffer);\n    const hashArray = new Uint8Array(hashBuffer);\n    return btoa(String.fromCharCode(...hashArray));\n  }\n  const { createHash } = __require(\"node:crypto\");\n  const hash = createHash(\"sha256\").update(data, \"utf8\").digest();\n  return hash.toString(\"base64\");\n}\n\n// src/sandbox/signature.ts\nasync function getSignature({\n  path,\n  operation,\n  user,\n  expirationInSeconds,\n  envdAccessToken\n}) {\n  if (!envdAccessToken) {\n    throw new Error(\n      \"Access token is not set and signature cannot be generated!\"\n    );\n  }\n  const signatureExpiration = expirationInSeconds ? Math.floor(Date.now() / 1e3) + expirationInSeconds : null;\n  let signatureRaw;\n  if (signatureExpiration === null) {\n    signatureRaw = `${path}:${operation}:${user}:${envdAccessToken}`;\n  } else {\n    signatureRaw = `${path}:${operation}:${user}:${envdAccessToken}:${signatureExpiration.toString()}`;\n  }\n  const hashBase64 = await sha256(signatureRaw);\n  const signature = \"v1_\" + hashBase64.replace(/=+$/, \"\");\n  return {\n    signature,\n    expiration: signatureExpiration\n  };\n}\n\n// src/sandbox/filesystem/index.ts\n\n\n// src/envd/api.ts\n\n\nasync function handleEnvdApiError(res) {\n  var _a2;\n  if (!res.error) {\n    return;\n  }\n  const message = typeof res.error == \"string\" ? res.error : ((_a2 = res.error) == null ? void 0 : _a2.message) || await res.response.text();\n  switch (res.response.status) {\n    case 400:\n      return new InvalidArgumentError(message);\n    case 401:\n      return new AuthenticationError(message);\n    case 404:\n      return new NotFoundError(message);\n    case 429:\n      return new SandboxError(\n        `${res.response.status}: ${message}: The requests are being rate limited.`\n      );\n    case 502:\n      return formatSandboxTimeoutError(message);\n    case 507:\n      return new NotEnoughSpaceError(message);\n    default:\n      return new SandboxError(`${res.response.status}: ${message}`);\n  }\n}\nasync function handleProcessStartEvent(events) {\n  var _a2;\n  let startEvent;\n  try {\n    startEvent = (await events[Symbol.asyncIterator]().next()).value;\n  } catch (err) {\n    if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n      if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unavailable) {\n        throw new NotFoundError(\"Sandbox is probably not running anymore\");\n      }\n    }\n    throw err;\n  }\n  if (((_a2 = startEvent.event) == null ? void 0 : _a2.event.case) !== \"start\") {\n    throw new Error(\"Expected start event\");\n  }\n  return startEvent.event.event.value.pid;\n}\nasync function handleWatchDirStartEvent(events) {\n  var _a2;\n  let startEvent;\n  try {\n    startEvent = (await events[Symbol.asyncIterator]().next()).value;\n  } catch (err) {\n    if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n      if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unavailable) {\n        throw new NotFoundError(\"Sandbox is probably not running anymore\");\n      }\n    }\n    throw err;\n  }\n  if (((_a2 = startEvent.event) == null ? void 0 : _a2.case) !== \"start\") {\n    throw new Error(\"Expected start event\");\n  }\n  return startEvent.event.value;\n}\nvar EnvdApiClient = class {\n  constructor(config, metadata) {\n    this.api = (0,openapi_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      baseUrl: config.apiUrl,\n      fetch: config == null ? void 0 : config.fetch,\n      headers: config == null ? void 0 : config.headers\n      // keepalive: true, // TODO: Return keepalive\n    });\n    this.version = metadata.version;\n    if (config.logger) {\n      this.api.use(createApiLogger(config.logger));\n    }\n  }\n};\n\n// src/envd/rpc.ts\n\nfunction handleRpcError(err) {\n  if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n    switch (err.code) {\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.InvalidArgument:\n        return new InvalidArgumentError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unauthenticated:\n        return new AuthenticationError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound:\n        return new NotFoundError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Unavailable:\n        return formatSandboxTimeoutError(err.message);\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.Canceled:\n        return new TimeoutError(\n          `${err.message}: This error is likely due to exceeding 'requestTimeoutMs'. You can pass the request timeout value as an option when making the request.`\n        );\n      case _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.DeadlineExceeded:\n        return new TimeoutError(\n          `${err.message}: This error is likely due to exceeding 'timeoutMs' \\u2014 the total time a long running request (like command execution or directory watch) can be active. It can be modified by passing 'timeoutMs' when making the request. Use '0' to disable the timeout.`\n        );\n      default:\n        return new SandboxError(`${err.code}: ${err.message}`);\n    }\n  }\n  return err;\n}\nfunction encode64(value) {\n  switch (runtime) {\n    case \"deno\":\n      return btoa(value);\n    case \"node\":\n      return Buffer.from(value).toString(\"base64\");\n    case \"bun\":\n      return Buffer.from(value).toString(\"base64\");\n    default:\n      return btoa(value);\n  }\n}\nfunction authenticationHeader(username) {\n  const value = `${username || defaultUsername}:`;\n  const encoded = encode64(value);\n  return { \"Authorization\": `Basic ${encoded}` };\n}\n\n// src/envd/filesystem/filesystem_pb.ts\n\n\nvar file_filesystem_filesystem = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_4__.fileDesc)(\"ChtmaWxlc3lzdGVtL2ZpbGVzeXN0ZW0ucHJvdG8SCmZpbGVzeXN0ZW0iMgoLTW92ZVJlcXVlc3QSDgoGc291cmNlGAEgASgJEhMKC2Rlc3RpbmF0aW9uGAIgASgJIjQKDE1vdmVSZXNwb25zZRIkCgVlbnRyeRgBIAEoCzIVLmZpbGVzeXN0ZW0uRW50cnlJbmZvIh4KDk1ha2VEaXJSZXF1ZXN0EgwKBHBhdGgYASABKAkiNwoPTWFrZURpclJlc3BvbnNlEiQKBWVudHJ5GAEgASgLMhUuZmlsZXN5c3RlbS5FbnRyeUluZm8iHQoNUmVtb3ZlUmVxdWVzdBIMCgRwYXRoGAEgASgJIhAKDlJlbW92ZVJlc3BvbnNlIhsKC1N0YXRSZXF1ZXN0EgwKBHBhdGgYASABKAkiNAoMU3RhdFJlc3BvbnNlEiQKBWVudHJ5GAEgASgLMhUuZmlsZXN5c3RlbS5FbnRyeUluZm8i/QEKCUVudHJ5SW5mbxIMCgRuYW1lGAEgASgJEiIKBHR5cGUYAiABKA4yFC5maWxlc3lzdGVtLkZpbGVUeXBlEgwKBHBhdGgYAyABKAkSDAoEc2l6ZRgEIAEoAxIMCgRtb2RlGAUgASgNEhMKC3Blcm1pc3Npb25zGAYgASgJEg0KBW93bmVyGAcgASgJEg0KBWdyb3VwGAggASgJEjEKDW1vZGlmaWVkX3RpbWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhsKDnN5bWxpbmtfdGFyZ2V0GAogASgJSACIAQFCEQoPX3N5bWxpbmtfdGFyZ2V0Ii0KDkxpc3REaXJSZXF1ZXN0EgwKBHBhdGgYASABKAkSDQoFZGVwdGgYAiABKA0iOQoPTGlzdERpclJlc3BvbnNlEiYKB2VudHJpZXMYASADKAsyFS5maWxlc3lzdGVtLkVudHJ5SW5mbyIyCg9XYXRjaERpclJlcXVlc3QSDAoEcGF0aBgBIAEoCRIRCglyZWN1cnNpdmUYAiABKAgiRAoPRmlsZXN5c3RlbUV2ZW50EgwKBG5hbWUYASABKAkSIwoEdHlwZRgCIAEoDjIVLmZpbGVzeXN0ZW0uRXZlbnRUeXBlIuABChBXYXRjaERpclJlc3BvbnNlEjgKBXN0YXJ0GAEgASgLMicuZmlsZXN5c3RlbS5XYXRjaERpclJlc3BvbnNlLlN0YXJ0RXZlbnRIABIxCgpmaWxlc3lzdGVtGAIgASgLMhsuZmlsZXN5c3RlbS5GaWxlc3lzdGVtRXZlbnRIABI7CglrZWVwYWxpdmUYAyABKAsyJi5maWxlc3lzdGVtLldhdGNoRGlyUmVzcG9uc2UuS2VlcEFsaXZlSAAaDAoKU3RhcnRFdmVudBoLCglLZWVwQWxpdmVCBwoFZXZlbnQiNwoUQ3JlYXRlV2F0Y2hlclJlcXVlc3QSDAoEcGF0aBgBIAEoCRIRCglyZWN1cnNpdmUYAiABKAgiKwoVQ3JlYXRlV2F0Y2hlclJlc3BvbnNlEhIKCndhdGNoZXJfaWQYASABKAkiLQoXR2V0V2F0Y2hlckV2ZW50c1JlcXVlc3QSEgoKd2F0Y2hlcl9pZBgBIAEoCSJHChhHZXRXYXRjaGVyRXZlbnRzUmVzcG9uc2USKwoGZXZlbnRzGAEgAygLMhsuZmlsZXN5c3RlbS5GaWxlc3lzdGVtRXZlbnQiKgoUUmVtb3ZlV2F0Y2hlclJlcXVlc3QSEgoKd2F0Y2hlcl9pZBgBIAEoCSIXChVSZW1vdmVXYXRjaGVyUmVzcG9uc2UqUgoIRmlsZVR5cGUSGQoVRklMRV9UWVBFX1VOU1BFQ0lGSUVEEAASEgoORklMRV9UWVBFX0ZJTEUQARIXChNGSUxFX1RZUEVfRElSRUNUT1JZEAIqmAEKCUV2ZW50VHlwZRIaChZFVkVOVF9UWVBFX1VOU1BFQ0lGSUVEEAASFQoRRVZFTlRfVFlQRV9DUkVBVEUQARIUChBFVkVOVF9UWVBFX1dSSVRFEAISFQoRRVZFTlRfVFlQRV9SRU1PVkUQAxIVChFFVkVOVF9UWVBFX1JFTkFNRRAEEhQKEEVWRU5UX1RZUEVfQ0hNT0QQBTKfBQoKRmlsZXN5c3RlbRI5CgRTdGF0EhcuZmlsZXN5c3RlbS5TdGF0UmVxdWVzdBoYLmZpbGVzeXN0ZW0uU3RhdFJlc3BvbnNlEkIKB01ha2VEaXISGi5maWxlc3lzdGVtLk1ha2VEaXJSZXF1ZXN0GhsuZmlsZXN5c3RlbS5NYWtlRGlyUmVzcG9uc2USOQoETW92ZRIXLmZpbGVzeXN0ZW0uTW92ZVJlcXVlc3QaGC5maWxlc3lzdGVtLk1vdmVSZXNwb25zZRJCCgdMaXN0RGlyEhouZmlsZXN5c3RlbS5MaXN0RGlyUmVxdWVzdBobLmZpbGVzeXN0ZW0uTGlzdERpclJlc3BvbnNlEj8KBlJlbW92ZRIZLmZpbGVzeXN0ZW0uUmVtb3ZlUmVxdWVzdBoaLmZpbGVzeXN0ZW0uUmVtb3ZlUmVzcG9uc2USRwoIV2F0Y2hEaXISGy5maWxlc3lzdGVtLldhdGNoRGlyUmVxdWVzdBocLmZpbGVzeXN0ZW0uV2F0Y2hEaXJSZXNwb25zZTABElQKDUNyZWF0ZVdhdGNoZXISIC5maWxlc3lzdGVtLkNyZWF0ZVdhdGNoZXJSZXF1ZXN0GiEuZmlsZXN5c3RlbS5DcmVhdGVXYXRjaGVyUmVzcG9uc2USXQoQR2V0V2F0Y2hlckV2ZW50cxIjLmZpbGVzeXN0ZW0uR2V0V2F0Y2hlckV2ZW50c1JlcXVlc3QaJC5maWxlc3lzdGVtLkdldFdhdGNoZXJFdmVudHNSZXNwb25zZRJUCg1SZW1vdmVXYXRjaGVyEiAuZmlsZXN5c3RlbS5SZW1vdmVXYXRjaGVyUmVxdWVzdBohLmZpbGVzeXN0ZW0uUmVtb3ZlV2F0Y2hlclJlc3BvbnNlQmkKDmNvbS5maWxlc3lzdGVtQg9GaWxlc3lzdGVtUHJvdG9QAaICA0ZYWKoCCkZpbGVzeXN0ZW3KAgpGaWxlc3lzdGVt4gIWRmlsZXN5c3RlbVxHUEJNZXRhZGF0YeoCCkZpbGVzeXN0ZW1iBnByb3RvMw\", [_bufbuild_protobuf_wkt__WEBPACK_IMPORTED_MODULE_5__.file_google_protobuf_timestamp]);\nvar Filesystem = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_6__.serviceDesc)(file_filesystem_filesystem, 0);\n\n// src/sandbox/filesystem/watchHandle.ts\nvar FilesystemEventType = /* @__PURE__ */ ((FilesystemEventType2) => {\n  FilesystemEventType2[\"CHMOD\"] = \"chmod\";\n  FilesystemEventType2[\"CREATE\"] = \"create\";\n  FilesystemEventType2[\"REMOVE\"] = \"remove\";\n  FilesystemEventType2[\"RENAME\"] = \"rename\";\n  FilesystemEventType2[\"WRITE\"] = \"write\";\n  return FilesystemEventType2;\n})(FilesystemEventType || {});\nfunction mapEventType(type) {\n  switch (type) {\n    case 5 /* CHMOD */:\n      return \"chmod\" /* CHMOD */;\n    case 1 /* CREATE */:\n      return \"create\" /* CREATE */;\n    case 3 /* REMOVE */:\n      return \"remove\" /* REMOVE */;\n    case 4 /* RENAME */:\n      return \"rename\" /* RENAME */;\n    case 2 /* WRITE */:\n      return \"write\" /* WRITE */;\n  }\n}\nvar WatchHandle = class {\n  constructor(handleStop, events, onEvent, onExit) {\n    this.handleStop = handleStop;\n    this.events = events;\n    this.onEvent = onEvent;\n    this.onExit = onExit;\n    this.handleEvents();\n  }\n  /**\n   * Stop watching the directory.\n   */\n  async stop() {\n    this.handleStop();\n  }\n  iterateEvents() {\n    return __asyncGenerator(this, null, function* () {\n      try {\n        try {\n          for (var iter = __forAwait(this.events), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {\n            const event = temp.value;\n            switch (event.event.case) {\n              case \"filesystem\":\n                yield event.event;\n                break;\n            }\n          }\n        } catch (temp) {\n          error = [temp];\n        } finally {\n          try {\n            more && (temp = iter.return) && (yield new __await(temp.call(iter)));\n          } finally {\n            if (error)\n              throw error[0];\n          }\n        }\n      } catch (err) {\n        throw handleRpcError(err);\n      }\n    });\n  }\n  async handleEvents() {\n    var _a2, _b, _c;\n    try {\n      try {\n        for (var iter = __forAwait(this.iterateEvents()), more, temp, error; more = !(temp = await iter.next()).done; more = false) {\n          const event = temp.value;\n          const eventType = mapEventType(event.value.type);\n          if (eventType === void 0) {\n            continue;\n          }\n          (_a2 = this.onEvent) == null ? void 0 : _a2.call(this, {\n            name: event.value.name,\n            type: eventType\n          });\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && await temp.call(iter);\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n      (_b = this.onExit) == null ? void 0 : _b.call(this);\n    } catch (err) {\n      (_c = this.onExit) == null ? void 0 : _c.call(this, err);\n    }\n  }\n};\n\n// src/sandbox/filesystem/index.ts\n\n\n// src/envd/versions.ts\nvar ENVD_VERSION_RECURSIVE_WATCH = \"0.1.4\";\n\n// src/sandbox/filesystem/index.ts\nvar FileType2 = /* @__PURE__ */ ((FileType3) => {\n  FileType3[\"FILE\"] = \"file\";\n  FileType3[\"DIR\"] = \"dir\";\n  return FileType3;\n})(FileType2 || {});\nfunction mapFileType(fileType) {\n  switch (fileType) {\n    case 2 /* DIRECTORY */:\n      return \"dir\" /* DIR */;\n    case 1 /* FILE */:\n      return \"file\" /* FILE */;\n  }\n}\nfunction mapModifiedTime(modifiedTime) {\n  if (!modifiedTime) return void 0;\n  return new Date(\n    Number(modifiedTime.seconds) * 1e3 + Math.floor(modifiedTime.nanos / 1e6)\n  );\n}\nvar Filesystem2 = class {\n  constructor(transport, envdApi, connectionConfig) {\n    this.envdApi = envdApi;\n    this.connectionConfig = connectionConfig;\n    this.defaultWatchTimeout = 6e4;\n    // 60 seconds\n    this.defaultWatchRecursive = false;\n    this.rpc = (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__.createClient)(Filesystem, transport);\n  }\n  async read(path, opts) {\n    var _a2;\n    const format = (_a2 = opts == null ? void 0 : opts.format) != null ? _a2 : \"text\";\n    const res = await this.envdApi.api.GET(\"/files\", {\n      params: {\n        query: {\n          path,\n          username: (opts == null ? void 0 : opts.user) || defaultUsername\n        }\n      },\n      parseAs: format === \"bytes\" ? \"arrayBuffer\" : format,\n      signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = await handleEnvdApiError(res);\n    if (err) {\n      throw err;\n    }\n    if (format === \"bytes\") {\n      return new Uint8Array(res.data);\n    }\n    if (res.response.headers.get(\"content-length\") === \"0\") {\n      return \"\";\n    }\n    return res.data;\n  }\n  async write(pathOrFiles, dataOrOpts, opts) {\n    if (typeof pathOrFiles !== \"string\" && !Array.isArray(pathOrFiles)) {\n      throw new Error(\"Path or files are required\");\n    }\n    if (typeof pathOrFiles === \"string\" && Array.isArray(dataOrOpts)) {\n      throw new Error(\n        \"Cannot specify both path and array of files. You have to specify either path and data for a single file or an array for multiple files.\"\n      );\n    }\n    const { path, writeOpts, writeFiles } = typeof pathOrFiles === \"string\" ? {\n      path: pathOrFiles,\n      writeOpts: opts,\n      writeFiles: [\n        {\n          data: dataOrOpts\n        }\n      ]\n    } : {\n      path: void 0,\n      writeOpts: dataOrOpts,\n      writeFiles: pathOrFiles\n    };\n    if (writeFiles.length === 0) return [];\n    const blobs = await Promise.all(\n      writeFiles.map((f) => new Response(f.data).blob())\n    );\n    const res = await this.envdApi.api.POST(\"/files\", {\n      params: {\n        query: {\n          path,\n          username: (writeOpts == null ? void 0 : writeOpts.user) || defaultUsername\n        }\n      },\n      bodySerializer() {\n        return blobs.reduce((fd, blob, i) => {\n          fd.append(\"file\", blob, writeFiles[i].path);\n          return fd;\n        }, new FormData());\n      },\n      body: {},\n      headers: {\n        \"Content-Type\": \"multipart/form-data\",\n        \"Bun-Content-Type\": \"temporary-fix\"\n        // https://github.com/oven-sh/bun/issues/14988\n      }\n    });\n    const err = await handleEnvdApiError(res);\n    if (err) {\n      throw err;\n    }\n    const files = res.data;\n    if (!files) {\n      throw new Error(\"Expected to receive information about written file\");\n    }\n    return files.length === 1 && path ? files[0] : files;\n  }\n  /**\n   * List entries in a directory.\n   *\n   * @param path path to the directory.\n   * @param opts connection options.\n   *\n   * @returns list of entries in the sandbox filesystem directory.\n   */\n  async list(path, opts) {\n    var _a2;\n    if (typeof (opts == null ? void 0 : opts.depth) === \"number\" && opts.depth < 1) {\n      throw new InvalidArgumentError(\"depth should be at least one\");\n    }\n    try {\n      const res = await this.rpc.listDir(\n        {\n          path,\n          depth: (_a2 = opts == null ? void 0 : opts.depth) != null ? _a2 : 1\n        },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      const entries = [];\n      for (const e of res.entries) {\n        const type = mapFileType(e.type);\n        if (type) {\n          entries.push({\n            name: e.name,\n            type,\n            path: e.path,\n            size: Number(e.size),\n            mode: e.mode,\n            permissions: e.permissions,\n            owner: e.owner,\n            group: e.group,\n            modifiedTime: mapModifiedTime(e.modifiedTime),\n            symlinkTarget: e.symlinkTarget\n          });\n        }\n      }\n      return entries;\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Create a new directory and all directories along the way if needed on the specified path.\n   *\n   * @param path path to a new directory. For example '/dirA/dirB' when creating 'dirB'.\n   * @param opts connection options.\n   *\n   * @returns `true` if the directory was created, `false` if it already exists.\n   */\n  async makeDir(path, opts) {\n    try {\n      await this.rpc.makeDir(\n        { path },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.AlreadyExists) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldPath path to the file or directory to rename.\n   * @param newPath new path for the file or directory.\n   * @param opts connection options.\n   *\n   * @returns information about renamed file or directory.\n   */\n  async rename(oldPath, newPath, opts) {\n    try {\n      const res = await this.rpc.move(\n        {\n          source: oldPath,\n          destination: newPath\n        },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      const entry = res.entry;\n      if (!entry) {\n        throw new Error(\"Expected to receive information about moved object\");\n      }\n      return {\n        name: entry.name,\n        type: mapFileType(entry.type),\n        path: entry.path,\n        size: Number(entry.size),\n        mode: entry.mode,\n        permissions: entry.permissions,\n        owner: entry.owner,\n        group: entry.group,\n        modifiedTime: mapModifiedTime(entry.modifiedTime),\n        symlinkTarget: entry.symlinkTarget\n      };\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Remove a file or directory.\n   *\n   * @param path path to a file or directory.\n   * @param opts connection options.\n   */\n  async remove(path, opts) {\n    try {\n      await this.rpc.remove(\n        { path },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Check if a file or a directory exists.\n   *\n   * @param path path to a file or a directory\n   * @param opts connection options.\n   *\n   * @returns `true` if the file or directory exists, `false` otherwise\n   */\n  async exists(path, opts) {\n    try {\n      await this.rpc.stat(\n        { path },\n        {\n          headers: authenticationHeader(opts == null ? void 0 : opts.user),\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Get information about a file or directory.\n   *\n   * @param path path to a file or directory.\n   * @param opts connection options.\n   *\n   * @returns information about the file or directory like name, type, and path.\n   */\n  async getInfo(path, opts) {\n    try {\n      const res = await this.rpc.stat(\n        { path },\n        { headers: authenticationHeader(opts == null ? void 0 : opts.user) }\n      );\n      if (!res.entry) {\n        throw new Error(\n          \"Expected to receive information about the file or directory\"\n        );\n      }\n      return {\n        name: res.entry.name,\n        type: mapFileType(res.entry.type),\n        path: res.entry.path,\n        size: Number(res.entry.size),\n        mode: res.entry.mode,\n        permissions: res.entry.permissions,\n        owner: res.entry.owner,\n        group: res.entry.group,\n        modifiedTime: mapModifiedTime(res.entry.modifiedTime),\n        symlinkTarget: res.entry.symlinkTarget\n      };\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Start watching a directory for filesystem events.\n   *\n   * @param path path to directory to watch.\n   * @param onEvent callback to call when an event in the directory occurs.\n   * @param opts connection options.\n   *\n   * @returns `WatchHandle` object for stopping watching directory.\n   */\n  async watchDir(path, onEvent, opts) {\n    var _a2, _b, _c;\n    if ((opts == null ? void 0 : opts.recursive) && this.envdApi.version && (0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(this.envdApi.version, ENVD_VERSION_RECURSIVE_WATCH) < 0) {\n      throw new TemplateError(\n        \"You need to update the template to use recursive watching. You can do this by running `e2b template build` in the directory with the template.\"\n      );\n    }\n    const requestTimeoutMs = (_a2 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a2 : this.connectionConfig.requestTimeoutMs;\n    const controller = new AbortController();\n    const reqTimeout = requestTimeoutMs ? setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs) : void 0;\n    const events = this.rpc.watchDir(\n      {\n        path,\n        recursive: (_b = opts == null ? void 0 : opts.recursive) != null ? _b : this.defaultWatchRecursive\n      },\n      {\n        headers: __spreadProps(__spreadValues({}, authenticationHeader(opts == null ? void 0 : opts.user)), {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        }),\n        signal: controller.signal,\n        timeoutMs: (_c = opts == null ? void 0 : opts.timeoutMs) != null ? _c : this.defaultWatchTimeout\n      }\n    );\n    try {\n      await handleWatchDirStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new WatchHandle(\n        () => controller.abort(),\n        events,\n        onEvent,\n        opts == null ? void 0 : opts.onExit\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n};\n\n// src/sandbox/commands/commandHandle.ts\nvar CommandExitError = class extends SandboxError {\n  constructor(result) {\n    super(result.error);\n    this.result = result;\n    this.name = \"CommandExitError\";\n  }\n  /**\n   * Command execution exit code.\n   * `0` if the command finished successfully.\n   */\n  get exitCode() {\n    return this.result.exitCode;\n  }\n  /**\n   * Error message from command execution.\n   */\n  get error() {\n    return this.result.error;\n  }\n  /**\n   * Command execution stdout output.\n   */\n  get stdout() {\n    return this.result.stdout;\n  }\n  /**\n   * Command execution stderr output.\n   */\n  get stderr() {\n    return this.result.stderr;\n  }\n};\nvar CommandHandle = class {\n  /**\n   * @hidden\n   * @internal\n   * @access protected\n   */\n  constructor(pid, handleDisconnect, handleKill, events, onStdout, onStderr, onPty) {\n    this.pid = pid;\n    this.handleDisconnect = handleDisconnect;\n    this.handleKill = handleKill;\n    this.events = events;\n    this.onStdout = onStdout;\n    this.onStderr = onStderr;\n    this.onPty = onPty;\n    this._stdout = \"\";\n    this._stderr = \"\";\n    this._wait = this.handleEvents();\n  }\n  /**\n   * Command execution exit code.\n   * `0` if the command finished successfully.\n   * \n   * It is `undefined` if the command is still running.\n   */\n  get exitCode() {\n    var _a2;\n    return (_a2 = this.result) == null ? void 0 : _a2.exitCode;\n  }\n  /**\n   * Error message from command execution.\n   */\n  get error() {\n    var _a2;\n    return (_a2 = this.result) == null ? void 0 : _a2.error;\n  }\n  /**\n   * Command execution stderr output.\n   */\n  get stderr() {\n    return this._stderr;\n  }\n  /**\n   * Command execution stdout output.\n   */\n  get stdout() {\n    return this._stdout;\n  }\n  /**\n   * Wait for the command to finish and return the result.\n   * If the command exits with a non-zero exit code, it throws a `CommandExitError`.\n   * \n   * @returns `CommandResult` result of command execution.\n   */\n  async wait() {\n    await this._wait;\n    if (this.iterationError) {\n      throw this.iterationError;\n    }\n    if (!this.result) {\n      throw new SandboxError(\"Process exited without a result\");\n    }\n    if (this.result.exitCode !== 0) {\n      throw new CommandExitError(this.result);\n    }\n    return this.result;\n  }\n  /**\n   * Disconnect from the command.\n   * \n   * The command is not killed, but SDK stops receiving events from the command.\n   * You can reconnect to the command using {@link Commands.connect}.\n   */\n  async disconnect() {\n    this.handleDisconnect();\n  }\n  /**\n   * Kill the command.\n   * It uses `SIGKILL` signal to kill the command.\n   * \n   * @returns `true` if the command was killed successfully, `false` if the command was not found.\n   */\n  async kill() {\n    return await this.handleKill();\n  }\n  iterateEvents() {\n    return __asyncGenerator(this, null, function* () {\n      var _a2;\n      try {\n        for (var iter = __forAwait(this.events), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {\n          const event = temp.value;\n          const e = (_a2 = event == null ? void 0 : event.event) == null ? void 0 : _a2.event;\n          let out;\n          switch (e == null ? void 0 : e.case) {\n            case \"data\":\n              switch (e.value.output.case) {\n                case \"stdout\":\n                  out = new TextDecoder().decode(e.value.output.value);\n                  this._stdout += out;\n                  yield [out, null, null];\n                  break;\n                case \"stderr\":\n                  out = new TextDecoder().decode(e.value.output.value);\n                  this._stderr += out;\n                  yield [null, out, null];\n                  break;\n                case \"pty\":\n                  yield [null, null, e.value.output.value];\n                  break;\n              }\n              break;\n            case \"end\":\n              this.result = {\n                exitCode: e.value.exitCode,\n                error: e.value.error,\n                stdout: this.stdout,\n                stderr: this.stderr\n              };\n              break;\n          }\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && (yield new __await(temp.call(iter)));\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n    });\n  }\n  async handleEvents() {\n    var _a2, _b, _c;\n    try {\n      try {\n        for (var iter = __forAwait(this.iterateEvents()), more, temp, error; more = !(temp = await iter.next()).done; more = false) {\n          const [stdout, stderr, pty] = temp.value;\n          if (stdout !== null) {\n            (_a2 = this.onStdout) == null ? void 0 : _a2.call(this, stdout);\n          } else if (stderr !== null) {\n            (_b = this.onStderr) == null ? void 0 : _b.call(this, stderr);\n          } else if (pty) {\n            (_c = this.onPty) == null ? void 0 : _c.call(this, pty);\n          }\n        }\n      } catch (temp) {\n        error = [temp];\n      } finally {\n        try {\n          more && (temp = iter.return) && await temp.call(iter);\n        } finally {\n          if (error)\n            throw error[0];\n        }\n      }\n    } catch (e) {\n      this.iterationError = handleRpcError(e);\n    }\n  }\n};\n\n// src/sandbox/index.ts\n\n\n// src/sandbox/commands/index.ts\n\n\n// src/envd/process/process_pb.ts\n\nvar file_process_process = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_4__.fileDesc)(\"ChVwcm9jZXNzL3Byb2Nlc3MucHJvdG8SB3Byb2Nlc3MiSgoDUFRZEh8KBHNpemUYASABKAsyES5wcm9jZXNzLlBUWS5TaXplGiIKBFNpemUSDAoEY29scxgBIAEoDRIMCgRyb3dzGAIgASgNIqEBCg1Qcm9jZXNzQ29uZmlnEgsKA2NtZBgBIAEoCRIMCgRhcmdzGAIgAygJEi4KBGVudnMYAyADKAsyIC5wcm9jZXNzLlByb2Nlc3NDb25maWcuRW52c0VudHJ5EhAKA2N3ZBgEIAEoCUgAiAEBGisKCUVudnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBQgYKBF9jd2QiDQoLTGlzdFJlcXVlc3QiXAoLUHJvY2Vzc0luZm8SJgoGY29uZmlnGAEgASgLMhYucHJvY2Vzcy5Qcm9jZXNzQ29uZmlnEgsKA3BpZBgCIAEoDRIQCgN0YWcYAyABKAlIAIgBAUIGCgRfdGFnIjcKDExpc3RSZXNwb25zZRInCglwcm9jZXNzZXMYASADKAsyFC5wcm9jZXNzLlByb2Nlc3NJbmZvInkKDFN0YXJ0UmVxdWVzdBInCgdwcm9jZXNzGAEgASgLMhYucHJvY2Vzcy5Qcm9jZXNzQ29uZmlnEh4KA3B0eRgCIAEoCzIMLnByb2Nlc3MuUFRZSACIAQESEAoDdGFnGAMgASgJSAGIAQFCBgoEX3B0eUIGCgRfdGFnImIKDVVwZGF0ZVJlcXVlc3QSKQoHcHJvY2VzcxgBIAEoCzIYLnByb2Nlc3MuUHJvY2Vzc1NlbGVjdG9yEh4KA3B0eRgCIAEoCzIMLnByb2Nlc3MuUFRZSACIAQFCBgoEX3B0eSIQCg5VcGRhdGVSZXNwb25zZSKvAwoMUHJvY2Vzc0V2ZW50EjEKBXN0YXJ0GAEgASgLMiAucHJvY2Vzcy5Qcm9jZXNzRXZlbnQuU3RhcnRFdmVudEgAEi8KBGRhdGEYAiABKAsyHy5wcm9jZXNzLlByb2Nlc3NFdmVudC5EYXRhRXZlbnRIABItCgNlbmQYAyABKAsyHi5wcm9jZXNzLlByb2Nlc3NFdmVudC5FbmRFdmVudEgAEjQKCWtlZXBhbGl2ZRgEIAEoCzIfLnByb2Nlc3MuUHJvY2Vzc0V2ZW50LktlZXBBbGl2ZUgAGhkKClN0YXJ0RXZlbnQSCwoDcGlkGAEgASgNGkgKCURhdGFFdmVudBIQCgZzdGRvdXQYASABKAxIABIQCgZzdGRlcnIYAiABKAxIABINCgNwdHkYAyABKAxIAEIICgZvdXRwdXQaWwoIRW5kRXZlbnQSEQoJZXhpdF9jb2RlGAEgASgREg4KBmV4aXRlZBgCIAEoCBIOCgZzdGF0dXMYAyABKAkSEgoFZXJyb3IYBCABKAlIAIgBAUIICgZfZXJyb3IaCwoJS2VlcEFsaXZlQgcKBWV2ZW50IjUKDVN0YXJ0UmVzcG9uc2USJAoFZXZlbnQYASABKAsyFS5wcm9jZXNzLlByb2Nlc3NFdmVudCI3Cg9Db25uZWN0UmVzcG9uc2USJAoFZXZlbnQYASABKAsyFS5wcm9jZXNzLlByb2Nlc3NFdmVudCJjChBTZW5kSW5wdXRSZXF1ZXN0EikKB3Byb2Nlc3MYASABKAsyGC5wcm9jZXNzLlByb2Nlc3NTZWxlY3RvchIkCgVpbnB1dBgCIAEoCzIVLnByb2Nlc3MuUHJvY2Vzc0lucHV0IhMKEVNlbmRJbnB1dFJlc3BvbnNlIjcKDFByb2Nlc3NJbnB1dBIPCgVzdGRpbhgBIAEoDEgAEg0KA3B0eRgCIAEoDEgAQgcKBWlucHV0IsICChJTdHJlYW1JbnB1dFJlcXVlc3QSNwoFc3RhcnQYASABKAsyJi5wcm9jZXNzLlN0cmVhbUlucHV0UmVxdWVzdC5TdGFydEV2ZW50SAASNQoEZGF0YRgCIAEoCzIlLnByb2Nlc3MuU3RyZWFtSW5wdXRSZXF1ZXN0LkRhdGFFdmVudEgAEjoKCWtlZXBhbGl2ZRgDIAEoCzIlLnByb2Nlc3MuU3RyZWFtSW5wdXRSZXF1ZXN0LktlZXBBbGl2ZUgAGjcKClN0YXJ0RXZlbnQSKQoHcHJvY2VzcxgBIAEoCzIYLnByb2Nlc3MuUHJvY2Vzc1NlbGVjdG9yGjEKCURhdGFFdmVudBIkCgVpbnB1dBgCIAEoCzIVLnByb2Nlc3MuUHJvY2Vzc0lucHV0GgsKCUtlZXBBbGl2ZUIHCgVldmVudCIVChNTdHJlYW1JbnB1dFJlc3BvbnNlIl8KEVNlbmRTaWduYWxSZXF1ZXN0EikKB3Byb2Nlc3MYASABKAsyGC5wcm9jZXNzLlByb2Nlc3NTZWxlY3RvchIfCgZzaWduYWwYAiABKA4yDy5wcm9jZXNzLlNpZ25hbCIUChJTZW5kU2lnbmFsUmVzcG9uc2UiOwoOQ29ubmVjdFJlcXVlc3QSKQoHcHJvY2VzcxgBIAEoCzIYLnByb2Nlc3MuUHJvY2Vzc1NlbGVjdG9yIjsKD1Byb2Nlc3NTZWxlY3RvchINCgNwaWQYASABKA1IABINCgN0YWcYAiABKAlIAEIKCghzZWxlY3RvcipICgZTaWduYWwSFgoSU0lHTkFMX1VOU1BFQ0lGSUVEEAASEgoOU0lHTkFMX1NJR1RFUk0QDxISCg5TSUdOQUxfU0lHS0lMTBAJMsoDCgdQcm9jZXNzEjMKBExpc3QSFC5wcm9jZXNzLkxpc3RSZXF1ZXN0GhUucHJvY2Vzcy5MaXN0UmVzcG9uc2USPgoHQ29ubmVjdBIXLnByb2Nlc3MuQ29ubmVjdFJlcXVlc3QaGC5wcm9jZXNzLkNvbm5lY3RSZXNwb25zZTABEjgKBVN0YXJ0EhUucHJvY2Vzcy5TdGFydFJlcXVlc3QaFi5wcm9jZXNzLlN0YXJ0UmVzcG9uc2UwARI5CgZVcGRhdGUSFi5wcm9jZXNzLlVwZGF0ZVJlcXVlc3QaFy5wcm9jZXNzLlVwZGF0ZVJlc3BvbnNlEkoKC1N0cmVhbUlucHV0EhsucHJvY2Vzcy5TdHJlYW1JbnB1dFJlcXVlc3QaHC5wcm9jZXNzLlN0cmVhbUlucHV0UmVzcG9uc2UoARJCCglTZW5kSW5wdXQSGS5wcm9jZXNzLlNlbmRJbnB1dFJlcXVlc3QaGi5wcm9jZXNzLlNlbmRJbnB1dFJlc3BvbnNlEkUKClNlbmRTaWduYWwSGi5wcm9jZXNzLlNlbmRTaWduYWxSZXF1ZXN0GhsucHJvY2Vzcy5TZW5kU2lnbmFsUmVzcG9uc2VCVwoLY29tLnByb2Nlc3NCDFByb2Nlc3NQcm90b1ABogIDUFhYqgIHUHJvY2Vzc8oCB1Byb2Nlc3PiAhNQcm9jZXNzXEdQQk1ldGFkYXRh6gIHUHJvY2Vzc2IGcHJvdG8z\");\nvar Process = /* @__PURE__ */ (0,_bufbuild_protobuf_codegenv2__WEBPACK_IMPORTED_MODULE_6__.serviceDesc)(file_process_process, 0);\n\n// src/sandbox/commands/pty.ts\n\nvar Pty = class {\n  constructor(transport, connectionConfig) {\n    this.transport = transport;\n    this.connectionConfig = connectionConfig;\n    this.rpc = (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__.createClient)(Process, this.transport);\n  }\n  /**\n   * Create a new PTY (pseudo-terminal).\n   *\n   * @param opts options for creating the PTY.\n   * \n   * @returns handle to interact with the PTY.\n   */\n  async create(opts) {\n    var _a2, _b, _c;\n    const requestTimeoutMs = (_a2 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a2 : this.connectionConfig.requestTimeoutMs;\n    const envs = (_b = opts == null ? void 0 : opts.envs) != null ? _b : {};\n    envs.TERM = \"xterm-256color\";\n    const controller = new AbortController();\n    const reqTimeout = setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs);\n    const events = this.rpc.start(\n      {\n        process: {\n          cmd: \"/bin/bash\",\n          args: [\"-i\", \"-l\"],\n          envs,\n          cwd: opts == null ? void 0 : opts.cwd\n        },\n        pty: {\n          size: {\n            cols: opts.cols,\n            rows: opts.rows\n          }\n        }\n      },\n      {\n        headers: __spreadProps(__spreadValues({}, authenticationHeader(opts == null ? void 0 : opts.user)), {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        }),\n        signal: controller.signal,\n        timeoutMs: (_c = opts == null ? void 0 : opts.timeoutMs) != null ? _c : 6e4\n      }\n    );\n    try {\n      const pid = await handleProcessStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new CommandHandle(\n        pid,\n        () => controller.abort(),\n        () => this.kill(pid),\n        events,\n        void 0,\n        void 0,\n        opts.onData\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Send input to a PTY.\n   *\n   * @param pid process ID of the PTY.\n   * @param data input data to send to the PTY.\n   * @param opts connection options.\n   */\n  async sendInput(pid, data, opts) {\n    try {\n      await this.rpc.sendInput(\n        {\n          input: {\n            input: {\n              case: \"pty\",\n              value: data\n            }\n          },\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          }\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Resize PTY.\n   * Call this when the terminal window is resized and the number of columns and rows has changed.\n   *\n   * @param pid process ID of the PTY.\n   * @param size new size of the PTY.\n   * @param opts connection options.\n   */\n  async resize(pid, size, opts) {\n    try {\n      await this.rpc.update(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          pty: {\n            size\n          }\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Kill a running PTY specified by process ID.\n   * It uses `SIGKILL` signal to kill the PTY.\n   *\n   * @param pid process ID of the PTY.\n   * @param opts connection options.\n   * \n   * @returns `true` if the PTY was killed, `false` if the PTY was not found.\n   */\n  async kill(pid, opts) {\n    try {\n      await this.rpc.sendSignal(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          signal: 9 /* SIGKILL */\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n};\n\n// src/sandbox/commands/index.ts\nvar Commands = class {\n  // 60 seconds\n  constructor(transport, connectionConfig) {\n    this.connectionConfig = connectionConfig;\n    this.defaultProcessConnectionTimeout = 6e4;\n    this.rpc = (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_7__.createClient)(Process, transport);\n  }\n  /**\n   * List all running commands and PTY sessions.\n   *\n   * @param opts connection options.\n   *\n   * @returns list of running commands and PTY sessions.\n   */\n  async list(opts) {\n    try {\n      const res = await this.rpc.list(\n        {},\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return res.processes.map((p) => __spreadValues(__spreadProps(__spreadValues({\n        pid: p.pid\n      }, p.tag && { tag: p.tag }), {\n        args: p.config.args,\n        envs: p.config.envs,\n        cmd: p.config.cmd\n      }), p.config.cwd && { cwd: p.config.cwd }));\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Send data to command stdin.\n   *\n   * @param pid process ID of the command. You can get the list of running commands using {@link Commands.list}.\n   * @param data data to send to the command.\n   * @param opts connection options.\n   */\n  async sendStdin(pid, data, opts) {\n    try {\n      await this.rpc.sendInput(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          input: {\n            input: {\n              case: \"stdin\",\n              value: new TextEncoder().encode(data)\n            }\n          }\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Kill a running command specified by its process ID.\n   * It uses `SIGKILL` signal to kill the command.\n   *\n   * @param pid process ID of the command. You can get the list of running commands using {@link Commands.list}.\n   * @param opts connection options.\n   *\n   * @returns `true` if the command was killed, `false` if the command was not found.\n   */\n  async kill(pid, opts) {\n    try {\n      await this.rpc.sendSignal(\n        {\n          process: {\n            selector: {\n              case: \"pid\",\n              value: pid\n            }\n          },\n          signal: 9 /* SIGKILL */\n        },\n        {\n          signal: this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n        }\n      );\n      return true;\n    } catch (err) {\n      if (err instanceof _connectrpc_connect__WEBPACK_IMPORTED_MODULE_2__.ConnectError) {\n        if (err.code === _connectrpc_connect__WEBPACK_IMPORTED_MODULE_3__.Code.NotFound) {\n          return false;\n        }\n      }\n      throw handleRpcError(err);\n    }\n  }\n  /**\n   * Connect to a running command.\n   * You can use {@link CommandHandle.wait} to wait for the command to finish and get execution results.\n   *\n   * @param pid process ID of the command to connect to. You can get the list of running commands using {@link Commands.list}.\n   * @param opts connection options.\n   *\n   * @returns `CommandHandle` handle to interact with the running command.\n   */\n  async connect(pid, opts) {\n    var _a2, _b;\n    const requestTimeoutMs = (_a2 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a2 : this.connectionConfig.requestTimeoutMs;\n    const controller = new AbortController();\n    const reqTimeout = requestTimeoutMs ? setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs) : void 0;\n    const events = this.rpc.connect(\n      {\n        process: {\n          selector: {\n            case: \"pid\",\n            value: pid\n          }\n        }\n      },\n      {\n        signal: controller.signal,\n        headers: {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        },\n        timeoutMs: (_b = opts == null ? void 0 : opts.timeoutMs) != null ? _b : this.defaultProcessConnectionTimeout\n      }\n    );\n    try {\n      const pid2 = await handleProcessStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new CommandHandle(\n        pid2,\n        () => controller.abort(),\n        () => this.kill(pid2),\n        events,\n        opts == null ? void 0 : opts.onStdout,\n        opts == null ? void 0 : opts.onStderr,\n        void 0\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n  async run(cmd, opts) {\n    const proc = await this.start(cmd, opts);\n    return (opts == null ? void 0 : opts.background) ? proc : proc.wait();\n  }\n  async start(cmd, opts) {\n    var _a2, _b;\n    const requestTimeoutMs = (_a2 = opts == null ? void 0 : opts.requestTimeoutMs) != null ? _a2 : this.connectionConfig.requestTimeoutMs;\n    const controller = new AbortController();\n    const reqTimeout = requestTimeoutMs ? setTimeout(() => {\n      controller.abort();\n    }, requestTimeoutMs) : void 0;\n    const events = this.rpc.start(\n      {\n        process: {\n          cmd: \"/bin/bash\",\n          cwd: opts == null ? void 0 : opts.cwd,\n          envs: opts == null ? void 0 : opts.envs,\n          args: [\"-l\", \"-c\", cmd]\n        }\n      },\n      {\n        headers: __spreadProps(__spreadValues({}, authenticationHeader(opts == null ? void 0 : opts.user)), {\n          [KEEPALIVE_PING_HEADER]: KEEPALIVE_PING_INTERVAL_SEC.toString()\n        }),\n        signal: controller.signal,\n        timeoutMs: (_b = opts == null ? void 0 : opts.timeoutMs) != null ? _b : this.defaultProcessConnectionTimeout\n      }\n    );\n    try {\n      const pid = await handleProcessStartEvent(events);\n      clearTimeout(reqTimeout);\n      return new CommandHandle(\n        pid,\n        () => controller.abort(),\n        () => this.kill(pid),\n        events,\n        opts == null ? void 0 : opts.onStdout,\n        opts == null ? void 0 : opts.onStderr,\n        void 0\n      );\n    } catch (err) {\n      throw handleRpcError(err);\n    }\n  }\n};\n\n// src/sandbox/sandboxApi.ts\n\nvar SandboxApi = class {\n  constructor() {\n  }\n  /**\n   * Kill the sandbox specified by sandbox ID.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns `true` if the sandbox was found and killed, `false` otherwise.\n   */\n  static async kill(sandboxId, opts) {\n    var _a2;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.DELETE(\"/sandboxes/{sandboxID}\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    if (((_a2 = res.error) == null ? void 0 : _a2.code) === 404) {\n      return false;\n    }\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return true;\n  }\n  /**\n   * List all running sandboxes.\n   *\n   * @param opts connection options.\n   *\n   * @returns list of running sandboxes.\n   */\n  static async list(opts) {\n    var _a2, _b;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    let metadata = void 0;\n    if (opts == null ? void 0 : opts.query) {\n      if (opts.query.metadata) {\n        const encodedPairs = Object.fromEntries(\n          Object.entries(opts.query.metadata).map(([key, value]) => [\n            encodeURIComponent(key),\n            encodeURIComponent(value)\n          ])\n        );\n        metadata = new URLSearchParams(encodedPairs).toString();\n      }\n    }\n    const res = await client.api.GET(\"/sandboxes\", {\n      params: {\n        query: { metadata }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return (_b = (_a2 = res.data) == null ? void 0 : _a2.map((sandbox) => ({\n      sandboxId: sandbox.sandboxID,\n      templateId: sandbox.templateID,\n      clientId: sandbox.clientID,\n      state: sandbox.state,\n      cpuCount: sandbox.cpuCount,\n      memoryMB: sandbox.memoryMB,\n      alias: sandbox.alias,\n      metadata: sandbox.metadata,\n      startedAt: new Date(sandbox.startedAt),\n      endAt: new Date(sandbox.endAt)\n    }))) != null ? _b : [];\n  }\n  /**\n   * Get sandbox information like sandbox ID, template, metadata, started at/end at date.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns sandbox information.\n   */\n  static async getInfo(sandboxId, opts) {\n    var _a2;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.GET(\"/sandboxes/{sandboxID}\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    if (!res.data) {\n      throw new Error(\"Sandbox not found\");\n    }\n    return __spreadProps(__spreadValues({\n      sandboxId: res.data.sandboxID,\n      sandboxDomain: res.data.domain || void 0,\n      templateId: res.data.templateID\n    }, res.data.alias && { name: res.data.alias }), {\n      metadata: (_a2 = res.data.metadata) != null ? _a2 : {},\n      envdVersion: res.data.envdVersion,\n      envdAccessToken: res.data.envdAccessToken,\n      startedAt: new Date(res.data.startedAt),\n      endAt: new Date(res.data.endAt)\n    });\n  }\n  /**\n   * Get the metrics of the sandbox.\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts sandbox metrics options.\n   *\n   * @returns  List of sandbox metrics containing CPU, memory and disk usage information.\n   */\n  static async getMetrics(sandboxId, opts) {\n    var _a2, _b;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.GET(\"/sandboxes/{sandboxID}/metrics\", {\n      params: {\n        path: {\n          sandboxID: sandboxId,\n          start: opts == null ? void 0 : opts.start,\n          end: opts == null ? void 0 : opts.end\n        }\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    return (_b = (_a2 = res.data) == null ? void 0 : _a2.map((metric) => ({\n      timestamp: new Date(metric.timestamp),\n      cpuUsedPct: metric.cpuUsedPct,\n      cpuCount: metric.cpuCount,\n      memUsed: metric.memUsed,\n      memTotal: metric.memTotal,\n      diskUsed: metric.diskUsed,\n      diskTotal: metric.diskTotal\n    }))) != null ? _b : [];\n  }\n  /**\n   * Set the timeout of the specified sandbox.\n   * After the timeout expires the sandbox will be automatically killed.\n   *\n   * This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to {@link Sandbox.setTimeout}.\n   *\n   * Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.\n   *\n   * @param sandboxId sandbox ID.\n   * @param timeoutMs timeout in **milliseconds**.\n   * @param opts connection options.\n   */\n  static async setTimeout(sandboxId, timeoutMs, opts) {\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.POST(\"/sandboxes/{sandboxID}/timeout\", {\n      params: {\n        path: {\n          sandboxID: sandboxId\n        }\n      },\n      body: {\n        timeout: this.timeoutToSeconds(timeoutMs)\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n  }\n  static async createSandbox(template, timeoutMs, opts) {\n    var _a2;\n    const config = new ConnectionConfig(opts);\n    const client = new ApiClient(config);\n    const res = await client.api.POST(\"/sandboxes\", {\n      body: {\n        autoPause: false,\n        templateID: template,\n        metadata: opts == null ? void 0 : opts.metadata,\n        envVars: opts == null ? void 0 : opts.envs,\n        timeout: this.timeoutToSeconds(timeoutMs),\n        secure: opts == null ? void 0 : opts.secure,\n        allow_internet_access: (_a2 = opts == null ? void 0 : opts.allowInternetAccess) != null ? _a2 : true\n      },\n      signal: config.getSignal(opts == null ? void 0 : opts.requestTimeoutMs)\n    });\n    const err = handleApiError(res);\n    if (err) {\n      throw err;\n    }\n    if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(res.data.envdVersion, \"0.1.0\") < 0) {\n      await this.kill(res.data.sandboxID, opts);\n      throw new TemplateError(\n        \"You need to update the template to use the new SDK. You can do this by running `e2b template build` in the directory with the template.\"\n      );\n    }\n    return {\n      sandboxId: res.data.sandboxID,\n      sandboxDomain: res.data.domain || void 0,\n      envdVersion: res.data.envdVersion,\n      envdAccessToken: res.data.envdAccessToken\n    };\n  }\n  static timeoutToSeconds(timeout) {\n    return Math.ceil(timeout / 1e3);\n  }\n};\n\n// src/sandbox/index.ts\n\nvar _Sandbox = class _Sandbox extends SandboxApi {\n  /**\n   * Use {@link Sandbox.create} to create a new Sandbox instead.\n   *\n   * @hidden\n   * @hide\n   * @internal\n   * @access protected\n   */\n  constructor(opts) {\n    var _a2;\n    super();\n    this.envdPort = 49983;\n    this.connectionConfig = new ConnectionConfig(opts);\n    this.sandboxId = opts.sandboxId;\n    this.sandboxDomain = (_a2 = opts.sandboxDomain) != null ? _a2 : this.connectionConfig.domain;\n    this.envdAccessToken = opts.envdAccessToken;\n    this.envdApiUrl = `${this.connectionConfig.debug ? \"http\" : \"https\"}://${this.getHost(this.envdPort)}`;\n    const rpcTransport = (0,_connectrpc_connect_web__WEBPACK_IMPORTED_MODULE_9__.createConnectTransport)({\n      baseUrl: this.envdApiUrl,\n      useBinaryFormat: false,\n      interceptors: (opts == null ? void 0 : opts.logger) ? [createRpcLogger(opts.logger)] : void 0,\n      fetch: (url, options) => {\n        const headers = new Headers(this.connectionConfig.headers);\n        new Headers(options == null ? void 0 : options.headers).forEach(\n          (value, key) => headers.append(key, value)\n        );\n        if (this.envdAccessToken) {\n          headers.append(\"X-Access-Token\", this.envdAccessToken);\n        }\n        options = __spreadProps(__spreadValues({}, options != null ? options : {}), {\n          headers,\n          redirect: \"follow\"\n        });\n        return fetch(url, options);\n      }\n    });\n    this.envdApi = new EnvdApiClient(\n      {\n        apiUrl: this.envdApiUrl,\n        logger: opts == null ? void 0 : opts.logger,\n        accessToken: this.envdAccessToken,\n        headers: this.envdAccessToken ? { \"X-Access-Token\": this.envdAccessToken } : {}\n      },\n      {\n        version: opts == null ? void 0 : opts.envdVersion\n      }\n    );\n    this.files = new Filesystem2(\n      rpcTransport,\n      this.envdApi,\n      this.connectionConfig\n    );\n    this.commands = new Commands(rpcTransport, this.connectionConfig);\n    this.pty = new Pty(rpcTransport, this.connectionConfig);\n  }\n  static async create(templateOrOpts, opts) {\n    var _a2;\n    const { template, sandboxOpts } = typeof templateOrOpts === \"string\" ? { template: templateOrOpts, sandboxOpts: opts } : { template: this.defaultTemplate, sandboxOpts: templateOrOpts };\n    const config = new ConnectionConfig(sandboxOpts);\n    if (config.debug) {\n      return new this(__spreadValues({\n        sandboxId: \"debug_sandbox_id\"\n      }, config));\n    } else {\n      const sandbox = await this.createSandbox(\n        template,\n        (_a2 = sandboxOpts == null ? void 0 : sandboxOpts.timeoutMs) != null ? _a2 : this.defaultSandboxTimeoutMs,\n        sandboxOpts\n      );\n      return new this(__spreadValues(__spreadValues({}, sandbox), config));\n    }\n  }\n  /**\n   * Connect to an existing sandbox.\n   * With sandbox ID you can connect to the same sandbox from different places or environments (serverless functions, etc).\n   *\n   * @param sandboxId sandbox ID.\n   * @param opts connection options.\n   *\n   * @returns sandbox instance for the existing sandbox.\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * const sandboxId = sandbox.sandboxId\n   *\n   * // Connect to the same sandbox.\n   * const sameSandbox = await Sandbox.connect(sandboxId)\n   * ```\n   */\n  static async connect(sandboxId, opts) {\n    const config = new ConnectionConfig(opts);\n    const info = await this.getInfo(sandboxId, opts);\n    return new this(__spreadValues({\n      sandboxId,\n      sandboxDomain: info.sandboxDomain,\n      envdAccessToken: info.envdAccessToken,\n      envdVersion: info.envdVersion\n    }, config));\n  }\n  /**\n   * Get the host address for the specified sandbox port.\n   * You can then use this address to connect to the sandbox port from outside the sandbox via HTTP or WebSocket.\n   *\n   * @param port number of the port in the sandbox.\n   *\n   * @returns host address of the sandbox port.\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * // Start an HTTP server\n   * await sandbox.commands.exec('python3 -m http.server 3000')\n   * // Get the hostname of the HTTP server\n   * const serverURL = sandbox.getHost(3000)\n   * ```\n   */\n  getHost(port) {\n    if (this.connectionConfig.debug) {\n      return `localhost:${port}`;\n    }\n    return `${port}-${this.sandboxId}.${this.sandboxDomain}`;\n  }\n  /**\n   * Check if the sandbox is running.\n   *\n   * @returns `true` if the sandbox is running, `false` otherwise.\n   *\n   * @example\n   * ```ts\n   * const sandbox = await Sandbox.create()\n   * await sandbox.isRunning() // Returns true\n   *\n   * await sandbox.kill()\n   * await sandbox.isRunning() // Returns false\n   * ```\n   */\n  async isRunning(opts) {\n    const signal = this.connectionConfig.getSignal(opts == null ? void 0 : opts.requestTimeoutMs);\n    const res = await this.envdApi.api.GET(\"/health\", {\n      signal\n    });\n    if (res.response.status == 502) {\n      return false;\n    }\n    const err = await handleEnvdApiError(res);\n    if (err) {\n      throw err;\n    }\n    return true;\n  }\n  /**\n   * Set the timeout of the sandbox.\n   * After the timeout expires the sandbox will be automatically killed.\n   *\n   * This method can extend or reduce the sandbox timeout set when creating the sandbox or from the last call to `.setTimeout`.\n   * Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.\n   *\n   * @param timeoutMs timeout in **milliseconds**.\n   * @param opts connection options.\n   */\n  async setTimeout(timeoutMs, opts) {\n    if (this.connectionConfig.debug) {\n      return;\n    }\n    await _Sandbox.setTimeout(this.sandboxId, timeoutMs, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  /**\n   * Kill the sandbox.\n   *\n   * @param opts connection options.\n   */\n  async kill(opts) {\n    if (this.connectionConfig.debug) {\n      return;\n    }\n    await _Sandbox.kill(this.sandboxId, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  /**\n   * Get the URL to upload a file to the sandbox.\n   *\n   * You have to send a POST request to this URL with the file as multipart/form-data.\n   *\n   * @param path path to the file in the sandbox.\n   *\n   * @param opts download url options.\n   *\n   * @returns URL for uploading file.\n   */\n  async uploadUrl(path, opts) {\n    var _a2;\n    opts = opts != null ? opts : {};\n    const useSignature = !!this.envdAccessToken;\n    if (!useSignature && opts.useSignatureExpiration != void 0) {\n      throw new Error(\n        \"Signature expiration can be used only when sandbox is created as secured.\"\n      );\n    }\n    const username = (_a2 = opts.user) != null ? _a2 : defaultUsername;\n    const filePath = path != null ? path : \"\";\n    const fileUrl = this.fileUrl(filePath, username);\n    if (useSignature) {\n      const url = new URL(fileUrl);\n      const sig = await getSignature({\n        path: filePath,\n        operation: \"write\",\n        user: username,\n        expirationInSeconds: opts.useSignatureExpiration,\n        envdAccessToken: this.envdAccessToken\n      });\n      url.searchParams.set(\"signature\", sig.signature);\n      if (sig.expiration) {\n        url.searchParams.set(\"signature_expiration\", sig.expiration.toString());\n      }\n      return url.toString();\n    }\n    return fileUrl;\n  }\n  /**\n   * Get the URL to download a file from the sandbox.\n   *\n   * @param path path to the file in the sandbox.\n   *\n   * @param opts download url options.\n   *\n   * @returns URL for downloading file.\n   */\n  async downloadUrl(path, opts) {\n    var _a2;\n    opts = opts != null ? opts : {};\n    const useSignature = !!this.envdAccessToken;\n    if (!useSignature && opts.useSignatureExpiration != void 0) {\n      throw new Error(\n        \"Signature expiration can be used only when sandbox is created as secured.\"\n      );\n    }\n    const username = (_a2 = opts.user) != null ? _a2 : defaultUsername;\n    const fileUrl = this.fileUrl(path, username);\n    if (useSignature) {\n      const url = new URL(fileUrl);\n      const sig = await getSignature({\n        path,\n        operation: \"read\",\n        user: username,\n        expirationInSeconds: opts.useSignatureExpiration,\n        envdAccessToken: this.envdAccessToken\n      });\n      url.searchParams.set(\"signature\", sig.signature);\n      if (sig.expiration) {\n        url.searchParams.set(\"signature_expiration\", sig.expiration.toString());\n      }\n      return url.toString();\n    }\n    return fileUrl;\n  }\n  /**\n   * Get sandbox information like sandbox ID, template, metadata, started at/end at date.\n   *\n   * @param opts connection options.\n   *\n   * @returns information about the sandbox\n   */\n  async getInfo(opts) {\n    return await _Sandbox.getInfo(this.sandboxId, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  /**\n   * Get the metrics of the sandbox.\n   *\n   * @param opts connection options.\n   *\n   * @returns  List of sandbox metrics containing CPU, memory and disk usage information.\n   */\n  async getMetrics(opts) {\n    var _a2, _b;\n    if (this.envdApi.version) {\n      if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(this.envdApi.version, \"0.1.5\") < 0) {\n        throw new SandboxError(\n          \"You need to update the template to use the new SDK. You can do this by running `e2b template build` in the directory with the template.\"\n        );\n      }\n      if ((0,compare_versions__WEBPACK_IMPORTED_MODULE_8__.compareVersions)(this.envdApi.version, \"0.2.4\") < 0) {\n        (_b = (_a2 = this.connectionConfig.logger) == null ? void 0 : _a2.warn) == null ? void 0 : _b.call(\n          _a2,\n          \"Disk metrics are not supported in this version of the sandbox, please rebuild the template to get disk metrics.\"\n        );\n      }\n    }\n    return await _Sandbox.getMetrics(this.sandboxId, __spreadValues(__spreadValues({}, this.connectionConfig), opts));\n  }\n  fileUrl(path, username) {\n    const url = new URL(\"/files\", this.envdApiUrl);\n    url.searchParams.set(\"username\", username != null ? username : defaultUsername);\n    if (path) {\n      url.searchParams.set(\"path\", path);\n    }\n    return url.toString();\n  }\n};\n_Sandbox.defaultTemplate = \"base\";\n_Sandbox.defaultSandboxTimeoutMs = 3e5;\nvar Sandbox = _Sandbox;\n\n// src/index.ts\nvar src_default = Sandbox;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lMmIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RywrQkFBK0Isc0JBQXNCLGdCQUFnQjtBQUNsTCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0pBQWtKLDBMQUEwTCxhQUFhOztBQUV6VjtBQUN5Qzs7QUFFekM7QUFDZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSwwQkFBMEIsNkNBQWdCO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsNkNBQWdCO0FBQzFEO0FBQ0EsV0FBVztBQUNYO0FBQ0EsTUFBTSxtQ0FBbUM7QUFDekM7QUFDQTtBQUNBLDRDQUE0QywwQ0FBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sUUFBUTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsaUVBQWU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRUFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFrQkU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvZTJiL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fa25vd25TeW1ib2wgPSAobmFtZSwgc3ltYm9sKSA9PiAoc3ltYm9sID0gU3ltYm9sW25hbWVdKSA/IHN5bWJvbCA6IFN5bWJvbC5mb3IoXCJTeW1ib2wuXCIgKyBuYW1lKTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX3JlcXVpcmUgPSAvKiBAX19QVVJFX18gKi8gKCh4KSA9PiB0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgUHJveHkoeCwge1xuICBnZXQ6IChhLCBiKSA9PiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlIDogYSlbYl1cbn0pIDogeCkoZnVuY3Rpb24oeCkge1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRocm93IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgXCInICsgeCArICdcIiBpcyBub3Qgc3VwcG9ydGVkJyk7XG59KTtcbnZhciBfX2F3YWl0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNZaWVsZFN0YXIpIHtcbiAgdGhpc1swXSA9IHByb21pc2U7XG4gIHRoaXNbMV0gPSBpc1lpZWxkU3Rhcjtcbn07XG52YXIgX19hc3luY0dlbmVyYXRvciA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgdmFyIHJlc3VtZSA9IChrLCB2LCB5ZXMsIG5vKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB4ID0gZ2VuZXJhdG9yW2tdKHYpLCBpc0F3YWl0ID0gKHYgPSB4LnZhbHVlKSBpbnN0YW5jZW9mIF9fYXdhaXQsIGRvbmUgPSB4LmRvbmU7XG4gICAgICBQcm9taXNlLnJlc29sdmUoaXNBd2FpdCA/IHZbMF0gOiB2KS50aGVuKCh5KSA9PiBpc0F3YWl0ID8gcmVzdW1lKGsgPT09IFwicmV0dXJuXCIgPyBrIDogXCJuZXh0XCIsIHZbMV0gPyB7IGRvbmU6IHkuZG9uZSwgdmFsdWU6IHkudmFsdWUgfSA6IHksIHllcywgbm8pIDogeWVzKHsgdmFsdWU6IHksIGRvbmUgfSkpLmNhdGNoKChlKSA9PiByZXN1bWUoXCJ0aHJvd1wiLCBlLCB5ZXMsIG5vKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbm8oZSk7XG4gICAgfVxuICB9LCBtZXRob2QgPSAoaykgPT4gaXRba10gPSAoeCkgPT4gbmV3IFByb21pc2UoKHllcywgbm8pID0+IHJlc3VtZShrLCB4LCB5ZXMsIG5vKSksIGl0ID0ge307XG4gIHJldHVybiBnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cyksIGl0W19fa25vd25TeW1ib2woXCJhc3luY0l0ZXJhdG9yXCIpXSA9ICgpID0+IGl0LCBtZXRob2QoXCJuZXh0XCIpLCBtZXRob2QoXCJ0aHJvd1wiKSwgbWV0aG9kKFwicmV0dXJuXCIpLCBpdDtcbn07XG52YXIgX19mb3JBd2FpdCA9IChvYmosIGl0LCBtZXRob2QpID0+IChpdCA9IG9ialtfX2tub3duU3ltYm9sKFwiYXN5bmNJdGVyYXRvclwiKV0pID8gaXQuY2FsbChvYmopIDogKG9iaiA9IG9ialtfX2tub3duU3ltYm9sKFwiaXRlcmF0b3JcIildKCksIGl0ID0ge30sIG1ldGhvZCA9IChrZXksIGZuKSA9PiAoZm4gPSBvYmpba2V5XSkgJiYgKGl0W2tleV0gPSAoYXJnKSA9PiBuZXcgUHJvbWlzZSgoeWVzLCBubywgZG9uZSkgPT4gKGFyZyA9IGZuLmNhbGwob2JqLCBhcmcpLCBkb25lID0gYXJnLmRvbmUsIFByb21pc2UucmVzb2x2ZShhcmcudmFsdWUpLnRoZW4oKHZhbHVlKSA9PiB5ZXMoeyB2YWx1ZSwgZG9uZSB9KSwgbm8pKSkpLCBtZXRob2QoXCJuZXh0XCIpLCBtZXRob2QoXCJyZXR1cm5cIiksIGl0KTtcblxuLy8gc3JjL2FwaS9pbmRleC50c1xuaW1wb3J0IGNyZWF0ZUNsaWVudCBmcm9tIFwib3BlbmFwaS1mZXRjaFwiO1xuXG4vLyBzcmMvYXBpL21ldGFkYXRhLnRzXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSBcInBsYXRmb3JtXCI7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjEuMTMuMlwiO1xuXG4vLyBzcmMvYXBpL21ldGFkYXRhLnRzXG5mdW5jdGlvbiBnZXRSdW50aW1lKCkge1xuICB2YXIgX2EyLCBfYiwgX2M7XG4gIGlmIChnbG9iYWxUaGlzLkJ1bikge1xuICAgIHJldHVybiB7IHJ1bnRpbWU6IFwiYnVuXCIsIHZlcnNpb246IGdsb2JhbFRoaXMuQnVuLnZlcnNpb24gfTtcbiAgfVxuICBpZiAoZ2xvYmFsVGhpcy5EZW5vKSB7XG4gICAgcmV0dXJuIHsgcnVudGltZTogXCJkZW5vXCIsIHZlcnNpb246IGdsb2JhbFRoaXMuRGVuby52ZXJzaW9uLmRlbm8gfTtcbiAgfVxuICBpZiAoKChfYiA9IChfYTIgPSBnbG9iYWxUaGlzLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVsZWFzZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSBcIm5vZGVcIikge1xuICAgIHJldHVybiB7IHJ1bnRpbWU6IFwibm9kZVwiLCB2ZXJzaW9uOiBwbGF0Zm9ybS52ZXJzaW9uIHx8IFwidW5rbm93blwiIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7IHJ1bnRpbWU6IFwidmVyY2VsLWVkZ2VcIiwgdmVyc2lvbjogXCJ1bmtub3duXCIgfTtcbiAgfVxuICBpZiAoKChfYyA9IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MudXNlckFnZW50KSA9PT0gXCJDbG91ZGZsYXJlLVdvcmtlcnNcIikge1xuICAgIHJldHVybiB7IHJ1bnRpbWU6IFwiY2xvdWRmbGFyZS13b3JrZXJcIiwgdmVyc2lvbjogXCJ1bmtub3duXCIgfTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7IHJ1bnRpbWU6IFwiYnJvd3NlclwiLCB2ZXJzaW9uOiBwbGF0Zm9ybS52ZXJzaW9uIHx8IFwidW5rbm93blwiIH07XG4gIH1cbiAgcmV0dXJuIHsgcnVudGltZTogXCJ1bmtub3duXCIsIHZlcnNpb246IFwidW5rbm93blwiIH07XG59XG52YXIgeyBydW50aW1lLCB2ZXJzaW9uOiBydW50aW1lVmVyc2lvbiB9ID0gZ2V0UnVudGltZSgpO1xudmFyIF9hO1xudmFyIGRlZmF1bHRIZWFkZXJzID0ge1xuICBicm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHBsYXRmb3JtLm5hbWUgfHwgXCJ1bmtub3duXCIsXG4gIGxhbmc6IFwianNcIixcbiAgbGFuZ192ZXJzaW9uOiBydW50aW1lVmVyc2lvbixcbiAgcGFja2FnZV92ZXJzaW9uOiB2ZXJzaW9uLFxuICBwdWJsaXNoZXI6IFwiZTJiXCIsXG4gIHNka19ydW50aW1lOiBydW50aW1lLFxuICBzeXN0ZW06ICgoX2EgPSBwbGF0Zm9ybS5vcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZhbWlseSkgfHwgXCJ1bmtub3duXCJcbn07XG5mdW5jdGlvbiBnZXRFbnZWYXIobmFtZSkge1xuICBpZiAocnVudGltZSA9PT0gXCJkZW5vXCIpIHtcbiAgICByZXR1cm4gRGVuby5lbnYuZ2V0KG5hbWUpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHJldHVybiBwcm9jZXNzLmVudltuYW1lXTtcbn1cblxuLy8gc3JjL2Vycm9ycy50c1xuZnVuY3Rpb24gZm9ybWF0U2FuZGJveFRpbWVvdXRFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgVGltZW91dEVycm9yKFxuICAgIGAke21lc3NhZ2V9OiBUaGlzIGVycm9yIGlzIGxpa2VseSBkdWUgdG8gc2FuZGJveCB0aW1lb3V0LiBZb3UgY2FuIG1vZGlmeSB0aGUgc2FuZGJveCB0aW1lb3V0IGJ5IHBhc3NpbmcgJ3RpbWVvdXRNcycgd2hlbiBzdGFydGluZyB0aGUgc2FuZGJveCBvciBjYWxsaW5nICcuc2V0VGltZW91dCcgb24gdGhlIHNhbmRib3ggd2l0aCB0aGUgZGVzaXJlZCB0aW1lb3V0LmBcbiAgKTtcbn1cbnZhciBTYW5kYm94RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2FuZGJveEVycm9yXCI7XG4gIH1cbn07XG52YXIgVGltZW91dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJUaW1lb3V0RXJyb3JcIjtcbiAgfVxufTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2FuZGJveEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbiAgfVxufTtcbnZhciBOb3RFbm91Z2hTcGFjZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJOb3RFbm91Z2hTcGFjZUVycm9yXCI7XG4gIH1cbn07XG52YXIgTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgU2FuZGJveEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiTm90Rm91bmRFcnJvclwiO1xuICB9XG59O1xudmFyIEF1dGhlbnRpY2F0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNhbmRib3hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkF1dGhlbnRpY2F0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnZhciBUZW1wbGF0ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTYW5kYm94RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJUZW1wbGF0ZUVycm9yXCI7XG4gIH1cbn07XG52YXIgUmF0ZUxpbWl0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFNhbmRib3hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJhdGVMaW1pdEVycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2dzLnRzXG5mdW5jdGlvbiBmb3JtYXRMb2cobG9nKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxvZykpO1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjTG9nZ2VyKGxvZ2dlcikge1xuICBmdW5jdGlvbiBsb2dFYWNoKHN0cmVhbSkge1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaXRlciA9IF9fZm9yQXdhaXQoc3RyZWFtKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSB5aWVsZCBuZXcgX19hd2FpdChpdGVyLm5leHQoKSkpLmRvbmU7IG1vcmUgPSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IG0gPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgIChfYTIgPSBsb2dnZXIuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChsb2dnZXIsIFwiUmVzcG9uc2Ugc3RyZWFtOlwiLCBmb3JtYXRMb2cobSkpO1xuICAgICAgICAgIHlpZWxkIG07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHRlbXApIHtcbiAgICAgICAgZXJyb3IgPSBbdGVtcF07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1vcmUgJiYgKHRlbXAgPSBpdGVyLnJldHVybikgJiYgKHlpZWxkIG5ldyBfX2F3YWl0KHRlbXAuY2FsbChpdGVyKSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHRocm93IGVycm9yWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChuZXh0KSA9PiBhc3luYyAocmVxKSA9PiB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgKF9hMiA9IGxvZ2dlci5pbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwobG9nZ2VyLCBgUmVxdWVzdDogUE9TVCAke3JlcS51cmx9YCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgbmV4dChyZXEpO1xuICAgIGlmIChyZXMuc3RyZWFtKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVzKSwge1xuICAgICAgICBtZXNzYWdlOiBsb2dFYWNoKHJlcy5tZXNzYWdlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChfYiA9IGxvZ2dlci5pbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChsb2dnZXIsIFwiUmVzcG9uc2U6XCIsIGZvcm1hdExvZyhyZXMubWVzc2FnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXBpTG9nZ2VyKGxvZ2dlcikge1xuICByZXR1cm4ge1xuICAgIGFzeW5jIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICAoX2EyID0gbG9nZ2VyLmluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChsb2dnZXIsIGBSZXF1ZXN0ICR7cmVxLm1ldGhvZH0gJHtyZXEudXJsfWApO1xuICAgICAgcmV0dXJuIHJlcTtcbiAgICB9LFxuICAgIGFzeW5jIG9uUmVzcG9uc2UocmVzKSB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIGlmIChyZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAoX2EyID0gbG9nZ2VyLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwobG9nZ2VyLCBcIlJlc3BvbnNlOlwiLCByZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoX2IgPSBsb2dnZXIuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwobG9nZ2VyLCBcIlJlc3BvbnNlOlwiLCByZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FwaS9pbmRleC50c1xuZnVuY3Rpb24gaGFuZGxlQXBpRXJyb3IocmVzcG9uc2UpIHtcbiAgdmFyIF9hMiwgX2I7XG4gIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihcIlJhdGUgbGltaXQgZXhjZWVkZWQsIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSAoX2IgPSAoX2EyID0gcmVzcG9uc2UuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubWVzc2FnZSkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2UuZXJyb3I7XG4gIHJldHVybiBuZXcgU2FuZGJveEVycm9yKGAke3Jlc3BvbnNlLnJlc3BvbnNlLnN0YXR1c306ICR7bWVzc2FnZX1gKTtcbn1cbnZhciBBcGlDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgb3B0cyA9IHsgcmVxdWlyZUFjY2Vzc1Rva2VuOiBmYWxzZSwgcmVxdWlyZUFwaUtleTogdHJ1ZSB9KSB7XG4gICAgaWYgKCEob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1aXJlQXBpS2V5KSAmJiAhY29uZmlnLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQVBJIGtleSBpcyByZXF1aXJlZCwgcGxlYXNlIHZpc2l0IHRoZSBUZWFtIHRhYiBhdCBodHRwczovL2UyYi5kZXYvZGFzaGJvYXJkIHRvIGdldCB5b3VyIEFQSSBrZXkuIFlvdSBjYW4gZWl0aGVyIHNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgYEUyQl9BUElfS0VZYCBvciB5b3UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgdG8gdGhlIHNhbmRib3ggbGlrZSBTYW5kYm94LmNyZWF0ZSh7IGFwaUtleTogJ2UyYl8uLi4nIH0pXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1aXJlQWNjZXNzVG9rZW4pICYmICFjb25maWcuYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICBcIkFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCwgcGxlYXNlIHZpc2l0IHRoZSBQZXJzb25hbCB0YWIgYXQgaHR0cHM6Ly9lMmIuZGV2L2Rhc2hib2FyZCB0byBnZXQgeW91ciBhY2Nlc3MgdG9rZW4uIFlvdSBjYW4gc2V0IHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBgRTJCX0FDQ0VTU19UT0tFTmAgb3IgcGFzcyB0aGUgYGFjY2Vzc1Rva2VuYCBpbiBvcHRpb25zLlwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFwaSA9IGNyZWF0ZUNsaWVudCh7XG4gICAgICBiYXNlVXJsOiBjb25maWcuYXBpVXJsLFxuICAgICAgLy8ga2VlcGFsaXZlOiB0cnVlLCAvLyBUT0RPOiBSZXR1cm4ga2VlcGFsaXZlXG4gICAgICBoZWFkZXJzOiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEhlYWRlcnMpLCBjb25maWcuYXBpS2V5ICYmIHsgXCJYLUFQSS1LRVlcIjogY29uZmlnLmFwaUtleSB9KSwgY29uZmlnLmFjY2Vzc1Rva2VuICYmIHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NvbmZpZy5hY2Nlc3NUb2tlbn1gXG4gICAgICB9KSwgY29uZmlnLmhlYWRlcnMpXG4gICAgfSk7XG4gICAgaWYgKGNvbmZpZy5sb2dnZXIpIHtcbiAgICAgIHRoaXMuYXBpLnVzZShjcmVhdGVBcGlMb2dnZXIoY29uZmlnLmxvZ2dlcikpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Nvbm5lY3Rpb25Db25maWcudHNcbnZhciBSRVFVRVNUX1RJTUVPVVRfTVMgPSA2ZTQ7XG52YXIgS0VFUEFMSVZFX1BJTkdfSU5URVJWQUxfU0VDID0gNTA7XG52YXIgS0VFUEFMSVZFX1BJTkdfSEVBREVSID0gXCJLZWVwYWxpdmUtUGluZy1JbnRlcnZhbFwiO1xudmFyIENvbm5lY3Rpb25Db25maWcgPSBjbGFzcyBfQ29ubmVjdGlvbkNvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB2YXIgX2EyO1xuICAgIHRoaXMuYXBpS2V5ID0gKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYXBpS2V5KSB8fCBfQ29ubmVjdGlvbkNvbmZpZy5hcGlLZXk7XG4gICAgdGhpcy5kZWJ1ZyA9IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmRlYnVnKSB8fCBfQ29ubmVjdGlvbkNvbmZpZy5kZWJ1ZztcbiAgICB0aGlzLmRvbWFpbiA9IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmRvbWFpbikgfHwgX0Nvbm5lY3Rpb25Db25maWcuZG9tYWluO1xuICAgIHRoaXMuYWNjZXNzVG9rZW4gPSAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5hY2Nlc3NUb2tlbikgfHwgX0Nvbm5lY3Rpb25Db25maWcuYWNjZXNzVG9rZW47XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dE1zID0gKF9hMiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcykgIT0gbnVsbCA/IF9hMiA6IFJFUVVFU1RfVElNRU9VVF9NUztcbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMubG9nZ2VyO1xuICAgIHRoaXMuaGVhZGVycyA9IChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmhlYWRlcnMpIHx8IHt9O1xuICAgIHRoaXMuaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSBgZTJiLWpzLXNkay8ke3ZlcnNpb259YDtcbiAgICB0aGlzLmFwaVVybCA9IHRoaXMuZGVidWcgPyBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiIDogYGh0dHBzOi8vYXBpLiR7dGhpcy5kb21haW59YDtcbiAgfVxuICBzdGF0aWMgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gZ2V0RW52VmFyKFwiRTJCX0RPTUFJTlwiKSB8fCBcImUyYi5hcHBcIjtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlYnVnKCkge1xuICAgIHJldHVybiAoZ2V0RW52VmFyKFwiRTJCX0RFQlVHXCIpIHx8IFwiZmFsc2VcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XG4gIH1cbiAgc3RhdGljIGdldCBhcGlLZXkoKSB7XG4gICAgcmV0dXJuIGdldEVudlZhcihcIkUyQl9BUElfS0VZXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgcmV0dXJuIGdldEVudlZhcihcIkUyQl9BQ0NFU1NfVE9LRU5cIik7XG4gIH1cbiAgZ2V0U2lnbmFsKHJlcXVlc3RUaW1lb3V0TXMpIHtcbiAgICBjb25zdCB0aW1lb3V0ID0gcmVxdWVzdFRpbWVvdXRNcyAhPSBudWxsID8gcmVxdWVzdFRpbWVvdXRNcyA6IHRoaXMucmVxdWVzdFRpbWVvdXRNcztcbiAgICByZXR1cm4gdGltZW91dCA/IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dCkgOiB2b2lkIDA7XG4gIH1cbn07XG52YXIgZGVmYXVsdFVzZXJuYW1lID0gXCJ1c2VyXCI7XG5cbi8vIHNyYy91dGlscy50c1xuYXN5bmMgZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZGF0YUJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKGRhdGEpO1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgZGF0YUJ1ZmZlcik7XG4gICAgY29uc3QgaGFzaEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcik7XG4gICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5oYXNoQXJyYXkpKTtcbiAgfVxuICBjb25zdCB7IGNyZWF0ZUhhc2ggfSA9IF9fcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoZGF0YSwgXCJ1dGY4XCIpLmRpZ2VzdCgpO1xuICByZXR1cm4gaGFzaC50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cblxuLy8gc3JjL3NhbmRib3gvc2lnbmF0dXJlLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRTaWduYXR1cmUoe1xuICBwYXRoLFxuICBvcGVyYXRpb24sXG4gIHVzZXIsXG4gIGV4cGlyYXRpb25JblNlY29uZHMsXG4gIGVudmRBY2Nlc3NUb2tlblxufSkge1xuICBpZiAoIWVudmRBY2Nlc3NUb2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQWNjZXNzIHRva2VuIGlzIG5vdCBzZXQgYW5kIHNpZ25hdHVyZSBjYW5ub3QgYmUgZ2VuZXJhdGVkIVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBzaWduYXR1cmVFeHBpcmF0aW9uID0gZXhwaXJhdGlvbkluU2Vjb25kcyA/IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgKyBleHBpcmF0aW9uSW5TZWNvbmRzIDogbnVsbDtcbiAgbGV0IHNpZ25hdHVyZVJhdztcbiAgaWYgKHNpZ25hdHVyZUV4cGlyYXRpb24gPT09IG51bGwpIHtcbiAgICBzaWduYXR1cmVSYXcgPSBgJHtwYXRofToke29wZXJhdGlvbn06JHt1c2VyfToke2VudmRBY2Nlc3NUb2tlbn1gO1xuICB9IGVsc2Uge1xuICAgIHNpZ25hdHVyZVJhdyA9IGAke3BhdGh9OiR7b3BlcmF0aW9ufToke3VzZXJ9OiR7ZW52ZEFjY2Vzc1Rva2VufToke3NpZ25hdHVyZUV4cGlyYXRpb24udG9TdHJpbmcoKX1gO1xuICB9XG4gIGNvbnN0IGhhc2hCYXNlNjQgPSBhd2FpdCBzaGEyNTYoc2lnbmF0dXJlUmF3KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCJ2MV9cIiArIGhhc2hCYXNlNjQucmVwbGFjZSgvPSskLywgXCJcIik7XG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlLFxuICAgIGV4cGlyYXRpb246IHNpZ25hdHVyZUV4cGlyYXRpb25cbiAgfTtcbn1cblxuLy8gc3JjL3NhbmRib3gvZmlsZXN5c3RlbS9pbmRleC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlQ2xpZW50IGFzIGNyZWF0ZUNsaWVudDMsXG4gIENvbm5lY3RFcnJvciBhcyBDb25uZWN0RXJyb3IzLFxuICBDb2RlIGFzIENvZGUzXG59IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0XCI7XG5cbi8vIHNyYy9lbnZkL2FwaS50c1xuaW1wb3J0IGNyZWF0ZUNsaWVudDIgZnJvbSBcIm9wZW5hcGktZmV0Y2hcIjtcbmltcG9ydCB7IENvZGUsIENvbm5lY3RFcnJvciB9IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0XCI7XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVFbnZkQXBpRXJyb3IocmVzKSB7XG4gIHZhciBfYTI7XG4gIGlmICghcmVzLmVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgcmVzLmVycm9yID09IFwic3RyaW5nXCIgPyByZXMuZXJyb3IgOiAoKF9hMiA9IHJlcy5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tZXNzYWdlKSB8fCBhd2FpdCByZXMucmVzcG9uc2UudGV4dCgpO1xuICBzd2l0Y2ggKHJlcy5yZXNwb25zZS5zdGF0dXMpIHtcbiAgICBjYXNlIDQwMDpcbiAgICAgIHJldHVybiBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSA0MDE6XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSA0MDQ6XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IobWVzc2FnZSk7XG4gICAgY2FzZSA0Mjk6XG4gICAgICByZXR1cm4gbmV3IFNhbmRib3hFcnJvcihcbiAgICAgICAgYCR7cmVzLnJlc3BvbnNlLnN0YXR1c306ICR7bWVzc2FnZX06IFRoZSByZXF1ZXN0cyBhcmUgYmVpbmcgcmF0ZSBsaW1pdGVkLmBcbiAgICAgICk7XG4gICAgY2FzZSA1MDI6XG4gICAgICByZXR1cm4gZm9ybWF0U2FuZGJveFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcbiAgICBjYXNlIDUwNzpcbiAgICAgIHJldHVybiBuZXcgTm90RW5vdWdoU3BhY2VFcnJvcihtZXNzYWdlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBTYW5kYm94RXJyb3IoYCR7cmVzLnJlc3BvbnNlLnN0YXR1c306ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKSB7XG4gIHZhciBfYTI7XG4gIGxldCBzdGFydEV2ZW50O1xuICB0cnkge1xuICAgIHN0YXJ0RXZlbnQgPSAoYXdhaXQgZXZlbnRzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLm5leHQoKSkudmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0RXJyb3IpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gQ29kZS5VbmF2YWlsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihcIlNhbmRib3ggaXMgcHJvYmFibHkgbm90IHJ1bm5pbmcgYW55bW9yZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGlmICgoKF9hMiA9IHN0YXJ0RXZlbnQuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZXZlbnQuY2FzZSkgIT09IFwic3RhcnRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0YXJ0IGV2ZW50XCIpO1xuICB9XG4gIHJldHVybiBzdGFydEV2ZW50LmV2ZW50LmV2ZW50LnZhbHVlLnBpZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdhdGNoRGlyU3RhcnRFdmVudChldmVudHMpIHtcbiAgdmFyIF9hMjtcbiAgbGV0IHN0YXJ0RXZlbnQ7XG4gIHRyeSB7XG4gICAgc3RhcnRFdmVudCA9IChhd2FpdCBldmVudHNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkubmV4dCgpKS52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbm5lY3RFcnJvcikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSBDb2RlLlVuYXZhaWxhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKFwiU2FuZGJveCBpcyBwcm9iYWJseSBub3QgcnVubmluZyBhbnltb3JlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgaWYgKCgoX2EyID0gc3RhcnRFdmVudC5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYXNlKSAhPT0gXCJzdGFydFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RhcnQgZXZlbnRcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXJ0RXZlbnQuZXZlbnQudmFsdWU7XG59XG52YXIgRW52ZEFwaUNsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZXRhZGF0YSkge1xuICAgIHRoaXMuYXBpID0gY3JlYXRlQ2xpZW50Mih7XG4gICAgICBiYXNlVXJsOiBjb25maWcuYXBpVXJsLFxuICAgICAgZmV0Y2g6IGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmZldGNoLFxuICAgICAgaGVhZGVyczogY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuaGVhZGVyc1xuICAgICAgLy8ga2VlcGFsaXZlOiB0cnVlLCAvLyBUT0RPOiBSZXR1cm4ga2VlcGFsaXZlXG4gICAgfSk7XG4gICAgdGhpcy52ZXJzaW9uID0gbWV0YWRhdGEudmVyc2lvbjtcbiAgICBpZiAoY29uZmlnLmxvZ2dlcikge1xuICAgICAgdGhpcy5hcGkudXNlKGNyZWF0ZUFwaUxvZ2dlcihjb25maWcubG9nZ2VyKSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZW52ZC9ycGMudHNcbmltcG9ydCB7IENvZGUgYXMgQ29kZTIsIENvbm5lY3RFcnJvciBhcyBDb25uZWN0RXJyb3IyIH0gZnJvbSBcIkBjb25uZWN0cnBjL2Nvbm5lY3RcIjtcbmZ1bmN0aW9uIGhhbmRsZVJwY0Vycm9yKGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yMikge1xuICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgIGNhc2UgQ29kZTIuSW52YWxpZEFyZ3VtZW50OlxuICAgICAgICByZXR1cm4gbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGNhc2UgQ29kZTIuVW5hdXRoZW50aWNhdGVkOlxuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgY2FzZSBDb2RlMi5Ob3RGb3VuZDpcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RGb3VuZEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGNhc2UgQ29kZTIuVW5hdmFpbGFibGU6XG4gICAgICAgIHJldHVybiBmb3JtYXRTYW5kYm94VGltZW91dEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGNhc2UgQ29kZTIuQ2FuY2VsZWQ6XG4gICAgICAgIHJldHVybiBuZXcgVGltZW91dEVycm9yKFxuICAgICAgICAgIGAke2Vyci5tZXNzYWdlfTogVGhpcyBlcnJvciBpcyBsaWtlbHkgZHVlIHRvIGV4Y2VlZGluZyAncmVxdWVzdFRpbWVvdXRNcycuIFlvdSBjYW4gcGFzcyB0aGUgcmVxdWVzdCB0aW1lb3V0IHZhbHVlIGFzIGFuIG9wdGlvbiB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdC5gXG4gICAgICAgICk7XG4gICAgICBjYXNlIENvZGUyLkRlYWRsaW5lRXhjZWVkZWQ6XG4gICAgICAgIHJldHVybiBuZXcgVGltZW91dEVycm9yKFxuICAgICAgICAgIGAke2Vyci5tZXNzYWdlfTogVGhpcyBlcnJvciBpcyBsaWtlbHkgZHVlIHRvIGV4Y2VlZGluZyAndGltZW91dE1zJyBcXHUyMDE0IHRoZSB0b3RhbCB0aW1lIGEgbG9uZyBydW5uaW5nIHJlcXVlc3QgKGxpa2UgY29tbWFuZCBleGVjdXRpb24gb3IgZGlyZWN0b3J5IHdhdGNoKSBjYW4gYmUgYWN0aXZlLiBJdCBjYW4gYmUgbW9kaWZpZWQgYnkgcGFzc2luZyAndGltZW91dE1zJyB3aGVuIG1ha2luZyB0aGUgcmVxdWVzdC4gVXNlICcwJyB0byBkaXNhYmxlIHRoZSB0aW1lb3V0LmBcbiAgICAgICAgKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgU2FuZGJveEVycm9yKGAke2Vyci5jb2RlfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGVuY29kZTY0KHZhbHVlKSB7XG4gIHN3aXRjaCAocnVudGltZSkge1xuICAgIGNhc2UgXCJkZW5vXCI6XG4gICAgICByZXR1cm4gYnRvYSh2YWx1ZSk7XG4gICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgY2FzZSBcImJ1blwiOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGJ0b2EodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdGlvbkhlYWRlcih1c2VybmFtZSkge1xuICBjb25zdCB2YWx1ZSA9IGAke3VzZXJuYW1lIHx8IGRlZmF1bHRVc2VybmFtZX06YDtcbiAgY29uc3QgZW5jb2RlZCA9IGVuY29kZTY0KHZhbHVlKTtcbiAgcmV0dXJuIHsgXCJBdXRob3JpemF0aW9uXCI6IGBCYXNpYyAke2VuY29kZWR9YCB9O1xufVxuXG4vLyBzcmMvZW52ZC9maWxlc3lzdGVtL2ZpbGVzeXN0ZW1fcGIudHNcbmltcG9ydCB7IGVudW1EZXNjLCBmaWxlRGVzYywgbWVzc2FnZURlc2MsIHNlcnZpY2VEZXNjIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1Zi9jb2RlZ2VudjJcIjtcbmltcG9ydCB7IGZpbGVfZ29vZ2xlX3Byb3RvYnVmX3RpbWVzdGFtcCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWYvd2t0XCI7XG52YXIgZmlsZV9maWxlc3lzdGVtX2ZpbGVzeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gZmlsZURlc2MoXCJDaHRtYVd4bGMzbHpkR1Z0TDJacGJHVnplWE4wWlcwdWNISnZkRzhTQ21acGJHVnplWE4wWlcwaU1nb0xUVzkyWlZKbGNYVmxjM1FTRGdvR2MyOTFjbU5sR0FFZ0FTZ0pFaE1LQzJSbGMzUnBibUYwYVc5dUdBSWdBU2dKSWpRS0RFMXZkbVZTWlhOd2IyNXpaUklrQ2dWbGJuUnllUmdCSUFFb0N6SVZMbVpwYkdWemVYTjBaVzB1Ulc1MGNubEpibVp2SWg0S0RrMWhhMlZFYVhKU1pYRjFaWE4wRWd3S0JIQmhkR2dZQVNBQktBa2lOd29QVFdGclpVUnBjbEpsYzNCdmJuTmxFaVFLQldWdWRISjVHQUVnQVNnTE1oVXVabWxzWlhONWMzUmxiUzVGYm5SeWVVbHVabThpSFFvTlVtVnRiM1psVW1WeGRXVnpkQklNQ2dSd1lYUm9HQUVnQVNnSkloQUtEbEpsYlc5MlpWSmxjM0J2Ym5ObEloc0tDMU4wWVhSU1pYRjFaWE4wRWd3S0JIQmhkR2dZQVNBQktBa2lOQW9NVTNSaGRGSmxjM0J2Ym5ObEVpUUtCV1Z1ZEhKNUdBRWdBU2dMTWhVdVptbHNaWE41YzNSbGJTNUZiblJ5ZVVsdVptOGkvUUVLQ1VWdWRISjVTVzVtYnhJTUNnUnVZVzFsR0FFZ0FTZ0pFaUlLQkhSNWNHVVlBaUFCS0E0eUZDNW1hV3hsYzNsemRHVnRMa1pwYkdWVWVYQmxFZ3dLQkhCaGRHZ1lBeUFCS0FrU0RBb0VjMmw2WlJnRUlBRW9BeElNQ2dSdGIyUmxHQVVnQVNnTkVoTUtDM0JsY20xcGMzTnBiMjV6R0FZZ0FTZ0pFZzBLQlc5M2JtVnlHQWNnQVNnSkVnMEtCV2R5YjNWd0dBZ2dBU2dKRWpFS0RXMXZaR2xtYVdWa1gzUnBiV1VZQ1NBQktBc3lHaTVuYjI5bmJHVXVjSEp2ZEc5aWRXWXVWR2x0WlhOMFlXMXdFaHNLRG5ONWJXeHBibXRmZEdGeVoyVjBHQW9nQVNnSlNBQ0lBUUZDRVFvUFgzTjViV3hwYm10ZmRHRnlaMlYwSWkwS0RreHBjM1JFYVhKU1pYRjFaWE4wRWd3S0JIQmhkR2dZQVNBQktBa1NEUW9GWkdWd2RHZ1lBaUFCS0EwaU9Rb1BUR2x6ZEVScGNsSmxjM0J2Ym5ObEVpWUtCMlZ1ZEhKcFpYTVlBU0FES0FzeUZTNW1hV3hsYzNsemRHVnRMa1Z1ZEhKNVNXNW1ieUl5Q2c5WFlYUmphRVJwY2xKbGNYVmxjM1FTREFvRWNHRjBhQmdCSUFFb0NSSVJDZ2x5WldOMWNuTnBkbVVZQWlBQktBZ2lSQW9QUm1sc1pYTjVjM1JsYlVWMlpXNTBFZ3dLQkc1aGJXVVlBU0FCS0FrU0l3b0VkSGx3WlJnQ0lBRW9EaklWTG1acGJHVnplWE4wWlcwdVJYWmxiblJVZVhCbEl1QUJDaEJYWVhSamFFUnBjbEpsYzNCdmJuTmxFamdLQlhOMFlYSjBHQUVnQVNnTE1pY3VabWxzWlhONWMzUmxiUzVYWVhSamFFUnBjbEpsYzNCdmJuTmxMbE4wWVhKMFJYWmxiblJJQUJJeENncG1hV3hsYzNsemRHVnRHQUlnQVNnTE1oc3VabWxzWlhONWMzUmxiUzVHYVd4bGMzbHpkR1Z0UlhabGJuUklBQkk3Q2dsclpXVndZV3hwZG1VWUF5QUJLQXN5Smk1bWFXeGxjM2x6ZEdWdExsZGhkR05vUkdseVVtVnpjRzl1YzJVdVMyVmxjRUZzYVhabFNBQWFEQW9LVTNSaGNuUkZkbVZ1ZEJvTENnbExaV1Z3UVd4cGRtVkNCd29GWlhabGJuUWlOd29VUTNKbFlYUmxWMkYwWTJobGNsSmxjWFZsYzNRU0RBb0VjR0YwYUJnQklBRW9DUklSQ2dseVpXTjFjbk5wZG1VWUFpQUJLQWdpS3dvVlEzSmxZWFJsVjJGMFkyaGxjbEpsYzNCdmJuTmxFaElLQ25kaGRHTm9aWEpmYVdRWUFTQUJLQWtpTFFvWFIyVjBWMkYwWTJobGNrVjJaVzUwYzFKbGNYVmxjM1FTRWdvS2QyRjBZMmhsY2w5cFpCZ0JJQUVvQ1NKSENoaEhaWFJYWVhSamFHVnlSWFpsYm5SelVtVnpjRzl1YzJVU0t3b0daWFpsYm5SekdBRWdBeWdMTWhzdVptbHNaWE41YzNSbGJTNUdhV3hsYzNsemRHVnRSWFpsYm5RaUtnb1VVbVZ0YjNabFYyRjBZMmhsY2xKbGNYVmxjM1FTRWdvS2QyRjBZMmhsY2w5cFpCZ0JJQUVvQ1NJWENoVlNaVzF2ZG1WWFlYUmphR1Z5VW1WemNHOXVjMlVxVWdvSVJtbHNaVlI1Y0dVU0dRb1ZSa2xNUlY5VVdWQkZYMVZPVTFCRlEwbEdTVVZFRUFBU0Vnb09Sa2xNUlY5VVdWQkZYMFpKVEVVUUFSSVhDaE5HU1V4RlgxUlpVRVZmUkVsU1JVTlVUMUpaRUFJcW1BRUtDVVYyWlc1MFZIbHdaUklhQ2haRlZrVk9WRjlVV1ZCRlgxVk9VMUJGUTBsR1NVVkVFQUFTRlFvUlJWWkZUbFJmVkZsUVJWOURVa1ZCVkVVUUFSSVVDaEJGVmtWT1ZGOVVXVkJGWDFkU1NWUkZFQUlTRlFvUlJWWkZUbFJmVkZsUVJWOVNSVTFQVmtVUUF4SVZDaEZGVmtWT1ZGOVVXVkJGWDFKRlRrRk5SUkFFRWhRS0VFVldSVTVVWDFSWlVFVmZRMGhOVDBRUUJUS2ZCUW9LUm1sc1pYTjVjM1JsYlJJNUNnUlRkR0YwRWhjdVptbHNaWE41YzNSbGJTNVRkR0YwVW1WeGRXVnpkQm9ZTG1acGJHVnplWE4wWlcwdVUzUmhkRkpsYzNCdmJuTmxFa0lLQjAxaGEyVkVhWElTR2k1bWFXeGxjM2x6ZEdWdExrMWhhMlZFYVhKU1pYRjFaWE4wR2hzdVptbHNaWE41YzNSbGJTNU5ZV3RsUkdseVVtVnpjRzl1YzJVU09Rb0VUVzkyWlJJWExtWnBiR1Z6ZVhOMFpXMHVUVzkyWlZKbGNYVmxjM1FhR0M1bWFXeGxjM2x6ZEdWdExrMXZkbVZTWlhOd2IyNXpaUkpDQ2dkTWFYTjBSR2x5RWhvdVptbHNaWE41YzNSbGJTNU1hWE4wUkdseVVtVnhkV1Z6ZEJvYkxtWnBiR1Z6ZVhOMFpXMHVUR2x6ZEVScGNsSmxjM0J2Ym5ObEVqOEtCbEpsYlc5MlpSSVpMbVpwYkdWemVYTjBaVzB1VW1WdGIzWmxVbVZ4ZFdWemRCb2FMbVpwYkdWemVYTjBaVzB1VW1WdGIzWmxVbVZ6Y0c5dWMyVVNSd29JVjJGMFkyaEVhWElTR3k1bWFXeGxjM2x6ZEdWdExsZGhkR05vUkdseVVtVnhkV1Z6ZEJvY0xtWnBiR1Z6ZVhOMFpXMHVWMkYwWTJoRWFYSlNaWE53YjI1elpUQUJFbFFLRFVOeVpXRjBaVmRoZEdOb1pYSVNJQzVtYVd4bGMzbHpkR1Z0TGtOeVpXRjBaVmRoZEdOb1pYSlNaWEYxWlhOMEdpRXVabWxzWlhONWMzUmxiUzVEY21WaGRHVlhZWFJqYUdWeVVtVnpjRzl1YzJVU1hRb1FSMlYwVjJGMFkyaGxja1YyWlc1MGN4SWpMbVpwYkdWemVYTjBaVzB1UjJWMFYyRjBZMmhsY2tWMlpXNTBjMUpsY1hWbGMzUWFKQzVtYVd4bGMzbHpkR1Z0TGtkbGRGZGhkR05vWlhKRmRtVnVkSE5TWlhOd2IyNXpaUkpVQ2cxU1pXMXZkbVZYWVhSamFHVnlFaUF1Wm1sc1pYTjVjM1JsYlM1U1pXMXZkbVZYWVhSamFHVnlVbVZ4ZFdWemRCb2hMbVpwYkdWemVYTjBaVzB1VW1WdGIzWmxWMkYwWTJobGNsSmxjM0J2Ym5ObFFta0tEbU52YlM1bWFXeGxjM2x6ZEdWdFFnOUdhV3hsYzNsemRHVnRVSEp2ZEc5UUFhSUNBMFpZV0tvQ0NrWnBiR1Z6ZVhOMFpXM0tBZ3BHYVd4bGMzbHpkR1Z0NGdJV1JtbHNaWE41YzNSbGJWeEhVRUpOWlhSaFpHRjBZZW9DQ2tacGJHVnplWE4wWlcxaUJuQnliM1J2TXdcIiwgW2ZpbGVfZ29vZ2xlX3Byb3RvYnVmX3RpbWVzdGFtcF0pO1xudmFyIEZpbGVzeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc2VydmljZURlc2MoZmlsZV9maWxlc3lzdGVtX2ZpbGVzeXN0ZW0sIDApO1xuXG4vLyBzcmMvc2FuZGJveC9maWxlc3lzdGVtL3dhdGNoSGFuZGxlLnRzXG52YXIgRmlsZXN5c3RlbUV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZpbGVzeXN0ZW1FdmVudFR5cGUyKSA9PiB7XG4gIEZpbGVzeXN0ZW1FdmVudFR5cGUyW1wiQ0hNT0RcIl0gPSBcImNobW9kXCI7XG4gIEZpbGVzeXN0ZW1FdmVudFR5cGUyW1wiQ1JFQVRFXCJdID0gXCJjcmVhdGVcIjtcbiAgRmlsZXN5c3RlbUV2ZW50VHlwZTJbXCJSRU1PVkVcIl0gPSBcInJlbW92ZVwiO1xuICBGaWxlc3lzdGVtRXZlbnRUeXBlMltcIlJFTkFNRVwiXSA9IFwicmVuYW1lXCI7XG4gIEZpbGVzeXN0ZW1FdmVudFR5cGUyW1wiV1JJVEVcIl0gPSBcIndyaXRlXCI7XG4gIHJldHVybiBGaWxlc3lzdGVtRXZlbnRUeXBlMjtcbn0pKEZpbGVzeXN0ZW1FdmVudFR5cGUgfHwge30pO1xuZnVuY3Rpb24gbWFwRXZlbnRUeXBlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSA1IC8qIENITU9EICovOlxuICAgICAgcmV0dXJuIFwiY2htb2RcIiAvKiBDSE1PRCAqLztcbiAgICBjYXNlIDEgLyogQ1JFQVRFICovOlxuICAgICAgcmV0dXJuIFwiY3JlYXRlXCIgLyogQ1JFQVRFICovO1xuICAgIGNhc2UgMyAvKiBSRU1PVkUgKi86XG4gICAgICByZXR1cm4gXCJyZW1vdmVcIiAvKiBSRU1PVkUgKi87XG4gICAgY2FzZSA0IC8qIFJFTkFNRSAqLzpcbiAgICAgIHJldHVybiBcInJlbmFtZVwiIC8qIFJFTkFNRSAqLztcbiAgICBjYXNlIDIgLyogV1JJVEUgKi86XG4gICAgICByZXR1cm4gXCJ3cml0ZVwiIC8qIFdSSVRFICovO1xuICB9XG59XG52YXIgV2F0Y2hIYW5kbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhhbmRsZVN0b3AsIGV2ZW50cywgb25FdmVudCwgb25FeGl0KSB7XG4gICAgdGhpcy5oYW5kbGVTdG9wID0gaGFuZGxlU3RvcDtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLm9uRXZlbnQgPSBvbkV2ZW50O1xuICAgIHRoaXMub25FeGl0ID0gb25FeGl0O1xuICAgIHRoaXMuaGFuZGxlRXZlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3Agd2F0Y2hpbmcgdGhlIGRpcmVjdG9yeS5cbiAgICovXG4gIGFzeW5jIHN0b3AoKSB7XG4gICAgdGhpcy5oYW5kbGVTdG9wKCk7XG4gIH1cbiAgaXRlcmF0ZUV2ZW50cygpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBpdGVyID0gX19mb3JBd2FpdCh0aGlzLmV2ZW50cyksIG1vcmUsIHRlbXAsIGVycm9yOyBtb3JlID0gISh0ZW1wID0geWllbGQgbmV3IF9fYXdhaXQoaXRlci5uZXh0KCkpKS5kb25lOyBtb3JlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuZXZlbnQuY2FzZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZmlsZXN5c3RlbVwiOlxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAodGVtcCkge1xuICAgICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmICh5aWVsZCBuZXcgX19hd2FpdCh0ZW1wLmNhbGwoaXRlcikpKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGhhbmRsZUV2ZW50cygpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgdHJ5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGl0ZXIgPSBfX2ZvckF3YWl0KHRoaXMuaXRlcmF0ZUV2ZW50cygpKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSBhd2FpdCBpdGVyLm5leHQoKSkuZG9uZTsgbW9yZSA9IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IG1hcEV2ZW50VHlwZShldmVudC52YWx1ZS50eXBlKTtcbiAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoX2EyID0gdGhpcy5vbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgbmFtZTogZXZlbnQudmFsdWUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh0ZW1wKSB7XG4gICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmIGF3YWl0IHRlbXAuY2FsbChpdGVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKF9iID0gdGhpcy5vbkV4aXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgKF9jID0gdGhpcy5vbkV4aXQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC9maWxlc3lzdGVtL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wYXJlVmVyc2lvbnMgfSBmcm9tIFwiY29tcGFyZS12ZXJzaW9uc1wiO1xuXG4vLyBzcmMvZW52ZC92ZXJzaW9ucy50c1xudmFyIEVOVkRfVkVSU0lPTl9SRUNVUlNJVkVfV0FUQ0ggPSBcIjAuMS40XCI7XG5cbi8vIHNyYy9zYW5kYm94L2ZpbGVzeXN0ZW0vaW5kZXgudHNcbnZhciBGaWxlVHlwZTIgPSAvKiBAX19QVVJFX18gKi8gKChGaWxlVHlwZTMpID0+IHtcbiAgRmlsZVR5cGUzW1wiRklMRVwiXSA9IFwiZmlsZVwiO1xuICBGaWxlVHlwZTNbXCJESVJcIl0gPSBcImRpclwiO1xuICByZXR1cm4gRmlsZVR5cGUzO1xufSkoRmlsZVR5cGUyIHx8IHt9KTtcbmZ1bmN0aW9uIG1hcEZpbGVUeXBlKGZpbGVUeXBlKSB7XG4gIHN3aXRjaCAoZmlsZVR5cGUpIHtcbiAgICBjYXNlIDIgLyogRElSRUNUT1JZICovOlxuICAgICAgcmV0dXJuIFwiZGlyXCIgLyogRElSICovO1xuICAgIGNhc2UgMSAvKiBGSUxFICovOlxuICAgICAgcmV0dXJuIFwiZmlsZVwiIC8qIEZJTEUgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcE1vZGlmaWVkVGltZShtb2RpZmllZFRpbWUpIHtcbiAgaWYgKCFtb2RpZmllZFRpbWUpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBuZXcgRGF0ZShcbiAgICBOdW1iZXIobW9kaWZpZWRUaW1lLnNlY29uZHMpICogMWUzICsgTWF0aC5mbG9vcihtb2RpZmllZFRpbWUubmFub3MgLyAxZTYpXG4gICk7XG59XG52YXIgRmlsZXN5c3RlbTIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgZW52ZEFwaSwgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIHRoaXMuZW52ZEFwaSA9IGVudmRBcGk7XG4gICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICB0aGlzLmRlZmF1bHRXYXRjaFRpbWVvdXQgPSA2ZTQ7XG4gICAgLy8gNjAgc2Vjb25kc1xuICAgIHRoaXMuZGVmYXVsdFdhdGNoUmVjdXJzaXZlID0gZmFsc2U7XG4gICAgdGhpcy5ycGMgPSBjcmVhdGVDbGllbnQzKEZpbGVzeXN0ZW0sIHRyYW5zcG9ydCk7XG4gIH1cbiAgYXN5bmMgcmVhZChwYXRoLCBvcHRzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBmb3JtYXQgPSAoX2EyID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mb3JtYXQpICE9IG51bGwgPyBfYTIgOiBcInRleHRcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmVudmRBcGkuYXBpLkdFVChcIi9maWxlc1wiLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHVzZXJuYW1lOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51c2VyKSB8fCBkZWZhdWx0VXNlcm5hbWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcnNlQXM6IGZvcm1hdCA9PT0gXCJieXRlc1wiID8gXCJhcnJheUJ1ZmZlclwiIDogZm9ybWF0LFxuICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICB9KTtcbiAgICBjb25zdCBlcnIgPSBhd2FpdCBoYW5kbGVFbnZkQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IFwiYnl0ZXNcIikge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcy5kYXRhKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtbGVuZ3RoXCIpID09PSBcIjBcIikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiByZXMuZGF0YTtcbiAgfVxuICBhc3luYyB3cml0ZShwYXRoT3JGaWxlcywgZGF0YU9yT3B0cywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgcGF0aE9yRmlsZXMgIT09IFwic3RyaW5nXCIgJiYgIUFycmF5LmlzQXJyYXkocGF0aE9yRmlsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIG9yIGZpbGVzIGFyZSByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXRoT3JGaWxlcyA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KGRhdGFPck9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYm90aCBwYXRoIGFuZCBhcnJheSBvZiBmaWxlcy4gWW91IGhhdmUgdG8gc3BlY2lmeSBlaXRoZXIgcGF0aCBhbmQgZGF0YSBmb3IgYSBzaW5nbGUgZmlsZSBvciBhbiBhcnJheSBmb3IgbXVsdGlwbGUgZmlsZXMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aCwgd3JpdGVPcHRzLCB3cml0ZUZpbGVzIH0gPSB0eXBlb2YgcGF0aE9yRmlsZXMgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICBwYXRoOiBwYXRoT3JGaWxlcyxcbiAgICAgIHdyaXRlT3B0czogb3B0cyxcbiAgICAgIHdyaXRlRmlsZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRhdGE6IGRhdGFPck9wdHNcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0gOiB7XG4gICAgICBwYXRoOiB2b2lkIDAsXG4gICAgICB3cml0ZU9wdHM6IGRhdGFPck9wdHMsXG4gICAgICB3cml0ZUZpbGVzOiBwYXRoT3JGaWxlc1xuICAgIH07XG4gICAgaWYgKHdyaXRlRmlsZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgY29uc3QgYmxvYnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHdyaXRlRmlsZXMubWFwKChmKSA9PiBuZXcgUmVzcG9uc2UoZi5kYXRhKS5ibG9iKCkpXG4gICAgKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmVudmRBcGkuYXBpLlBPU1QoXCIvZmlsZXNcIiwge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB1c2VybmFtZTogKHdyaXRlT3B0cyA9PSBudWxsID8gdm9pZCAwIDogd3JpdGVPcHRzLnVzZXIpIHx8IGRlZmF1bHRVc2VybmFtZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYm9keVNlcmlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBibG9icy5yZWR1Y2UoKGZkLCBibG9iLCBpKSA9PiB7XG4gICAgICAgICAgZmQuYXBwZW5kKFwiZmlsZVwiLCBibG9iLCB3cml0ZUZpbGVzW2ldLnBhdGgpO1xuICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgfSwgbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgfSxcbiAgICAgIGJvZHk6IHt9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcbiAgICAgICAgXCJCdW4tQ29udGVudC1UeXBlXCI6IFwidGVtcG9yYXJ5LWZpeFwiXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vdmVuLXNoL2J1bi9pc3N1ZXMvMTQ5ODhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBlcnIgPSBhd2FpdCBoYW5kbGVFbnZkQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVzID0gcmVzLmRhdGE7XG4gICAgaWYgKCFmaWxlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdG8gcmVjZWl2ZSBpbmZvcm1hdGlvbiBhYm91dCB3cml0dGVuIGZpbGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcy5sZW5ndGggPT09IDEgJiYgcGF0aCA/IGZpbGVzWzBdIDogZmlsZXM7XG4gIH1cbiAgLyoqXG4gICAqIExpc3QgZW50cmllcyBpbiBhIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggcGF0aCB0byB0aGUgZGlyZWN0b3J5LlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGxpc3Qgb2YgZW50cmllcyBpbiB0aGUgc2FuZGJveCBmaWxlc3lzdGVtIGRpcmVjdG9yeS5cbiAgICovXG4gIGFzeW5jIGxpc3QocGF0aCwgb3B0cykge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKHR5cGVvZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5kZXB0aCkgPT09IFwibnVtYmVyXCIgJiYgb3B0cy5kZXB0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImRlcHRoIHNob3VsZCBiZSBhdCBsZWFzdCBvbmVcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJwYy5saXN0RGlyKFxuICAgICAgICB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBkZXB0aDogKF9hMiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGVwdGgpICE9IG51bGwgPyBfYTIgOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpLFxuICAgICAgICAgIHNpZ25hbDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGUgb2YgcmVzLmVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG1hcEZpbGVUeXBlKGUudHlwZSk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoOiBlLnBhdGgsXG4gICAgICAgICAgICBzaXplOiBOdW1iZXIoZS5zaXplKSxcbiAgICAgICAgICAgIG1vZGU6IGUubW9kZSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiBlLnBlcm1pc3Npb25zLFxuICAgICAgICAgICAgb3duZXI6IGUub3duZXIsXG4gICAgICAgICAgICBncm91cDogZS5ncm91cCxcbiAgICAgICAgICAgIG1vZGlmaWVkVGltZTogbWFwTW9kaWZpZWRUaW1lKGUubW9kaWZpZWRUaW1lKSxcbiAgICAgICAgICAgIHN5bWxpbmtUYXJnZXQ6IGUuc3ltbGlua1RhcmdldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cmllcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGlyZWN0b3J5IGFuZCBhbGwgZGlyZWN0b3JpZXMgYWxvbmcgdGhlIHdheSBpZiBuZWVkZWQgb24gdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBwYXRoIHRvIGEgbmV3IGRpcmVjdG9yeS4gRm9yIGV4YW1wbGUgJy9kaXJBL2RpckInIHdoZW4gY3JlYXRpbmcgJ2RpckInLlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGlyZWN0b3J5IHdhcyBjcmVhdGVkLCBgZmFsc2VgIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgYXN5bmMgbWFrZURpcihwYXRoLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucnBjLm1ha2VEaXIoXG4gICAgICAgIHsgcGF0aCB9LFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogYXV0aGVudGljYXRpb25IZWFkZXIob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51c2VyKSxcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yMykge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGUzLkFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5hbWUgYSBmaWxlIG9yIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIG9sZFBhdGggcGF0aCB0byB0aGUgZmlsZSBvciBkaXJlY3RvcnkgdG8gcmVuYW1lLlxuICAgKiBAcGFyYW0gbmV3UGF0aCBuZXcgcGF0aCBmb3IgdGhlIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHJlbmFtZWQgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqL1xuICBhc3luYyByZW5hbWUob2xkUGF0aCwgbmV3UGF0aCwgb3B0cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJwYy5tb3ZlKFxuICAgICAgICB7XG4gICAgICAgICAgc291cmNlOiBvbGRQYXRoLFxuICAgICAgICAgIGRlc3RpbmF0aW9uOiBuZXdQYXRoXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpLFxuICAgICAgICAgIHNpZ25hbDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBlbnRyeSA9IHJlcy5lbnRyeTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdG8gcmVjZWl2ZSBpbmZvcm1hdGlvbiBhYm91dCBtb3ZlZCBvYmplY3RcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBlbnRyeS5uYW1lLFxuICAgICAgICB0eXBlOiBtYXBGaWxlVHlwZShlbnRyeS50eXBlKSxcbiAgICAgICAgcGF0aDogZW50cnkucGF0aCxcbiAgICAgICAgc2l6ZTogTnVtYmVyKGVudHJ5LnNpemUpLFxuICAgICAgICBtb2RlOiBlbnRyeS5tb2RlLFxuICAgICAgICBwZXJtaXNzaW9uczogZW50cnkucGVybWlzc2lvbnMsXG4gICAgICAgIG93bmVyOiBlbnRyeS5vd25lcixcbiAgICAgICAgZ3JvdXA6IGVudHJ5Lmdyb3VwLFxuICAgICAgICBtb2RpZmllZFRpbWU6IG1hcE1vZGlmaWVkVGltZShlbnRyeS5tb2RpZmllZFRpbWUpLFxuICAgICAgICBzeW1saW5rVGFyZ2V0OiBlbnRyeS5zeW1saW5rVGFyZ2V0XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBwYXRoIHRvIGEgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHJlbW92ZShwYXRoLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucnBjLnJlbW92ZShcbiAgICAgICAgeyBwYXRoIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpLFxuICAgICAgICAgIHNpZ25hbDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBmaWxlIG9yIGEgZGlyZWN0b3J5IGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggcGF0aCB0byBhIGZpbGUgb3IgYSBkaXJlY3RvcnlcbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpbGUgb3IgZGlyZWN0b3J5IGV4aXN0cywgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGFzeW5jIGV4aXN0cyhwYXRoLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucnBjLnN0YXQoXG4gICAgICAgIHsgcGF0aCB9LFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogYXV0aGVudGljYXRpb25IZWFkZXIob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy51c2VyKSxcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yMykge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGUzLk5vdEZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGEgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIHBhdGggdG8gYSBmaWxlIG9yIGRpcmVjdG9yeS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmlsZSBvciBkaXJlY3RvcnkgbGlrZSBuYW1lLCB0eXBlLCBhbmQgcGF0aC5cbiAgICovXG4gIGFzeW5jIGdldEluZm8ocGF0aCwgb3B0cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJwYy5zdGF0KFxuICAgICAgICB7IHBhdGggfSxcbiAgICAgICAgeyBoZWFkZXJzOiBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpIH1cbiAgICAgICk7XG4gICAgICBpZiAoIXJlcy5lbnRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byByZWNlaXZlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmaWxlIG9yIGRpcmVjdG9yeVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiByZXMuZW50cnkubmFtZSxcbiAgICAgICAgdHlwZTogbWFwRmlsZVR5cGUocmVzLmVudHJ5LnR5cGUpLFxuICAgICAgICBwYXRoOiByZXMuZW50cnkucGF0aCxcbiAgICAgICAgc2l6ZTogTnVtYmVyKHJlcy5lbnRyeS5zaXplKSxcbiAgICAgICAgbW9kZTogcmVzLmVudHJ5Lm1vZGUsXG4gICAgICAgIHBlcm1pc3Npb25zOiByZXMuZW50cnkucGVybWlzc2lvbnMsXG4gICAgICAgIG93bmVyOiByZXMuZW50cnkub3duZXIsXG4gICAgICAgIGdyb3VwOiByZXMuZW50cnkuZ3JvdXAsXG4gICAgICAgIG1vZGlmaWVkVGltZTogbWFwTW9kaWZpZWRUaW1lKHJlcy5lbnRyeS5tb2RpZmllZFRpbWUpLFxuICAgICAgICBzeW1saW5rVGFyZ2V0OiByZXMuZW50cnkuc3ltbGlua1RhcmdldFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdGFydCB3YXRjaGluZyBhIGRpcmVjdG9yeSBmb3IgZmlsZXN5c3RlbSBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIHBhdGggdG8gZGlyZWN0b3J5IHRvIHdhdGNoLlxuICAgKiBAcGFyYW0gb25FdmVudCBjYWxsYmFjayB0byBjYWxsIHdoZW4gYW4gZXZlbnQgaW4gdGhlIGRpcmVjdG9yeSBvY2N1cnMuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgYFdhdGNoSGFuZGxlYCBvYmplY3QgZm9yIHN0b3BwaW5nIHdhdGNoaW5nIGRpcmVjdG9yeS5cbiAgICovXG4gIGFzeW5jIHdhdGNoRGlyKHBhdGgsIG9uRXZlbnQsIG9wdHMpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgaWYgKChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlY3Vyc2l2ZSkgJiYgdGhpcy5lbnZkQXBpLnZlcnNpb24gJiYgY29tcGFyZVZlcnNpb25zKHRoaXMuZW52ZEFwaS52ZXJzaW9uLCBFTlZEX1ZFUlNJT05fUkVDVVJTSVZFX1dBVENIKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUVycm9yKFxuICAgICAgICBcIllvdSBuZWVkIHRvIHVwZGF0ZSB0aGUgdGVtcGxhdGUgdG8gdXNlIHJlY3Vyc2l2ZSB3YXRjaGluZy4gWW91IGNhbiBkbyB0aGlzIGJ5IHJ1bm5pbmcgYGUyYiB0ZW1wbGF0ZSBidWlsZGAgaW4gdGhlIGRpcmVjdG9yeSB3aXRoIHRoZSB0ZW1wbGF0ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdFRpbWVvdXRNcyA9IChfYTIgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpICE9IG51bGwgPyBfYTIgOiB0aGlzLmNvbm5lY3Rpb25Db25maWcucmVxdWVzdFRpbWVvdXRNcztcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlcVRpbWVvdXQgPSByZXF1ZXN0VGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgcmVxdWVzdFRpbWVvdXRNcykgOiB2b2lkIDA7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5ycGMud2F0Y2hEaXIoXG4gICAgICB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHJlY3Vyc2l2ZTogKF9iID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWN1cnNpdmUpICE9IG51bGwgPyBfYiA6IHRoaXMuZGVmYXVsdFdhdGNoUmVjdXJzaXZlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpKSwge1xuICAgICAgICAgIFtLRUVQQUxJVkVfUElOR19IRUFERVJdOiBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMudG9TdHJpbmcoKVxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgdGltZW91dE1zOiAoX2MgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnRpbWVvdXRNcykgIT0gbnVsbCA/IF9jIDogdGhpcy5kZWZhdWx0V2F0Y2hUaW1lb3V0XG4gICAgICB9XG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaGFuZGxlV2F0Y2hEaXJTdGFydEV2ZW50KGV2ZW50cyk7XG4gICAgICBjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG4gICAgICByZXR1cm4gbmV3IFdhdGNoSGFuZGxlKFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb25FdmVudCxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vbkV4aXRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3NhbmRib3gvY29tbWFuZHMvY29tbWFuZEhhbmRsZS50c1xudmFyIENvbW1hbmRFeGl0RXJyb3IgPSBjbGFzcyBleHRlbmRzIFNhbmRib3hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlc3VsdCkge1xuICAgIHN1cGVyKHJlc3VsdC5lcnJvcik7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgdGhpcy5uYW1lID0gXCJDb21tYW5kRXhpdEVycm9yXCI7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1hbmQgZXhlY3V0aW9uIGV4aXQgY29kZS5cbiAgICogYDBgIGlmIHRoZSBjb21tYW5kIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseS5cbiAgICovXG4gIGdldCBleGl0Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuZXhpdENvZGU7XG4gIH1cbiAgLyoqXG4gICAqIEVycm9yIG1lc3NhZ2UgZnJvbSBjb21tYW5kIGV4ZWN1dGlvbi5cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQuZXJyb3I7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1hbmQgZXhlY3V0aW9uIHN0ZG91dCBvdXRwdXQuXG4gICAqL1xuICBnZXQgc3Rkb3V0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5zdGRvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1hbmQgZXhlY3V0aW9uIHN0ZGVyciBvdXRwdXQuXG4gICAqL1xuICBnZXQgc3RkZXJyKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5zdGRlcnI7XG4gIH1cbn07XG52YXIgQ29tbWFuZEhhbmRsZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICogQGludGVybmFsXG4gICAqIEBhY2Nlc3MgcHJvdGVjdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwaWQsIGhhbmRsZURpc2Nvbm5lY3QsIGhhbmRsZUtpbGwsIGV2ZW50cywgb25TdGRvdXQsIG9uU3RkZXJyLCBvblB0eSkge1xuICAgIHRoaXMucGlkID0gcGlkO1xuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCA9IGhhbmRsZURpc2Nvbm5lY3Q7XG4gICAgdGhpcy5oYW5kbGVLaWxsID0gaGFuZGxlS2lsbDtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLm9uU3Rkb3V0ID0gb25TdGRvdXQ7XG4gICAgdGhpcy5vblN0ZGVyciA9IG9uU3RkZXJyO1xuICAgIHRoaXMub25QdHkgPSBvblB0eTtcbiAgICB0aGlzLl9zdGRvdXQgPSBcIlwiO1xuICAgIHRoaXMuX3N0ZGVyciA9IFwiXCI7XG4gICAgdGhpcy5fd2FpdCA9IHRoaXMuaGFuZGxlRXZlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1hbmQgZXhlY3V0aW9uIGV4aXQgY29kZS5cbiAgICogYDBgIGlmIHRoZSBjb21tYW5kIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseS5cbiAgICogXG4gICAqIEl0IGlzIGB1bmRlZmluZWRgIGlmIHRoZSBjb21tYW5kIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAqL1xuICBnZXQgZXhpdENvZGUoKSB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IHRoaXMucmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmV4aXRDb2RlO1xuICB9XG4gIC8qKlxuICAgKiBFcnJvciBtZXNzYWdlIGZyb20gY29tbWFuZCBleGVjdXRpb24uXG4gICAqL1xuICBnZXQgZXJyb3IoKSB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gKF9hMiA9IHRoaXMucmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmVycm9yO1xuICB9XG4gIC8qKlxuICAgKiBDb21tYW5kIGV4ZWN1dGlvbiBzdGRlcnIgb3V0cHV0LlxuICAgKi9cbiAgZ2V0IHN0ZGVycigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RkZXJyO1xuICB9XG4gIC8qKlxuICAgKiBDb21tYW5kIGV4ZWN1dGlvbiBzdGRvdXQgb3V0cHV0LlxuICAgKi9cbiAgZ2V0IHN0ZG91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Rkb3V0O1xuICB9XG4gIC8qKlxuICAgKiBXYWl0IGZvciB0aGUgY29tbWFuZCB0byBmaW5pc2ggYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgKiBJZiB0aGUgY29tbWFuZCBleGl0cyB3aXRoIGEgbm9uLXplcm8gZXhpdCBjb2RlLCBpdCB0aHJvd3MgYSBgQ29tbWFuZEV4aXRFcnJvcmAuXG4gICAqIFxuICAgKiBAcmV0dXJucyBgQ29tbWFuZFJlc3VsdGAgcmVzdWx0IG9mIGNvbW1hbmQgZXhlY3V0aW9uLlxuICAgKi9cbiAgYXN5bmMgd2FpdCgpIHtcbiAgICBhd2FpdCB0aGlzLl93YWl0O1xuICAgIGlmICh0aGlzLml0ZXJhdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLml0ZXJhdGlvbkVycm9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgU2FuZGJveEVycm9yKFwiUHJvY2VzcyBleGl0ZWQgd2l0aG91dCBhIHJlc3VsdFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzdWx0LmV4aXRDb2RlICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQ29tbWFuZEV4aXRFcnJvcih0aGlzLnJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBjb21tYW5kLlxuICAgKiBcbiAgICogVGhlIGNvbW1hbmQgaXMgbm90IGtpbGxlZCwgYnV0IFNESyBzdG9wcyByZWNlaXZpbmcgZXZlbnRzIGZyb20gdGhlIGNvbW1hbmQuXG4gICAqIFlvdSBjYW4gcmVjb25uZWN0IHRvIHRoZSBjb21tYW5kIHVzaW5nIHtAbGluayBDb21tYW5kcy5jb25uZWN0fS5cbiAgICovXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgdGhlIGNvbW1hbmQuXG4gICAqIEl0IHVzZXMgYFNJR0tJTExgIHNpZ25hbCB0byBraWxsIHRoZSBjb21tYW5kLlxuICAgKiBcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb21tYW5kIHdhcyBraWxsZWQgc3VjY2Vzc2Z1bGx5LCBgZmFsc2VgIGlmIHRoZSBjb21tYW5kIHdhcyBub3QgZm91bmQuXG4gICAqL1xuICBhc3luYyBraWxsKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZUtpbGwoKTtcbiAgfVxuICBpdGVyYXRlRXZlbnRzKCkge1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaXRlciA9IF9fZm9yQXdhaXQodGhpcy5ldmVudHMpLCBtb3JlLCB0ZW1wLCBlcnJvcjsgbW9yZSA9ICEodGVtcCA9IHlpZWxkIG5ldyBfX2F3YWl0KGl0ZXIubmV4dCgpKSkuZG9uZTsgbW9yZSA9IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgIGNvbnN0IGUgPSAoX2EyID0gZXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50LmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmV2ZW50O1xuICAgICAgICAgIGxldCBvdXQ7XG4gICAgICAgICAgc3dpdGNoIChlID09IG51bGwgPyB2b2lkIDAgOiBlLmNhc2UpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgIHN3aXRjaCAoZS52YWx1ZS5vdXRwdXQuY2FzZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdGRvdXRcIjpcbiAgICAgICAgICAgICAgICAgIG91dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShlLnZhbHVlLm91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zdGRvdXQgKz0gb3V0O1xuICAgICAgICAgICAgICAgICAgeWllbGQgW291dCwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RkZXJyXCI6XG4gICAgICAgICAgICAgICAgICBvdXQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZS52YWx1ZS5vdXRwdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc3RkZXJyICs9IG91dDtcbiAgICAgICAgICAgICAgICAgIHlpZWxkIFtudWxsLCBvdXQsIG51bGxdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInB0eVwiOlxuICAgICAgICAgICAgICAgICAgeWllbGQgW251bGwsIG51bGwsIGUudmFsdWUub3V0cHV0LnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBleGl0Q29kZTogZS52YWx1ZS5leGl0Q29kZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZS52YWx1ZS5lcnJvcixcbiAgICAgICAgICAgICAgICBzdGRvdXQ6IHRoaXMuc3Rkb3V0LFxuICAgICAgICAgICAgICAgIHN0ZGVycjogdGhpcy5zdGRlcnJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh0ZW1wKSB7XG4gICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmICh5aWVsZCBuZXcgX19hd2FpdCh0ZW1wLmNhbGwoaXRlcikpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGhhbmRsZUV2ZW50cygpIHtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgdHJ5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGl0ZXIgPSBfX2ZvckF3YWl0KHRoaXMuaXRlcmF0ZUV2ZW50cygpKSwgbW9yZSwgdGVtcCwgZXJyb3I7IG1vcmUgPSAhKHRlbXAgPSBhd2FpdCBpdGVyLm5leHQoKSkuZG9uZTsgbW9yZSA9IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgW3N0ZG91dCwgc3RkZXJyLCBwdHldID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICBpZiAoc3Rkb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAoX2EyID0gdGhpcy5vblN0ZG91dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKHRoaXMsIHN0ZG91dCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGRlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25TdGRlcnIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIHN0ZGVycik7XG4gICAgICAgICAgfSBlbHNlIGlmIChwdHkpIHtcbiAgICAgICAgICAgIChfYyA9IHRoaXMub25QdHkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIHB0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh0ZW1wKSB7XG4gICAgICAgIGVycm9yID0gW3RlbXBdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtb3JlICYmICh0ZW1wID0gaXRlci5yZXR1cm4pICYmIGF3YWl0IHRlbXAuY2FsbChpdGVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvclswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuaXRlcmF0aW9uRXJyb3IgPSBoYW5kbGVScGNFcnJvcihlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9zYW5kYm94L2luZGV4LnRzXG5pbXBvcnQgeyBjcmVhdGVDb25uZWN0VHJhbnNwb3J0IH0gZnJvbSBcIkBjb25uZWN0cnBjL2Nvbm5lY3Qtd2ViXCI7XG5cbi8vIHNyYy9zYW5kYm94L2NvbW1hbmRzL2luZGV4LnRzXG5pbXBvcnQge1xuICBDb2RlIGFzIENvZGU1LFxuICBDb25uZWN0RXJyb3IgYXMgQ29ubmVjdEVycm9yNSxcbiAgY3JlYXRlQ2xpZW50IGFzIGNyZWF0ZUNsaWVudDVcbn0gZnJvbSBcIkBjb25uZWN0cnBjL2Nvbm5lY3RcIjtcblxuLy8gc3JjL2VudmQvcHJvY2Vzcy9wcm9jZXNzX3BiLnRzXG5pbXBvcnQgeyBlbnVtRGVzYyBhcyBlbnVtRGVzYzIsIGZpbGVEZXNjIGFzIGZpbGVEZXNjMiwgbWVzc2FnZURlc2MgYXMgbWVzc2FnZURlc2MyLCBzZXJ2aWNlRGVzYyBhcyBzZXJ2aWNlRGVzYzIgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2NvZGVnZW52MlwiO1xudmFyIGZpbGVfcHJvY2Vzc19wcm9jZXNzID0gLyogQF9fUFVSRV9fICovIGZpbGVEZXNjMihcIkNoVndjbTlqWlhOekwzQnliMk5sYzNNdWNISnZkRzhTQjNCeWIyTmxjM01pU2dvRFVGUlpFaDhLQkhOcGVtVVlBU0FCS0FzeUVTNXdjbTlqWlhOekxsQlVXUzVUYVhwbEdpSUtCRk5wZW1VU0RBb0VZMjlzY3hnQklBRW9EUklNQ2dSeWIzZHpHQUlnQVNnTklxRUJDZzFRY205alpYTnpRMjl1Wm1sbkVnc0tBMk50WkJnQklBRW9DUklNQ2dSaGNtZHpHQUlnQXlnSkVpNEtCR1Z1ZG5NWUF5QURLQXN5SUM1d2NtOWpaWE56TGxCeWIyTmxjM05EYjI1bWFXY3VSVzUyYzBWdWRISjVFaEFLQTJOM1pCZ0VJQUVvQ1VnQWlBRUJHaXNLQ1VWdWRuTkZiblJ5ZVJJTENnTnJaWGtZQVNBQktBa1NEUW9GZG1Gc2RXVVlBaUFCS0FrNkFqZ0JRZ1lLQkY5amQyUWlEUW9MVEdsemRGSmxjWFZsYzNRaVhBb0xVSEp2WTJWemMwbHVabThTSmdvR1kyOXVabWxuR0FFZ0FTZ0xNaFl1Y0hKdlkyVnpjeTVRY205alpYTnpRMjl1Wm1sbkVnc0tBM0JwWkJnQ0lBRW9EUklRQ2dOMFlXY1lBeUFCS0FsSUFJZ0JBVUlHQ2dSZmRHRm5JamNLREV4cGMzUlNaWE53YjI1elpSSW5DZ2x3Y205alpYTnpaWE1ZQVNBREtBc3lGQzV3Y205alpYTnpMbEJ5YjJObGMzTkpibVp2SW5rS0RGTjBZWEowVW1WeGRXVnpkQkluQ2dkd2NtOWpaWE56R0FFZ0FTZ0xNaFl1Y0hKdlkyVnpjeTVRY205alpYTnpRMjl1Wm1sbkVoNEtBM0IwZVJnQ0lBRW9DeklNTG5CeWIyTmxjM011VUZSWlNBQ0lBUUVTRUFvRGRHRm5HQU1nQVNnSlNBR0lBUUZDQmdvRVgzQjBlVUlHQ2dSZmRHRm5JbUlLRFZWd1pHRjBaVkpsY1hWbGMzUVNLUW9IY0hKdlkyVnpjeGdCSUFFb0N6SVlMbkJ5YjJObGMzTXVVSEp2WTJWemMxTmxiR1ZqZEc5eUVoNEtBM0IwZVJnQ0lBRW9DeklNTG5CeWIyTmxjM011VUZSWlNBQ0lBUUZDQmdvRVgzQjBlU0lRQ2c1VmNHUmhkR1ZTWlhOd2IyNXpaU0t2QXdvTVVISnZZMlZ6YzBWMlpXNTBFakVLQlhOMFlYSjBHQUVnQVNnTE1pQXVjSEp2WTJWemN5NVFjbTlqWlhOelJYWmxiblF1VTNSaGNuUkZkbVZ1ZEVnQUVpOEtCR1JoZEdFWUFpQUJLQXN5SHk1d2NtOWpaWE56TGxCeWIyTmxjM05GZG1WdWRDNUVZWFJoUlhabGJuUklBQkl0Q2dObGJtUVlBeUFCS0FzeUhpNXdjbTlqWlhOekxsQnliMk5sYzNORmRtVnVkQzVGYm1SRmRtVnVkRWdBRWpRS0NXdGxaWEJoYkdsMlpSZ0VJQUVvQ3pJZkxuQnliMk5sYzNNdVVISnZZMlZ6YzBWMlpXNTBMa3RsWlhCQmJHbDJaVWdBR2hrS0NsTjBZWEowUlhabGJuUVNDd29EY0dsa0dBRWdBU2dOR2tnS0NVUmhkR0ZGZG1WdWRCSVFDZ1p6ZEdSdmRYUVlBU0FCS0F4SUFCSVFDZ1p6ZEdSbGNuSVlBaUFCS0F4SUFCSU5DZ053ZEhrWUF5QUJLQXhJQUVJSUNnWnZkWFJ3ZFhRYVd3b0lSVzVrUlhabGJuUVNFUW9KWlhocGRGOWpiMlJsR0FFZ0FTZ1JFZzRLQm1WNGFYUmxaQmdDSUFFb0NCSU9DZ1p6ZEdGMGRYTVlBeUFCS0FrU0Vnb0ZaWEp5YjNJWUJDQUJLQWxJQUlnQkFVSUlDZ1pmWlhKeWIzSWFDd29KUzJWbGNFRnNhWFpsUWdjS0JXVjJaVzUwSWpVS0RWTjBZWEowVW1WemNHOXVjMlVTSkFvRlpYWmxiblFZQVNBQktBc3lGUzV3Y205alpYTnpMbEJ5YjJObGMzTkZkbVZ1ZENJM0NnOURiMjV1WldOMFVtVnpjRzl1YzJVU0pBb0ZaWFpsYm5RWUFTQUJLQXN5RlM1d2NtOWpaWE56TGxCeWIyTmxjM05GZG1WdWRDSmpDaEJUWlc1a1NXNXdkWFJTWlhGMVpYTjBFaWtLQjNCeWIyTmxjM01ZQVNBQktBc3lHQzV3Y205alpYTnpMbEJ5YjJObGMzTlRaV3hsWTNSdmNoSWtDZ1ZwYm5CMWRCZ0NJQUVvQ3pJVkxuQnliMk5sYzNNdVVISnZZMlZ6YzBsdWNIVjBJaE1LRVZObGJtUkpibkIxZEZKbGMzQnZibk5sSWpjS0RGQnliMk5sYzNOSmJuQjFkQklQQ2dWemRHUnBiaGdCSUFFb0RFZ0FFZzBLQTNCMGVSZ0NJQUVvREVnQVFnY0tCV2x1Y0hWMElzSUNDaEpUZEhKbFlXMUpibkIxZEZKbGNYVmxjM1FTTndvRmMzUmhjblFZQVNBQktBc3lKaTV3Y205alpYTnpMbE4wY21WaGJVbHVjSFYwVW1WeGRXVnpkQzVUZEdGeWRFVjJaVzUwU0FBU05Rb0VaR0YwWVJnQ0lBRW9DeklsTG5CeWIyTmxjM011VTNSeVpXRnRTVzV3ZFhSU1pYRjFaWE4wTGtSaGRHRkZkbVZ1ZEVnQUVqb0tDV3RsWlhCaGJHbDJaUmdESUFFb0N6SWxMbkJ5YjJObGMzTXVVM1J5WldGdFNXNXdkWFJTWlhGMVpYTjBMa3RsWlhCQmJHbDJaVWdBR2pjS0NsTjBZWEowUlhabGJuUVNLUW9IY0hKdlkyVnpjeGdCSUFFb0N6SVlMbkJ5YjJObGMzTXVVSEp2WTJWemMxTmxiR1ZqZEc5eUdqRUtDVVJoZEdGRmRtVnVkQklrQ2dWcGJuQjFkQmdDSUFFb0N6SVZMbkJ5YjJObGMzTXVVSEp2WTJWemMwbHVjSFYwR2dzS0NVdGxaWEJCYkdsMlpVSUhDZ1ZsZG1WdWRDSVZDaE5UZEhKbFlXMUpibkIxZEZKbGMzQnZibk5sSWw4S0VWTmxibVJUYVdkdVlXeFNaWEYxWlhOMEVpa0tCM0J5YjJObGMzTVlBU0FCS0FzeUdDNXdjbTlqWlhOekxsQnliMk5sYzNOVFpXeGxZM1J2Y2hJZkNnWnphV2R1WVd3WUFpQUJLQTR5RHk1d2NtOWpaWE56TGxOcFoyNWhiQ0lVQ2hKVFpXNWtVMmxuYm1Gc1VtVnpjRzl1YzJVaU93b09RMjl1Ym1WamRGSmxjWFZsYzNRU0tRb0hjSEp2WTJWemN4Z0JJQUVvQ3pJWUxuQnliMk5sYzNNdVVISnZZMlZ6YzFObGJHVmpkRzl5SWpzS0QxQnliMk5sYzNOVFpXeGxZM1J2Y2hJTkNnTndhV1FZQVNBQktBMUlBQklOQ2dOMFlXY1lBaUFCS0FsSUFFSUtDZ2h6Wld4bFkzUnZjaXBJQ2daVGFXZHVZV3dTRmdvU1UwbEhUa0ZNWDFWT1UxQkZRMGxHU1VWRUVBQVNFZ29PVTBsSFRrRk1YMU5KUjFSRlVrMFFEeElTQ2c1VFNVZE9RVXhmVTBsSFMwbE1UQkFKTXNvRENnZFFjbTlqWlhOekVqTUtCRXhwYzNRU0ZDNXdjbTlqWlhOekxreHBjM1JTWlhGMVpYTjBHaFV1Y0hKdlkyVnpjeTVNYVhOMFVtVnpjRzl1YzJVU1Bnb0hRMjl1Ym1WamRCSVhMbkJ5YjJObGMzTXVRMjl1Ym1WamRGSmxjWFZsYzNRYUdDNXdjbTlqWlhOekxrTnZibTVsWTNSU1pYTndiMjV6WlRBQkVqZ0tCVk4wWVhKMEVoVXVjSEp2WTJWemN5NVRkR0Z5ZEZKbGNYVmxjM1FhRmk1d2NtOWpaWE56TGxOMFlYSjBVbVZ6Y0c5dWMyVXdBUkk1Q2daVmNHUmhkR1VTRmk1d2NtOWpaWE56TGxWd1pHRjBaVkpsY1hWbGMzUWFGeTV3Y205alpYTnpMbFZ3WkdGMFpWSmxjM0J2Ym5ObEVrb0tDMU4wY21WaGJVbHVjSFYwRWhzdWNISnZZMlZ6Y3k1VGRISmxZVzFKYm5CMWRGSmxjWFZsYzNRYUhDNXdjbTlqWlhOekxsTjBjbVZoYlVsdWNIVjBVbVZ6Y0c5dWMyVW9BUkpDQ2dsVFpXNWtTVzV3ZFhRU0dTNXdjbTlqWlhOekxsTmxibVJKYm5CMWRGSmxjWFZsYzNRYUdpNXdjbTlqWlhOekxsTmxibVJKYm5CMWRGSmxjM0J2Ym5ObEVrVUtDbE5sYm1SVGFXZHVZV3dTR2k1d2NtOWpaWE56TGxObGJtUlRhV2R1WVd4U1pYRjFaWE4wR2hzdWNISnZZMlZ6Y3k1VFpXNWtVMmxuYm1Gc1VtVnpjRzl1YzJWQ1Z3b0xZMjl0TG5CeWIyTmxjM05DREZCeWIyTmxjM05RY205MGIxQUJvZ0lEVUZoWXFnSUhVSEp2WTJWemM4b0NCMUJ5YjJObGMzUGlBaE5RY205alpYTnpYRWRRUWsxbGRHRmtZWFJoNmdJSFVISnZZMlZ6YzJJR2NISnZkRzh6XCIpO1xudmFyIFByb2Nlc3MgPSAvKiBAX19QVVJFX18gKi8gc2VydmljZURlc2MyKGZpbGVfcHJvY2Vzc19wcm9jZXNzLCAwKTtcblxuLy8gc3JjL3NhbmRib3gvY29tbWFuZHMvcHR5LnRzXG5pbXBvcnQge1xuICBDb2RlIGFzIENvZGU0LFxuICBDb25uZWN0RXJyb3IgYXMgQ29ubmVjdEVycm9yNCxcbiAgY3JlYXRlQ2xpZW50IGFzIGNyZWF0ZUNsaWVudDRcbn0gZnJvbSBcIkBjb25uZWN0cnBjL2Nvbm5lY3RcIjtcbnZhciBQdHkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgdGhpcy5ycGMgPSBjcmVhdGVDbGllbnQ0KFByb2Nlc3MsIHRoaXMudHJhbnNwb3J0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBUWSAocHNldWRvLXRlcm1pbmFsKS5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIFBUWS5cbiAgICogXG4gICAqIEByZXR1cm5zIGhhbmRsZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBQVFkuXG4gICAqL1xuICBhc3luYyBjcmVhdGUob3B0cykge1xuICAgIHZhciBfYTIsIF9iLCBfYztcbiAgICBjb25zdCByZXF1ZXN0VGltZW91dE1zID0gKF9hMiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcykgIT0gbnVsbCA/IF9hMiA6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5yZXF1ZXN0VGltZW91dE1zO1xuICAgIGNvbnN0IGVudnMgPSAoX2IgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmVudnMpICE9IG51bGwgPyBfYiA6IHt9O1xuICAgIGVudnMuVEVSTSA9IFwieHRlcm0tMjU2Y29sb3JcIjtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9LCByZXF1ZXN0VGltZW91dE1zKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLnJwYy5zdGFydChcbiAgICAgIHtcbiAgICAgICAgcHJvY2Vzczoge1xuICAgICAgICAgIGNtZDogXCIvYmluL2Jhc2hcIixcbiAgICAgICAgICBhcmdzOiBbXCItaVwiLCBcIi1sXCJdLFxuICAgICAgICAgIGVudnMsXG4gICAgICAgICAgY3dkOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmN3ZFxuICAgICAgICB9LFxuICAgICAgICBwdHk6IHtcbiAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICBjb2xzOiBvcHRzLmNvbHMsXG4gICAgICAgICAgICByb3dzOiBvcHRzLnJvd3NcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGF1dGhlbnRpY2F0aW9uSGVhZGVyKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudXNlcikpLCB7XG4gICAgICAgICAgW0tFRVBBTElWRV9QSU5HX0hFQURFUl06IEtFRVBBTElWRV9QSU5HX0lOVEVSVkFMX1NFQy50b1N0cmluZygpXG4gICAgICAgIH0pLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB0aW1lb3V0TXM6IChfYyA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2MgOiA2ZTRcbiAgICAgIH1cbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwaWQgPSBhd2FpdCBoYW5kbGVQcm9jZXNzU3RhcnRFdmVudChldmVudHMpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuICAgICAgcmV0dXJuIG5ldyBDb21tYW5kSGFuZGxlKFxuICAgICAgICBwaWQsXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICAgICAgKCkgPT4gdGhpcy5raWxsKHBpZCksXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG9wdHMub25EYXRhXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgaW5wdXQgdG8gYSBQVFkuXG4gICAqXG4gICAqIEBwYXJhbSBwaWQgcHJvY2VzcyBJRCBvZiB0aGUgUFRZLlxuICAgKiBAcGFyYW0gZGF0YSBpbnB1dCBkYXRhIHRvIHNlbmQgdG8gdGhlIFBUWS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgc2VuZElucHV0KHBpZCwgZGF0YSwgb3B0cykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJwYy5zZW5kSW5wdXQoXG4gICAgICAgIHtcbiAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgY2FzZTogXCJwdHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSBQVFkuXG4gICAqIENhbGwgdGhpcyB3aGVuIHRoZSB0ZXJtaW5hbCB3aW5kb3cgaXMgcmVzaXplZCBhbmQgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFuZCByb3dzIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0gcGlkIHByb2Nlc3MgSUQgb2YgdGhlIFBUWS5cbiAgICogQHBhcmFtIHNpemUgbmV3IHNpemUgb2YgdGhlIFBUWS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgcmVzaXplKHBpZCwgc2l6ZSwgb3B0cykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJwYy51cGRhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9jZXNzOiB7XG4gICAgICAgICAgICBzZWxlY3Rvcjoge1xuICAgICAgICAgICAgICBjYXNlOiBcInBpZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogcGlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwdHk6IHtcbiAgICAgICAgICAgIHNpemVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgYSBydW5uaW5nIFBUWSBzcGVjaWZpZWQgYnkgcHJvY2VzcyBJRC5cbiAgICogSXQgdXNlcyBgU0lHS0lMTGAgc2lnbmFsIHRvIGtpbGwgdGhlIFBUWS5cbiAgICpcbiAgICogQHBhcmFtIHBpZCBwcm9jZXNzIElEIG9mIHRoZSBQVFkuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICogXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgUFRZIHdhcyBraWxsZWQsIGBmYWxzZWAgaWYgdGhlIFBUWSB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMga2lsbChwaWQsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMuc2VuZFNpZ25hbChcbiAgICAgICAge1xuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogOSAvKiBTSUdLSUxMICovXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yNCkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGU0Lk5vdEZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3NhbmRib3gvY29tbWFuZHMvaW5kZXgudHNcbnZhciBDb21tYW5kcyA9IGNsYXNzIHtcbiAgLy8gNjAgc2Vjb25kc1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25Db25maWcgPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgIHRoaXMuZGVmYXVsdFByb2Nlc3NDb25uZWN0aW9uVGltZW91dCA9IDZlNDtcbiAgICB0aGlzLnJwYyA9IGNyZWF0ZUNsaWVudDUoUHJvY2VzcywgdHJhbnNwb3J0KTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBhbGwgcnVubmluZyBjb21tYW5kcyBhbmQgUFRZIHNlc3Npb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGxpc3Qgb2YgcnVubmluZyBjb21tYW5kcyBhbmQgUFRZIHNlc3Npb25zLlxuICAgKi9cbiAgYXN5bmMgbGlzdChvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucnBjLmxpc3QoXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgc2lnbmFsOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXMucHJvY2Vzc2VzLm1hcCgocCkgPT4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHBpZDogcC5waWRcbiAgICAgIH0sIHAudGFnICYmIHsgdGFnOiBwLnRhZyB9KSwge1xuICAgICAgICBhcmdzOiBwLmNvbmZpZy5hcmdzLFxuICAgICAgICBlbnZzOiBwLmNvbmZpZy5lbnZzLFxuICAgICAgICBjbWQ6IHAuY29uZmlnLmNtZFxuICAgICAgfSksIHAuY29uZmlnLmN3ZCAmJiB7IGN3ZDogcC5jb25maWcuY3dkIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgdG8gY29tbWFuZCBzdGRpbi5cbiAgICpcbiAgICogQHBhcmFtIHBpZCBwcm9jZXNzIElEIG9mIHRoZSBjb21tYW5kLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBydW5uaW5nIGNvbW1hbmRzIHVzaW5nIHtAbGluayBDb21tYW5kcy5saXN0fS5cbiAgICogQHBhcmFtIGRhdGEgZGF0YSB0byBzZW5kIHRvIHRoZSBjb21tYW5kLlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBzZW5kU3RkaW4ocGlkLCBkYXRhLCBvcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucnBjLnNlbmRJbnB1dChcbiAgICAgICAge1xuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICBjYXNlOiBcInN0ZGluXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgYSBydW5uaW5nIGNvbW1hbmQgc3BlY2lmaWVkIGJ5IGl0cyBwcm9jZXNzIElELlxuICAgKiBJdCB1c2VzIGBTSUdLSUxMYCBzaWduYWwgdG8ga2lsbCB0aGUgY29tbWFuZC5cbiAgICpcbiAgICogQHBhcmFtIHBpZCBwcm9jZXNzIElEIG9mIHRoZSBjb21tYW5kLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBydW5uaW5nIGNvbW1hbmRzIHVzaW5nIHtAbGluayBDb21tYW5kcy5saXN0fS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbW1hbmQgd2FzIGtpbGxlZCwgYGZhbHNlYCBpZiB0aGUgY29tbWFuZCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMga2lsbChwaWQsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ycGMuc2VuZFNpZ25hbChcbiAgICAgICAge1xuICAgICAgICAgIHByb2Nlc3M6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgIGNhc2U6IFwicGlkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBwaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogOSAvKiBTSUdLSUxMICovXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdEVycm9yNSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IENvZGU1Lk5vdEZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBoYW5kbGVScGNFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29ubmVjdCB0byBhIHJ1bm5pbmcgY29tbWFuZC5cbiAgICogWW91IGNhbiB1c2Uge0BsaW5rIENvbW1hbmRIYW5kbGUud2FpdH0gdG8gd2FpdCBmb3IgdGhlIGNvbW1hbmQgdG8gZmluaXNoIGFuZCBnZXQgZXhlY3V0aW9uIHJlc3VsdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwaWQgcHJvY2VzcyBJRCBvZiB0aGUgY29tbWFuZCB0byBjb25uZWN0IHRvLiBZb3UgY2FuIGdldCB0aGUgbGlzdCBvZiBydW5uaW5nIGNvbW1hbmRzIHVzaW5nIHtAbGluayBDb21tYW5kcy5saXN0fS5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgQ29tbWFuZEhhbmRsZWAgaGFuZGxlIHRvIGludGVyYWN0IHdpdGggdGhlIHJ1bm5pbmcgY29tbWFuZC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QocGlkLCBvcHRzKSB7XG4gICAgdmFyIF9hMiwgX2I7XG4gICAgY29uc3QgcmVxdWVzdFRpbWVvdXRNcyA9IChfYTIgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpICE9IG51bGwgPyBfYTIgOiB0aGlzLmNvbm5lY3Rpb25Db25maWcucmVxdWVzdFRpbWVvdXRNcztcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlcVRpbWVvdXQgPSByZXF1ZXN0VGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfSwgcmVxdWVzdFRpbWVvdXRNcykgOiB2b2lkIDA7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5ycGMuY29ubmVjdChcbiAgICAgIHtcbiAgICAgICAgcHJvY2Vzczoge1xuICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICBjYXNlOiBcInBpZFwiLFxuICAgICAgICAgICAgdmFsdWU6IHBpZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFtLRUVQQUxJVkVfUElOR19IRUFERVJdOiBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMudG9TdHJpbmcoKVxuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0TXM6IChfYiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2IgOiB0aGlzLmRlZmF1bHRQcm9jZXNzQ29ubmVjdGlvblRpbWVvdXRcbiAgICAgIH1cbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwaWQyID0gYXdhaXQgaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgIHJldHVybiBuZXcgQ29tbWFuZEhhbmRsZShcbiAgICAgICAgcGlkMixcbiAgICAgICAgKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLFxuICAgICAgICAoKSA9PiB0aGlzLmtpbGwocGlkMiksXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vblN0ZG91dCxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vblN0ZGVycixcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaGFuZGxlUnBjRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcnVuKGNtZCwgb3B0cykge1xuICAgIGNvbnN0IHByb2MgPSBhd2FpdCB0aGlzLnN0YXJ0KGNtZCwgb3B0cyk7XG4gICAgcmV0dXJuIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhY2tncm91bmQpID8gcHJvYyA6IHByb2Mud2FpdCgpO1xuICB9XG4gIGFzeW5jIHN0YXJ0KGNtZCwgb3B0cykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IHJlcXVlc3RUaW1lb3V0TXMgPSAoX2EyID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKSAhPSBudWxsID8gX2EyIDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLnJlcXVlc3RUaW1lb3V0TXM7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCByZXFUaW1lb3V0ID0gcmVxdWVzdFRpbWVvdXRNcyA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0sIHJlcXVlc3RUaW1lb3V0TXMpIDogdm9pZCAwO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMucnBjLnN0YXJ0KFxuICAgICAge1xuICAgICAgICBwcm9jZXNzOiB7XG4gICAgICAgICAgY21kOiBcIi9iaW4vYmFzaFwiLFxuICAgICAgICAgIGN3ZDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5jd2QsXG4gICAgICAgICAgZW52czogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbnZzLFxuICAgICAgICAgIGFyZ3M6IFtcIi1sXCIsIFwiLWNcIiwgY21kXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBhdXRoZW50aWNhdGlvbkhlYWRlcihvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnVzZXIpKSwge1xuICAgICAgICAgIFtLRUVQQUxJVkVfUElOR19IRUFERVJdOiBLRUVQQUxJVkVfUElOR19JTlRFUlZBTF9TRUMudG9TdHJpbmcoKVxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgdGltZW91dE1zOiAoX2IgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnRpbWVvdXRNcykgIT0gbnVsbCA/IF9iIDogdGhpcy5kZWZhdWx0UHJvY2Vzc0Nvbm5lY3Rpb25UaW1lb3V0XG4gICAgICB9XG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGlkID0gYXdhaXQgaGFuZGxlUHJvY2Vzc1N0YXJ0RXZlbnQoZXZlbnRzKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcbiAgICAgIHJldHVybiBuZXcgQ29tbWFuZEhhbmRsZShcbiAgICAgICAgcGlkLFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgICgpID0+IHRoaXMua2lsbChwaWQpLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25TdGRvdXQsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25TdGRlcnIsXG4gICAgICAgIHZvaWQgMFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGhhbmRsZVJwY0Vycm9yKGVycik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc2FuZGJveC9zYW5kYm94QXBpLnRzXG5pbXBvcnQgeyBjb21wYXJlVmVyc2lvbnMgYXMgY29tcGFyZVZlcnNpb25zMiB9IGZyb20gXCJjb21wYXJlLXZlcnNpb25zXCI7XG52YXIgU2FuZGJveEFwaSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgdGhlIHNhbmRib3ggc3BlY2lmaWVkIGJ5IHNhbmRib3ggSUQuXG4gICAqXG4gICAqIEBwYXJhbSBzYW5kYm94SWQgc2FuZGJveCBJRC5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNhbmRib3ggd2FzIGZvdW5kIGFuZCBraWxsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGtpbGwoc2FuZGJveElkLCBvcHRzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmFwaS5ERUxFVEUoXCIvc2FuZGJveGVzL3tzYW5kYm94SUR9XCIsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgc2FuZGJveElEOiBzYW5kYm94SWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgfSk7XG4gICAgaWYgKCgoX2EyID0gcmVzLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvZGUpID09PSA0MDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IGFsbCBydW5uaW5nIHNhbmRib3hlcy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBsaXN0IG9mIHJ1bm5pbmcgc2FuZGJveGVzLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxpc3Qob3B0cykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKG9wdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBBcGlDbGllbnQoY29uZmlnKTtcbiAgICBsZXQgbWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucXVlcnkpIHtcbiAgICAgIGlmIChvcHRzLnF1ZXJ5Lm1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWlycyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRzLnF1ZXJ5Lm1ldGFkYXRhKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgICAgbWV0YWRhdGEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGVuY29kZWRQYWlycykudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmFwaS5HRVQoXCIvc2FuZGJveGVzXCIsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBxdWVyeTogeyBtZXRhZGF0YSB9XG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBjb25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICB9KTtcbiAgICBjb25zdCBlcnIgPSBoYW5kbGVBcGlFcnJvcihyZXMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIChfYiA9IChfYTIgPSByZXMuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tYXAoKHNhbmRib3gpID0+ICh7XG4gICAgICBzYW5kYm94SWQ6IHNhbmRib3guc2FuZGJveElELFxuICAgICAgdGVtcGxhdGVJZDogc2FuZGJveC50ZW1wbGF0ZUlELFxuICAgICAgY2xpZW50SWQ6IHNhbmRib3guY2xpZW50SUQsXG4gICAgICBzdGF0ZTogc2FuZGJveC5zdGF0ZSxcbiAgICAgIGNwdUNvdW50OiBzYW5kYm94LmNwdUNvdW50LFxuICAgICAgbWVtb3J5TUI6IHNhbmRib3gubWVtb3J5TUIsXG4gICAgICBhbGlhczogc2FuZGJveC5hbGlhcyxcbiAgICAgIG1ldGFkYXRhOiBzYW5kYm94Lm1ldGFkYXRhLFxuICAgICAgc3RhcnRlZEF0OiBuZXcgRGF0ZShzYW5kYm94LnN0YXJ0ZWRBdCksXG4gICAgICBlbmRBdDogbmV3IERhdGUoc2FuZGJveC5lbmRBdClcbiAgICB9KSkpICE9IG51bGwgPyBfYiA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc2FuZGJveCBpbmZvcm1hdGlvbiBsaWtlIHNhbmRib3ggSUQsIHRlbXBsYXRlLCBtZXRhZGF0YSwgc3RhcnRlZCBhdC9lbmQgYXQgZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHNhbmRib3hJZCBzYW5kYm94IElELlxuICAgKiBAcGFyYW0gb3B0cyBjb25uZWN0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHNhbmRib3ggaW5mb3JtYXRpb24uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0SW5mbyhzYW5kYm94SWQsIG9wdHMpIHtcbiAgICB2YXIgX2EyO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKG9wdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBBcGlDbGllbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuYXBpLkdFVChcIi9zYW5kYm94ZXMve3NhbmRib3hJRH1cIiwge1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBzYW5kYm94SUQ6IHNhbmRib3hJZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBjb25maWcuZ2V0U2lnbmFsKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVxdWVzdFRpbWVvdXRNcylcbiAgICB9KTtcbiAgICBjb25zdCBlcnIgPSBoYW5kbGVBcGlFcnJvcihyZXMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgaWYgKCFyZXMuZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2FuZGJveCBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHNhbmRib3hJZDogcmVzLmRhdGEuc2FuZGJveElELFxuICAgICAgc2FuZGJveERvbWFpbjogcmVzLmRhdGEuZG9tYWluIHx8IHZvaWQgMCxcbiAgICAgIHRlbXBsYXRlSWQ6IHJlcy5kYXRhLnRlbXBsYXRlSURcbiAgICB9LCByZXMuZGF0YS5hbGlhcyAmJiB7IG5hbWU6IHJlcy5kYXRhLmFsaWFzIH0pLCB7XG4gICAgICBtZXRhZGF0YTogKF9hMiA9IHJlcy5kYXRhLm1ldGFkYXRhKSAhPSBudWxsID8gX2EyIDoge30sXG4gICAgICBlbnZkVmVyc2lvbjogcmVzLmRhdGEuZW52ZFZlcnNpb24sXG4gICAgICBlbnZkQWNjZXNzVG9rZW46IHJlcy5kYXRhLmVudmRBY2Nlc3NUb2tlbixcbiAgICAgIHN0YXJ0ZWRBdDogbmV3IERhdGUocmVzLmRhdGEuc3RhcnRlZEF0KSxcbiAgICAgIGVuZEF0OiBuZXcgRGF0ZShyZXMuZGF0YS5lbmRBdClcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtZXRyaWNzIG9mIHRoZSBzYW5kYm94LlxuICAgKlxuICAgKiBAcGFyYW0gc2FuZGJveElkIHNhbmRib3ggSUQuXG4gICAqIEBwYXJhbSBvcHRzIHNhbmRib3ggbWV0cmljcyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyAgTGlzdCBvZiBzYW5kYm94IG1ldHJpY3MgY29udGFpbmluZyBDUFUsIG1lbW9yeSBhbmQgZGlzayB1c2FnZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRNZXRyaWNzKHNhbmRib3hJZCwgb3B0cykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKG9wdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBBcGlDbGllbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuYXBpLkdFVChcIi9zYW5kYm94ZXMve3NhbmRib3hJRH0vbWV0cmljc1wiLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIHNhbmRib3hJRDogc2FuZGJveElkLFxuICAgICAgICAgIHN0YXJ0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnN0YXJ0LFxuICAgICAgICAgIGVuZDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbmRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgfSk7XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiAoX2IgPSAoX2EyID0gcmVzLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubWFwKChtZXRyaWMpID0+ICh7XG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKG1ldHJpYy50aW1lc3RhbXApLFxuICAgICAgY3B1VXNlZFBjdDogbWV0cmljLmNwdVVzZWRQY3QsXG4gICAgICBjcHVDb3VudDogbWV0cmljLmNwdUNvdW50LFxuICAgICAgbWVtVXNlZDogbWV0cmljLm1lbVVzZWQsXG4gICAgICBtZW1Ub3RhbDogbWV0cmljLm1lbVRvdGFsLFxuICAgICAgZGlza1VzZWQ6IG1ldHJpYy5kaXNrVXNlZCxcbiAgICAgIGRpc2tUb3RhbDogbWV0cmljLmRpc2tUb3RhbFxuICAgIH0pKSkgIT0gbnVsbCA/IF9iIDogW107XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdGltZW91dCBvZiB0aGUgc3BlY2lmaWVkIHNhbmRib3guXG4gICAqIEFmdGVyIHRoZSB0aW1lb3V0IGV4cGlyZXMgdGhlIHNhbmRib3ggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGtpbGxlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGV4dGVuZCBvciByZWR1Y2UgdGhlIHNhbmRib3ggdGltZW91dCBzZXQgd2hlbiBjcmVhdGluZyB0aGUgc2FuZGJveCBvciBmcm9tIHRoZSBsYXN0IGNhbGwgdG8ge0BsaW5rIFNhbmRib3guc2V0VGltZW91dH0uXG4gICAqXG4gICAqIE1heGltdW0gdGltZSBhIHNhbmRib3ggY2FuIGJlIGtlcHQgYWxpdmUgaXMgMjQgaG91cnMgKDg2XzQwMF8wMDAgbWlsbGlzZWNvbmRzKSBmb3IgUHJvIHVzZXJzIGFuZCAxIGhvdXIgKDNfNjAwXzAwMCBtaWxsaXNlY29uZHMpIGZvciBIb2JieSB1c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHNhbmRib3hJZCBzYW5kYm94IElELlxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gKiptaWxsaXNlY29uZHMqKi5cbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNldFRpbWVvdXQoc2FuZGJveElkLCB0aW1lb3V0TXMsIG9wdHMpIHtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmFwaS5QT1NUKFwiL3NhbmRib3hlcy97c2FuZGJveElEfS90aW1lb3V0XCIsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgc2FuZGJveElEOiBzYW5kYm94SWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0VG9TZWNvbmRzKHRpbWVvdXRNcylcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGNvbmZpZy5nZXRTaWduYWwob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZXF1ZXN0VGltZW91dE1zKVxuICAgIH0pO1xuICAgIGNvbnN0IGVyciA9IGhhbmRsZUFwaUVycm9yKHJlcyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlU2FuZGJveCh0ZW1wbGF0ZSwgdGltZW91dE1zLCBvcHRzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgQ29ubmVjdGlvbkNvbmZpZyhvcHRzKTtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmFwaS5QT1NUKFwiL3NhbmRib3hlc1wiLCB7XG4gICAgICBib2R5OiB7XG4gICAgICAgIGF1dG9QYXVzZTogZmFsc2UsXG4gICAgICAgIHRlbXBsYXRlSUQ6IHRlbXBsYXRlLFxuICAgICAgICBtZXRhZGF0YTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5tZXRhZGF0YSxcbiAgICAgICAgZW52VmFyczogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5lbnZzLFxuICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXRUb1NlY29uZHModGltZW91dE1zKSxcbiAgICAgICAgc2VjdXJlOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnNlY3VyZSxcbiAgICAgICAgYWxsb3dfaW50ZXJuZXRfYWNjZXNzOiAoX2EyID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5hbGxvd0ludGVybmV0QWNjZXNzKSAhPSBudWxsID8gX2EyIDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpXG4gICAgfSk7XG4gICAgY29uc3QgZXJyID0gaGFuZGxlQXBpRXJyb3IocmVzKTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGlmIChjb21wYXJlVmVyc2lvbnMyKHJlcy5kYXRhLmVudmRWZXJzaW9uLCBcIjAuMS4wXCIpIDwgMCkge1xuICAgICAgYXdhaXQgdGhpcy5raWxsKHJlcy5kYXRhLnNhbmRib3hJRCwgb3B0cyk7XG4gICAgICB0aHJvdyBuZXcgVGVtcGxhdGVFcnJvcihcbiAgICAgICAgXCJZb3UgbmVlZCB0byB1cGRhdGUgdGhlIHRlbXBsYXRlIHRvIHVzZSB0aGUgbmV3IFNESy4gWW91IGNhbiBkbyB0aGlzIGJ5IHJ1bm5pbmcgYGUyYiB0ZW1wbGF0ZSBidWlsZGAgaW4gdGhlIGRpcmVjdG9yeSB3aXRoIHRoZSB0ZW1wbGF0ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbmRib3hJZDogcmVzLmRhdGEuc2FuZGJveElELFxuICAgICAgc2FuZGJveERvbWFpbjogcmVzLmRhdGEuZG9tYWluIHx8IHZvaWQgMCxcbiAgICAgIGVudmRWZXJzaW9uOiByZXMuZGF0YS5lbnZkVmVyc2lvbixcbiAgICAgIGVudmRBY2Nlc3NUb2tlbjogcmVzLmRhdGEuZW52ZEFjY2Vzc1Rva2VuXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgdGltZW91dFRvU2Vjb25kcyh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aW1lb3V0IC8gMWUzKTtcbiAgfVxufTtcblxuLy8gc3JjL3NhbmRib3gvaW5kZXgudHNcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucyBhcyBjb21wYXJlVmVyc2lvbnMzIH0gZnJvbSBcImNvbXBhcmUtdmVyc2lvbnNcIjtcbnZhciBfU2FuZGJveCA9IGNsYXNzIF9TYW5kYm94IGV4dGVuZHMgU2FuZGJveEFwaSB7XG4gIC8qKlxuICAgKiBVc2Uge0BsaW5rIFNhbmRib3guY3JlYXRlfSB0byBjcmVhdGUgYSBuZXcgU2FuZGJveCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAaGlkZGVuXG4gICAqIEBoaWRlXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAYWNjZXNzIHByb3RlY3RlZFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHZhciBfYTI7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVudmRQb3J0ID0gNDk5ODM7XG4gICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnID0gbmV3IENvbm5lY3Rpb25Db25maWcob3B0cyk7XG4gICAgdGhpcy5zYW5kYm94SWQgPSBvcHRzLnNhbmRib3hJZDtcbiAgICB0aGlzLnNhbmRib3hEb21haW4gPSAoX2EyID0gb3B0cy5zYW5kYm94RG9tYWluKSAhPSBudWxsID8gX2EyIDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmRvbWFpbjtcbiAgICB0aGlzLmVudmRBY2Nlc3NUb2tlbiA9IG9wdHMuZW52ZEFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuZW52ZEFwaVVybCA9IGAke3RoaXMuY29ubmVjdGlvbkNvbmZpZy5kZWJ1ZyA/IFwiaHR0cFwiIDogXCJodHRwc1wifTovLyR7dGhpcy5nZXRIb3N0KHRoaXMuZW52ZFBvcnQpfWA7XG4gICAgY29uc3QgcnBjVHJhbnNwb3J0ID0gY3JlYXRlQ29ubmVjdFRyYW5zcG9ydCh7XG4gICAgICBiYXNlVXJsOiB0aGlzLmVudmRBcGlVcmwsXG4gICAgICB1c2VCaW5hcnlGb3JtYXQ6IGZhbHNlLFxuICAgICAgaW50ZXJjZXB0b3JzOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5sb2dnZXIpID8gW2NyZWF0ZVJwY0xvZ2dlcihvcHRzLmxvZ2dlcildIDogdm9pZCAwLFxuICAgICAgZmV0Y2g6ICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5oZWFkZXJzKTtcbiAgICAgICAgbmV3IEhlYWRlcnMob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKFxuICAgICAgICAgICh2YWx1ZSwga2V5KSA9PiBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5lbnZkQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChcIlgtQWNjZXNzLVRva2VuXCIsIHRoaXMuZW52ZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9KSwge1xuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW52ZEFwaSA9IG5ldyBFbnZkQXBpQ2xpZW50KFxuICAgICAge1xuICAgICAgICBhcGlVcmw6IHRoaXMuZW52ZEFwaVVybCxcbiAgICAgICAgbG9nZ2VyOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmxvZ2dlcixcbiAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuZW52ZEFjY2Vzc1Rva2VuLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmVudmRBY2Nlc3NUb2tlbiA/IHsgXCJYLUFjY2Vzcy1Ub2tlblwiOiB0aGlzLmVudmRBY2Nlc3NUb2tlbiB9IDoge31cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZlcnNpb246IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZW52ZFZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZXN5c3RlbTIoXG4gICAgICBycGNUcmFuc3BvcnQsXG4gICAgICB0aGlzLmVudmRBcGksXG4gICAgICB0aGlzLmNvbm5lY3Rpb25Db25maWdcbiAgICApO1xuICAgIHRoaXMuY29tbWFuZHMgPSBuZXcgQ29tbWFuZHMocnBjVHJhbnNwb3J0LCB0aGlzLmNvbm5lY3Rpb25Db25maWcpO1xuICAgIHRoaXMucHR5ID0gbmV3IFB0eShycGNUcmFuc3BvcnQsIHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSh0ZW1wbGF0ZU9yT3B0cywgb3B0cykge1xuICAgIHZhciBfYTI7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgc2FuZGJveE9wdHMgfSA9IHR5cGVvZiB0ZW1wbGF0ZU9yT3B0cyA9PT0gXCJzdHJpbmdcIiA/IHsgdGVtcGxhdGU6IHRlbXBsYXRlT3JPcHRzLCBzYW5kYm94T3B0czogb3B0cyB9IDogeyB0ZW1wbGF0ZTogdGhpcy5kZWZhdWx0VGVtcGxhdGUsIHNhbmRib3hPcHRzOiB0ZW1wbGF0ZU9yT3B0cyB9O1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKHNhbmRib3hPcHRzKTtcbiAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBzYW5kYm94SWQ6IFwiZGVidWdfc2FuZGJveF9pZFwiXG4gICAgICB9LCBjb25maWcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2FuZGJveCA9IGF3YWl0IHRoaXMuY3JlYXRlU2FuZGJveChcbiAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgIChfYTIgPSBzYW5kYm94T3B0cyA9PSBudWxsID8gdm9pZCAwIDogc2FuZGJveE9wdHMudGltZW91dE1zKSAhPSBudWxsID8gX2EyIDogdGhpcy5kZWZhdWx0U2FuZGJveFRpbWVvdXRNcyxcbiAgICAgICAgc2FuZGJveE9wdHNcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHNhbmRib3gpLCBjb25maWcpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gYW4gZXhpc3Rpbmcgc2FuZGJveC5cbiAgICogV2l0aCBzYW5kYm94IElEIHlvdSBjYW4gY29ubmVjdCB0byB0aGUgc2FtZSBzYW5kYm94IGZyb20gZGlmZmVyZW50IHBsYWNlcyBvciBlbnZpcm9ubWVudHMgKHNlcnZlcmxlc3MgZnVuY3Rpb25zLCBldGMpLlxuICAgKlxuICAgKiBAcGFyYW0gc2FuZGJveElkIHNhbmRib3ggSUQuXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgc2FuZGJveCBpbnN0YW5jZSBmb3IgdGhlIGV4aXN0aW5nIHNhbmRib3guXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHNhbmRib3ggPSBhd2FpdCBTYW5kYm94LmNyZWF0ZSgpXG4gICAqIGNvbnN0IHNhbmRib3hJZCA9IHNhbmRib3guc2FuZGJveElkXG4gICAqXG4gICAqIC8vIENvbm5lY3QgdG8gdGhlIHNhbWUgc2FuZGJveC5cbiAgICogY29uc3Qgc2FtZVNhbmRib3ggPSBhd2FpdCBTYW5kYm94LmNvbm5lY3Qoc2FuZGJveElkKVxuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjb25uZWN0KHNhbmRib3hJZCwgb3B0cykge1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25uZWN0aW9uQ29uZmlnKG9wdHMpO1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmdldEluZm8oc2FuZGJveElkLCBvcHRzKTtcbiAgICByZXR1cm4gbmV3IHRoaXMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgc2FuZGJveElkLFxuICAgICAgc2FuZGJveERvbWFpbjogaW5mby5zYW5kYm94RG9tYWluLFxuICAgICAgZW52ZEFjY2Vzc1Rva2VuOiBpbmZvLmVudmRBY2Nlc3NUb2tlbixcbiAgICAgIGVudmRWZXJzaW9uOiBpbmZvLmVudmRWZXJzaW9uXG4gICAgfSwgY29uZmlnKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaG9zdCBhZGRyZXNzIGZvciB0aGUgc3BlY2lmaWVkIHNhbmRib3ggcG9ydC5cbiAgICogWW91IGNhbiB0aGVuIHVzZSB0aGlzIGFkZHJlc3MgdG8gY29ubmVjdCB0byB0aGUgc2FuZGJveCBwb3J0IGZyb20gb3V0c2lkZSB0aGUgc2FuZGJveCB2aWEgSFRUUCBvciBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwb3J0IG51bWJlciBvZiB0aGUgcG9ydCBpbiB0aGUgc2FuZGJveC5cbiAgICpcbiAgICogQHJldHVybnMgaG9zdCBhZGRyZXNzIG9mIHRoZSBzYW5kYm94IHBvcnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHNhbmRib3ggPSBhd2FpdCBTYW5kYm94LmNyZWF0ZSgpXG4gICAqIC8vIFN0YXJ0IGFuIEhUVFAgc2VydmVyXG4gICAqIGF3YWl0IHNhbmRib3guY29tbWFuZHMuZXhlYygncHl0aG9uMyAtbSBodHRwLnNlcnZlciAzMDAwJylcbiAgICogLy8gR2V0IHRoZSBob3N0bmFtZSBvZiB0aGUgSFRUUCBzZXJ2ZXJcbiAgICogY29uc3Qgc2VydmVyVVJMID0gc2FuZGJveC5nZXRIb3N0KDMwMDApXG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0SG9zdChwb3J0KSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5kZWJ1Zykge1xuICAgICAgcmV0dXJuIGBsb2NhbGhvc3Q6JHtwb3J0fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwb3J0fS0ke3RoaXMuc2FuZGJveElkfS4ke3RoaXMuc2FuZGJveERvbWFpbn1gO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc2FuZGJveCBpcyBydW5uaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNhbmRib3ggaXMgcnVubmluZywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHNhbmRib3ggPSBhd2FpdCBTYW5kYm94LmNyZWF0ZSgpXG4gICAqIGF3YWl0IHNhbmRib3guaXNSdW5uaW5nKCkgLy8gUmV0dXJucyB0cnVlXG4gICAqXG4gICAqIGF3YWl0IHNhbmRib3gua2lsbCgpXG4gICAqIGF3YWl0IHNhbmRib3guaXNSdW5uaW5nKCkgLy8gUmV0dXJucyBmYWxzZVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGlzUnVubmluZyhvcHRzKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldFNpZ25hbChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlcXVlc3RUaW1lb3V0TXMpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZW52ZEFwaS5hcGkuR0VUKFwiL2hlYWx0aFwiLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAocmVzLnJlc3BvbnNlLnN0YXR1cyA9PSA1MDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXJyID0gYXdhaXQgaGFuZGxlRW52ZEFwaUVycm9yKHJlcyk7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB0aW1lb3V0IG9mIHRoZSBzYW5kYm94LlxuICAgKiBBZnRlciB0aGUgdGltZW91dCBleHBpcmVzIHRoZSBzYW5kYm94IHdpbGwgYmUgYXV0b21hdGljYWxseSBraWxsZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBleHRlbmQgb3IgcmVkdWNlIHRoZSBzYW5kYm94IHRpbWVvdXQgc2V0IHdoZW4gY3JlYXRpbmcgdGhlIHNhbmRib3ggb3IgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIGAuc2V0VGltZW91dGAuXG4gICAqIE1heGltdW0gdGltZSBhIHNhbmRib3ggY2FuIGJlIGtlcHQgYWxpdmUgaXMgMjQgaG91cnMgKDg2XzQwMF8wMDAgbWlsbGlzZWNvbmRzKSBmb3IgUHJvIHVzZXJzIGFuZCAxIGhvdXIgKDNfNjAwXzAwMCBtaWxsaXNlY29uZHMpIGZvciBIb2JieSB1c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXRNcyB0aW1lb3V0IGluICoqbWlsbGlzZWNvbmRzKiouXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHNldFRpbWVvdXQodGltZW91dE1zLCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBfU2FuZGJveC5zZXRUaW1lb3V0KHRoaXMuc2FuZGJveElkLCB0aW1lb3V0TXMsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmNvbm5lY3Rpb25Db25maWcpLCBvcHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIEtpbGwgdGhlIHNhbmRib3guXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIGNvbm5lY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGtpbGwob3B0cykge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Db25maWcuZGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgX1NhbmRib3gua2lsbCh0aGlzLnNhbmRib3hJZCwgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuY29ubmVjdGlvbkNvbmZpZyksIG9wdHMpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBVUkwgdG8gdXBsb2FkIGEgZmlsZSB0byB0aGUgc2FuZGJveC5cbiAgICpcbiAgICogWW91IGhhdmUgdG8gc2VuZCBhIFBPU1QgcmVxdWVzdCB0byB0aGlzIFVSTCB3aXRoIHRoZSBmaWxlIGFzIG11bHRpcGFydC9mb3JtLWRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIHBhdGggdG8gdGhlIGZpbGUgaW4gdGhlIHNhbmRib3guXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIGRvd25sb2FkIHVybCBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBVUkwgZm9yIHVwbG9hZGluZyBmaWxlLlxuICAgKi9cbiAgYXN5bmMgdXBsb2FkVXJsKHBhdGgsIG9wdHMpIHtcbiAgICB2YXIgX2EyO1xuICAgIG9wdHMgPSBvcHRzICE9IG51bGwgPyBvcHRzIDoge307XG4gICAgY29uc3QgdXNlU2lnbmF0dXJlID0gISF0aGlzLmVudmRBY2Nlc3NUb2tlbjtcbiAgICBpZiAoIXVzZVNpZ25hdHVyZSAmJiBvcHRzLnVzZVNpZ25hdHVyZUV4cGlyYXRpb24gIT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiU2lnbmF0dXJlIGV4cGlyYXRpb24gY2FuIGJlIHVzZWQgb25seSB3aGVuIHNhbmRib3ggaXMgY3JlYXRlZCBhcyBzZWN1cmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1c2VybmFtZSA9IChfYTIgPSBvcHRzLnVzZXIpICE9IG51bGwgPyBfYTIgOiBkZWZhdWx0VXNlcm5hbWU7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoICE9IG51bGwgPyBwYXRoIDogXCJcIjtcbiAgICBjb25zdCBmaWxlVXJsID0gdGhpcy5maWxlVXJsKGZpbGVQYXRoLCB1c2VybmFtZSk7XG4gICAgaWYgKHVzZVNpZ25hdHVyZSkge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChmaWxlVXJsKTtcbiAgICAgIGNvbnN0IHNpZyA9IGF3YWl0IGdldFNpZ25hdHVyZSh7XG4gICAgICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgICAgICBvcGVyYXRpb246IFwid3JpdGVcIixcbiAgICAgICAgdXNlcjogdXNlcm5hbWUsXG4gICAgICAgIGV4cGlyYXRpb25JblNlY29uZHM6IG9wdHMudXNlU2lnbmF0dXJlRXhwaXJhdGlvbixcbiAgICAgICAgZW52ZEFjY2Vzc1Rva2VuOiB0aGlzLmVudmRBY2Nlc3NUb2tlblxuICAgICAgfSk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInNpZ25hdHVyZVwiLCBzaWcuc2lnbmF0dXJlKTtcbiAgICAgIGlmIChzaWcuZXhwaXJhdGlvbikge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInNpZ25hdHVyZV9leHBpcmF0aW9uXCIsIHNpZy5leHBpcmF0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZVVybDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBVUkwgdG8gZG93bmxvYWQgYSBmaWxlIGZyb20gdGhlIHNhbmRib3guXG4gICAqXG4gICAqIEBwYXJhbSBwYXRoIHBhdGggdG8gdGhlIGZpbGUgaW4gdGhlIHNhbmRib3guXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIGRvd25sb2FkIHVybCBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBVUkwgZm9yIGRvd25sb2FkaW5nIGZpbGUuXG4gICAqL1xuICBhc3luYyBkb3dubG9hZFVybChwYXRoLCBvcHRzKSB7XG4gICAgdmFyIF9hMjtcbiAgICBvcHRzID0gb3B0cyAhPSBudWxsID8gb3B0cyA6IHt9O1xuICAgIGNvbnN0IHVzZVNpZ25hdHVyZSA9ICEhdGhpcy5lbnZkQWNjZXNzVG9rZW47XG4gICAgaWYgKCF1c2VTaWduYXR1cmUgJiYgb3B0cy51c2VTaWduYXR1cmVFeHBpcmF0aW9uICE9IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlNpZ25hdHVyZSBleHBpcmF0aW9uIGNhbiBiZSB1c2VkIG9ubHkgd2hlbiBzYW5kYm94IGlzIGNyZWF0ZWQgYXMgc2VjdXJlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlcm5hbWUgPSAoX2EyID0gb3B0cy51c2VyKSAhPSBudWxsID8gX2EyIDogZGVmYXVsdFVzZXJuYW1lO1xuICAgIGNvbnN0IGZpbGVVcmwgPSB0aGlzLmZpbGVVcmwocGF0aCwgdXNlcm5hbWUpO1xuICAgIGlmICh1c2VTaWduYXR1cmUpIHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZmlsZVVybCk7XG4gICAgICBjb25zdCBzaWcgPSBhd2FpdCBnZXRTaWduYXR1cmUoe1xuICAgICAgICBwYXRoLFxuICAgICAgICBvcGVyYXRpb246IFwicmVhZFwiLFxuICAgICAgICB1c2VyOiB1c2VybmFtZSxcbiAgICAgICAgZXhwaXJhdGlvbkluU2Vjb25kczogb3B0cy51c2VTaWduYXR1cmVFeHBpcmF0aW9uLFxuICAgICAgICBlbnZkQWNjZXNzVG9rZW46IHRoaXMuZW52ZEFjY2Vzc1Rva2VuXG4gICAgICB9KTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2lnbmF0dXJlXCIsIHNpZy5zaWduYXR1cmUpO1xuICAgICAgaWYgKHNpZy5leHBpcmF0aW9uKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2lnbmF0dXJlX2V4cGlyYXRpb25cIiwgc2lnLmV4cGlyYXRpb24udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlVXJsO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc2FuZGJveCBpbmZvcm1hdGlvbiBsaWtlIHNhbmRib3ggSUQsIHRlbXBsYXRlLCBtZXRhZGF0YSwgc3RhcnRlZCBhdC9lbmQgYXQgZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2FuZGJveFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbyhvcHRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IF9TYW5kYm94LmdldEluZm8odGhpcy5zYW5kYm94SWQsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmNvbm5lY3Rpb25Db25maWcpLCBvcHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWV0cmljcyBvZiB0aGUgc2FuZGJveC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgY29ubmVjdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyAgTGlzdCBvZiBzYW5kYm94IG1ldHJpY3MgY29udGFpbmluZyBDUFUsIG1lbW9yeSBhbmQgZGlzayB1c2FnZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGFzeW5jIGdldE1ldHJpY3Mob3B0cykge1xuICAgIHZhciBfYTIsIF9iO1xuICAgIGlmICh0aGlzLmVudmRBcGkudmVyc2lvbikge1xuICAgICAgaWYgKGNvbXBhcmVWZXJzaW9uczModGhpcy5lbnZkQXBpLnZlcnNpb24sIFwiMC4xLjVcIikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTYW5kYm94RXJyb3IoXG4gICAgICAgICAgXCJZb3UgbmVlZCB0byB1cGRhdGUgdGhlIHRlbXBsYXRlIHRvIHVzZSB0aGUgbmV3IFNESy4gWW91IGNhbiBkbyB0aGlzIGJ5IHJ1bm5pbmcgYGUyYiB0ZW1wbGF0ZSBidWlsZGAgaW4gdGhlIGRpcmVjdG9yeSB3aXRoIHRoZSB0ZW1wbGF0ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmVWZXJzaW9uczModGhpcy5lbnZkQXBpLnZlcnNpb24sIFwiMC4yLjRcIikgPCAwKSB7XG4gICAgICAgIChfYiA9IChfYTIgPSB0aGlzLmNvbm5lY3Rpb25Db25maWcubG9nZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLndhcm4pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKFxuICAgICAgICAgIF9hMixcbiAgICAgICAgICBcIkRpc2sgbWV0cmljcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIHZlcnNpb24gb2YgdGhlIHNhbmRib3gsIHBsZWFzZSByZWJ1aWxkIHRoZSB0ZW1wbGF0ZSB0byBnZXQgZGlzayBtZXRyaWNzLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBfU2FuZGJveC5nZXRNZXRyaWNzKHRoaXMuc2FuZGJveElkLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5jb25uZWN0aW9uQ29uZmlnKSwgb3B0cykpO1xuICB9XG4gIGZpbGVVcmwocGF0aCwgdXNlcm5hbWUpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiL2ZpbGVzXCIsIHRoaXMuZW52ZEFwaVVybCk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ1c2VybmFtZVwiLCB1c2VybmFtZSAhPSBudWxsID8gdXNlcm5hbWUgOiBkZWZhdWx0VXNlcm5hbWUpO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInBhdGhcIiwgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgfVxufTtcbl9TYW5kYm94LmRlZmF1bHRUZW1wbGF0ZSA9IFwiYmFzZVwiO1xuX1NhbmRib3guZGVmYXVsdFNhbmRib3hUaW1lb3V0TXMgPSAzZTU7XG52YXIgU2FuZGJveCA9IF9TYW5kYm94O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZGVmYXVsdCA9IFNhbmRib3g7XG5leHBvcnQge1xuICBBcGlDbGllbnQsXG4gIEF1dGhlbnRpY2F0aW9uRXJyb3IsXG4gIENvbW1hbmRFeGl0RXJyb3IsXG4gIENvbm5lY3Rpb25Db25maWcsXG4gIEZpbGVUeXBlMiBhcyBGaWxlVHlwZSxcbiAgRmlsZXN5c3RlbUV2ZW50VHlwZSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIE5vdEVub3VnaFNwYWNlRXJyb3IsXG4gIE5vdEZvdW5kRXJyb3IsXG4gIFJhdGVMaW1pdEVycm9yLFxuICBTYW5kYm94LFxuICBTYW5kYm94RXJyb3IsXG4gIFRlbXBsYXRlRXJyb3IsXG4gIFRpbWVvdXRFcnJvcixcbiAgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgZ2V0U2lnbmF0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/e2b/dist/index.mjs\n");

/***/ })

};
;