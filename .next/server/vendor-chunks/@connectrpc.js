"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@connectrpc";
exports.ids = ["vendor-chunks/@connectrpc"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertFetchApi: () => (/* binding */ assertFetchApi)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Asserts that the fetch API is available.\n */\nfunction assertFetchApi() {\n    try {\n        new Headers();\n    }\n    catch (_) {\n        throw new Error(\"connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0LXdlYi9kaXN0L2VzbS9hc3NlcnQtZmV0Y2gtYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3Qtd2ViL2Rpc3QvZXNtL2Fzc2VydC1mZXRjaC1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBmZXRjaCBBUEkgaXMgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmV0Y2hBcGkoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEhlYWRlcnMoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29ubmVjdC13ZWIgcmVxdWlyZXMgdGhlIGZldGNoIEFQSS4gQXJlIHlvdSBydW5uaW5nIG9uIGFuIG9sZCB2ZXJzaW9uIG9mIE5vZGUuanM/IE5vZGUuanMgaXMgbm90IHN1cHBvcnRlZCBpbiBDb25uZWN0IGZvciBXZWIgLSBwbGVhc2Ugc3RheSB0dW5lZCBmb3IgQ29ubmVjdCBmb3IgTm9kZS5cIik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createConnectTransport: () => (/* binding */ createConnectTransport)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/from-json.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/context-values.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @connectrpc/connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js\");\n/* harmony import */ var _assert_fetch_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert-fetch-api.js */ \"(action-browser)/./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js\");\n/* harmony import */ var _bufbuild_protobuf_wkt__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @bufbuild/protobuf/wkt */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/wkt/gen/google/protobuf/descriptor_pb.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\nconst fetchOptions = {\n    redirect: \"error\",\n};\n/**\n * Create a Transport for the Connect protocol, which makes unary and\n * server-streaming methods available to web browsers. It uses the fetch\n * API to make HTTP requests.\n */\nfunction createConnectTransport(options) {\n    var _a;\n    (0,_assert_fetch_api_js__WEBPACK_IMPORTED_MODULE_0__.assertFetchApi)();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : false;\n    return {\n        async unary(method, signal, timeoutMs, header, message, contextValues) {\n            const { serialize, parse } = (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__.createClientMethodSerializers)(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_2__.runUnaryCall)({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service: method.parent,\n                    method,\n                    requestMethod: \"POST\",\n                    url: (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_3__.createMethodUrl)(options.baseUrl, method),\n                    header: (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_4__.requestHeader)(method.methodKind, useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_5__.createContextValues)(),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const useGet = options.useHttpGet === true &&\n                        method.idempotency ===\n                            _bufbuild_protobuf_wkt__WEBPACK_IMPORTED_MODULE_6__.MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;\n                    let body = null;\n                    if (useGet) {\n                        req = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_7__.transformConnectPostToGetRequest)(req, serialize(req.message), useBinaryFormat);\n                    }\n                    else {\n                        body = serialize(req.message);\n                    }\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body }));\n                    const { isUnaryError, unaryError } = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_8__.validateResponse)(method.methodKind, useBinaryFormat, response.status, response.headers);\n                    if (isUnaryError) {\n                        throw (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_9__.errorFromJson)((await response.json()), (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_10__.appendHeaders)(...(0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_11__.trailerDemux)(response.headers)), unaryError);\n                    }\n                    const [demuxedHeader, demuxedTrailer] = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_11__.trailerDemux)(response.headers);\n                    return {\n                        stream: false,\n                        service: method.parent,\n                        method,\n                        header: demuxedHeader,\n                        message: useBinaryFormat\n                            ? parse(new Uint8Array(await response.arrayBuffer()))\n                            : (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_12__.fromJson)(method.output, (await response.json()), (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__.getJsonOptions)(options.jsonOptions)),\n                        trailer: demuxedTrailer,\n                    };\n                },\n            });\n        },\n        async stream(method, signal, timeoutMs, header, input, contextValues) {\n            const { serialize, parse } = (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__.createClientMethodSerializers)(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, trailerTarget, header, signal) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_13__.createEnvelopeReadableStream)(body).getReader();\n                    let endStreamReceived = false;\n                    for (;;) {\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_14__.compressedFlag) === _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_14__.compressedFlag) {\n                            throw new _connectrpc_connect__WEBPACK_IMPORTED_MODULE_15__.ConnectError(`protocol error: received unsupported compressed output`, _connectrpc_connect__WEBPACK_IMPORTED_MODULE_16__.Code.Internal);\n                        }\n                        if ((flags & _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_17__.endStreamFlag) === _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_17__.endStreamFlag) {\n                            endStreamReceived = true;\n                            const endStream = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_17__.endStreamFromJson)(data);\n                            if (endStream.error) {\n                                const error = endStream.error;\n                                header.forEach((value, key) => {\n                                    error.metadata.append(key, value);\n                                });\n                                throw error;\n                            }\n                            endStream.metadata.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        yield yield __await(parse(data));\n                    }\n                    // Node wil not throw an AbortError on `read` if the\n                    // signal is aborted before `getReader` is called.\n                    // As a work around we check at the end and throw.\n                    //\n                    // Ref: https://github.com/nodejs/undici/issues/1940\n                    if (\"throwIfAborted\" in signal) {\n                        // We assume that implementations without `throwIfAborted` (old\n                        // browsers) do honor aborted signals on `read`.\n                        signal.throwIfAborted();\n                    }\n                    if (!endStreamReceived) {\n                        throw \"missing EndStreamResponse\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.methodKind != \"server_streaming\") {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_13__.encodeEnvelope)(0, serialize(r.value));\n            }\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_2__.runStreamingCall)({\n                interceptors: options.interceptors,\n                timeoutMs,\n                signal,\n                req: {\n                    stream: true,\n                    service: method.parent,\n                    method,\n                    requestMethod: \"POST\",\n                    url: (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_3__.createMethodUrl)(options.baseUrl, method),\n                    header: (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_4__.requestHeader)(method.methodKind, useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_5__.createContextValues)(),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, fetchOptions), { method: req.requestMethod, headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_8__.validateResponse)(method.methodKind, useBinaryFormat, fRes.status, fRes.headers);\n                    if (fRes.body === null) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, trailer, fRes.headers, req.signal) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0LXdlYi9kaXN0L2VzbS9jb25uZWN0LXRyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJLDRCQUE0QjtBQUN2RCx3QkFBd0IsU0FBSSxJQUFJLFNBQUk7QUFDcEM7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDOEM7QUFDZ0Q7QUFDK0c7QUFDcEI7QUFDbEk7QUFDaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLG9FQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsRUFBRSwyRkFBNkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkVBQWU7QUFDeEMsNEJBQTRCLG1GQUFhO0FBQ3pDLHdHQUF3Ryx3RUFBbUI7QUFDM0g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0ZBQThCO0FBQzFEO0FBQ0E7QUFDQSw4QkFBOEIsc0dBQWdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsbUJBQW1CLDBFQUEwRTtBQUNyTCw0QkFBNEIsMkJBQTJCLEVBQUUsc0ZBQWdCO0FBQ3pFO0FBQ0EsOEJBQThCLG1GQUFhLDBCQUEwQixtRUFBYSxJQUFJLG1GQUFZO0FBQ2xHO0FBQ0EsNERBQTRELG1GQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZEQUFRLHlDQUF5Qyw0RUFBYztBQUM3RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsbUJBQW1CLEVBQUUsMkZBQTZCO0FBQ3RFO0FBQ0E7QUFDQSxtQ0FBbUMsMkZBQTRCO0FBQy9EO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUMscUNBQXFDLHlFQUFjLE1BQU0seUVBQWM7QUFDdkUsc0NBQXNDLDhEQUFZLDJEQUEyRCxzREFBSTtBQUNqSDtBQUNBLHFDQUFxQyxnRkFBYSxNQUFNLGdGQUFhO0FBQ3JFO0FBQ0EsOENBQThDLHdGQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2RUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4RUFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2RUFBZTtBQUN4Qyw0QkFBNEIsbUZBQWE7QUFDekMsd0dBQXdHLHdFQUFtQjtBQUMzSDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsbUJBQW1CLGdIQUFnSDtBQUN2TixvQkFBb0Isc0ZBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVUseUdBQXlHO0FBQ2pMO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC13ZWIvZGlzdC9lc20vY29ubmVjdC10cmFuc3BvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5pbXBvcnQgeyBmcm9tSnNvbiB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IENvZGUsIENvbm5lY3RFcnJvciwgYXBwZW5kSGVhZGVycywgY3JlYXRlQ29udGV4dFZhbHVlcywgfSBmcm9tIFwiQGNvbm5lY3RycGMvY29ubmVjdFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50TWV0aG9kU2VyaWFsaXplcnMsIGNyZWF0ZUVudmVsb3BlUmVhZGFibGVTdHJlYW0sIGNyZWF0ZU1ldGhvZFVybCwgZ2V0SnNvbk9wdGlvbnMsIGVuY29kZUVudmVsb3BlLCBydW5TdHJlYW1pbmdDYWxsLCBydW5VbmFyeUNhbGwsIGNvbXByZXNzZWRGbGFnLCB9IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0L3Byb3RvY29sXCI7XG5pbXBvcnQgeyBlbmRTdHJlYW1GbGFnLCBlbmRTdHJlYW1Gcm9tSnNvbiwgZXJyb3JGcm9tSnNvbiwgcmVxdWVzdEhlYWRlciwgdHJhaWxlckRlbXV4LCB0cmFuc2Zvcm1Db25uZWN0UG9zdFRvR2V0UmVxdWVzdCwgdmFsaWRhdGVSZXNwb25zZSwgfSBmcm9tIFwiQGNvbm5lY3RycGMvY29ubmVjdC9wcm90b2NvbC1jb25uZWN0XCI7XG5pbXBvcnQgeyBhc3NlcnRGZXRjaEFwaSB9IGZyb20gXCIuL2Fzc2VydC1mZXRjaC1hcGkuanNcIjtcbmltcG9ydCB7IE1ldGhvZE9wdGlvbnNfSWRlbXBvdGVuY3lMZXZlbCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWYvd2t0XCI7XG5jb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgcmVkaXJlY3Q6IFwiZXJyb3JcIixcbn07XG4vKipcbiAqIENyZWF0ZSBhIFRyYW5zcG9ydCBmb3IgdGhlIENvbm5lY3QgcHJvdG9jb2wsIHdoaWNoIG1ha2VzIHVuYXJ5IGFuZFxuICogc2VydmVyLXN0cmVhbWluZyBtZXRob2RzIGF2YWlsYWJsZSB0byB3ZWIgYnJvd3NlcnMuIEl0IHVzZXMgdGhlIGZldGNoXG4gKiBBUEkgdG8gbWFrZSBIVFRQIHJlcXVlc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdFRyYW5zcG9ydChvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGFzc2VydEZldGNoQXBpKCk7XG4gICAgY29uc3QgdXNlQmluYXJ5Rm9ybWF0ID0gKF9hID0gb3B0aW9ucy51c2VCaW5hcnlGb3JtYXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIHVuYXJ5KG1ldGhvZCwgc2lnbmFsLCB0aW1lb3V0TXMsIGhlYWRlciwgbWVzc2FnZSwgY29udGV4dFZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgeyBzZXJpYWxpemUsIHBhcnNlIH0gPSBjcmVhdGVDbGllbnRNZXRob2RTZXJpYWxpemVycyhtZXRob2QsIHVzZUJpbmFyeUZvcm1hdCwgb3B0aW9ucy5qc29uT3B0aW9ucywgb3B0aW9ucy5iaW5hcnlPcHRpb25zKTtcbiAgICAgICAgICAgIHRpbWVvdXRNcyA9XG4gICAgICAgICAgICAgICAgdGltZW91dE1zID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmRlZmF1bHRUaW1lb3V0TXNcbiAgICAgICAgICAgICAgICAgICAgOiB0aW1lb3V0TXMgPD0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGltZW91dE1zO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1blVuYXJ5Q2FsbCh7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0b3JzOiBvcHRpb25zLmludGVyY2VwdG9ycyxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgdGltZW91dE1zLFxuICAgICAgICAgICAgICAgIHJlcToge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiBtZXRob2QucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGNyZWF0ZU1ldGhvZFVybChvcHRpb25zLmJhc2VVcmwsIG1ldGhvZCksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogcmVxdWVzdEhlYWRlcihtZXRob2QubWV0aG9kS2luZCwgdXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIGhlYWRlciwgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0VmFsdWVzOiBjb250ZXh0VmFsdWVzICE9PSBudWxsICYmIGNvbnRleHRWYWx1ZXMgIT09IHZvaWQgMCA/IGNvbnRleHRWYWx1ZXMgOiBjcmVhdGVDb250ZXh0VmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXh0OiBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlR2V0ID0gb3B0aW9ucy51c2VIdHRwR2V0ID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuaWRlbXBvdGVuY3kgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWV0aG9kT3B0aW9uc19JZGVtcG90ZW5jeUxldmVsLk5PX1NJREVfRUZGRUNUUztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSB0cmFuc2Zvcm1Db25uZWN0UG9zdFRvR2V0UmVxdWVzdChyZXEsIHNlcmlhbGl6ZShyZXEubWVzc2FnZSksIHVzZUJpbmFyeUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gc2VyaWFsaXplKHJlcS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaCA9IChfYSA9IG9wdGlvbnMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxLnVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmZXRjaE9wdGlvbnMpLCB7IG1ldGhvZDogcmVxLnJlcXVlc3RNZXRob2QsIGhlYWRlcnM6IHJlcS5oZWFkZXIsIHNpZ25hbDogcmVxLnNpZ25hbCwgYm9keSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNVbmFyeUVycm9yLCB1bmFyeUVycm9yIH0gPSB2YWxpZGF0ZVJlc3BvbnNlKG1ldGhvZC5tZXRob2RLaW5kLCB1c2VCaW5hcnlGb3JtYXQsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuYXJ5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yRnJvbUpzb24oKGF3YWl0IHJlc3BvbnNlLmpzb24oKSksIGFwcGVuZEhlYWRlcnMoLi4udHJhaWxlckRlbXV4KHJlc3BvbnNlLmhlYWRlcnMpKSwgdW5hcnlFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2RlbXV4ZWRIZWFkZXIsIGRlbXV4ZWRUcmFpbGVyXSA9IHRyYWlsZXJEZW11eChyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiBtZXRob2QucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBkZW11eGVkSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdXNlQmluYXJ5Rm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZShuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZyb21Kc29uKG1ldGhvZC5vdXRwdXQsIChhd2FpdCByZXNwb25zZS5qc29uKCkpLCBnZXRKc29uT3B0aW9ucyhvcHRpb25zLmpzb25PcHRpb25zKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGVyOiBkZW11eGVkVHJhaWxlcixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHN0cmVhbShtZXRob2QsIHNpZ25hbCwgdGltZW91dE1zLCBoZWFkZXIsIGlucHV0LCBjb250ZXh0VmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmlhbGl6ZSwgcGFyc2UgfSA9IGNyZWF0ZUNsaWVudE1ldGhvZFNlcmlhbGl6ZXJzKG1ldGhvZCwgdXNlQmluYXJ5Rm9ybWF0LCBvcHRpb25zLmpzb25PcHRpb25zLCBvcHRpb25zLmJpbmFyeU9wdGlvbnMpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VSZXNwb25zZUJvZHkoYm9keSwgdHJhaWxlclRhcmdldCwgaGVhZGVyLCBzaWduYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwYXJzZVJlc3BvbnNlQm9keV8xKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBjcmVhdGVFbnZlbG9wZVJlYWRhYmxlU3RyZWFtKGJvZHkpLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kU3RyZWFtUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgX19hd2FpdChyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmbGFncywgZGF0YSB9ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIGNvbXByZXNzZWRGbGFnKSA9PT0gY29tcHJlc3NlZEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBwcm90b2NvbCBlcnJvcjogcmVjZWl2ZWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCBvdXRwdXRgLCBDb2RlLkludGVybmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFN0cmVhbVJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRTdHJlYW0gPSBlbmRTdHJlYW1Gcm9tSnNvbihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3RyZWFtLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZW5kU3RyZWFtLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWV0YWRhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFN0cmVhbS5tZXRhZGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0cmFpbGVyVGFyZ2V0LnNldChrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlIHdpbCBub3QgdGhyb3cgYW4gQWJvcnRFcnJvciBvbiBgcmVhZGAgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hbCBpcyBhYm9ydGVkIGJlZm9yZSBgZ2V0UmVhZGVyYCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFzIGEgd29yayBhcm91bmQgd2UgY2hlY2sgYXQgdGhlIGVuZCBhbmQgdGhyb3cuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE5NDBcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidGhyb3dJZkFib3J0ZWRcIiBpbiBzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGltcGxlbWVudGF0aW9ucyB3aXRob3V0IGB0aHJvd0lmQWJvcnRlZGAgKG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMpIGRvIGhvbm9yIGFib3J0ZWQgc2lnbmFscyBvbiBgcmVhZGAuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwudGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZFN0cmVhbVJlY2VpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgRW5kU3RyZWFtUmVzcG9uc2VcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEJvZHkoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kLm1ldGhvZEtpbmQgIT0gXCJzZXJ2ZXJfc3RyZWFtaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJUaGUgZmV0Y2ggQVBJIGRvZXMgbm90IHN1cHBvcnQgc3RyZWFtaW5nIHJlcXVlc3QgYm9kaWVzXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBpbnB1dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHIuZG9uZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwibWlzc2luZyByZXF1ZXN0IG1lc3NhZ2VcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUVudmVsb3BlKDAsIHNlcmlhbGl6ZShyLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lb3V0TXMgPVxuICAgICAgICAgICAgICAgIHRpbWVvdXRNcyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kZWZhdWx0VGltZW91dE1zXG4gICAgICAgICAgICAgICAgICAgIDogdGltZW91dE1zIDw9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRpbWVvdXRNcztcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5TdHJlYW1pbmdDYWxsKHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvcnM6IG9wdGlvbnMuaW50ZXJjZXB0b3JzLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRNcyxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgcmVxOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZTogbWV0aG9kLnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjcmVhdGVNZXRob2RVcmwob3B0aW9ucy5iYXNlVXJsLCBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHJlcXVlc3RIZWFkZXIobWV0aG9kLm1ldGhvZEtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgdGltZW91dE1zLCBoZWFkZXIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFZhbHVlczogY29udGV4dFZhbHVlcyAhPT0gbnVsbCAmJiBjb250ZXh0VmFsdWVzICE9PSB2b2lkIDAgPyBjb250ZXh0VmFsdWVzIDogY3JlYXRlQ29udGV4dFZhbHVlcygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5leHQ6IGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaCA9IChfYSA9IG9wdGlvbnMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZSZXMgPSBhd2FpdCBmZXRjaChyZXEudXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZldGNoT3B0aW9ucyksIHsgbWV0aG9kOiByZXEucmVxdWVzdE1ldGhvZCwgaGVhZGVyczogcmVxLmhlYWRlciwgc2lnbmFsOiByZXEuc2lnbmFsLCBib2R5OiBhd2FpdCBjcmVhdGVSZXF1ZXN0Qm9keShyZXEubWVzc2FnZSkgfSkpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVJlc3BvbnNlKG1ldGhvZC5tZXRob2RLaW5kLCB1c2VCaW5hcnlGb3JtYXQsIGZSZXMuc3RhdHVzLCBmUmVzLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZlJlcy5ib2R5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm1pc3NpbmcgcmVzcG9uc2UgYm9keVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXIgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcSksIHsgaGVhZGVyOiBmUmVzLmhlYWRlcnMsIHRyYWlsZXIsIG1lc3NhZ2U6IHBhcnNlUmVzcG9uc2VCb2R5KGZSZXMuYm9keSwgdHJhaWxlciwgZlJlcy5oZWFkZXJzLCByZXEuc2lnbmFsKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/any-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/any-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeAnyClient: () => (/* binding */ makeAnyClient)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create any client for the given service.\n *\n * The given createMethod function is called for each method definition\n * of the service. The function it returns is added to the client object\n * as a method.\n */\nfunction makeAnyClient(service, createMethod) {\n    const client = {};\n    for (const desc of service.methods) {\n        const method = createMethod(desc);\n        if (method != null) {\n            client[desc.localName] = method;\n        }\n    }\n    return client;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2FueS1jbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9hbnktY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhbnkgY2xpZW50IGZvciB0aGUgZ2l2ZW4gc2VydmljZS5cbiAqXG4gKiBUaGUgZ2l2ZW4gY3JlYXRlTWV0aG9kIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaCBtZXRob2QgZGVmaW5pdGlvblxuICogb2YgdGhlIHNlcnZpY2UuIFRoZSBmdW5jdGlvbiBpdCByZXR1cm5zIGlzIGFkZGVkIHRvIHRoZSBjbGllbnQgb2JqZWN0XG4gKiBhcyBhIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBbnlDbGllbnQoc2VydmljZSwgY3JlYXRlTWV0aG9kKSB7XG4gICAgY29uc3QgY2xpZW50ID0ge307XG4gICAgZm9yIChjb25zdCBkZXNjIG9mIHNlcnZpY2UubWV0aG9kcykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSBjcmVhdGVNZXRob2QoZGVzYyk7XG4gICAgICAgIGlmIChtZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xpZW50W2Rlc2MubG9jYWxOYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/any-client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js":
/*!***********************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/code.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Connect represents categories of errors as codes, and each code maps to a\n * specific HTTP status code. The codes and their semantics were chosen to\n * match gRPC. Only the codes below are valid â€” there are no user-defined\n * codes.\n *\n * See the specification at https://connectrpc.com/docs/protocol#error-codes\n * for details.\n */\nvar Code;\n(function (Code) {\n    /**\n     * Canceled, usually be the user\n     */\n    Code[Code[\"Canceled\"] = 1] = \"Canceled\";\n    /**\n     * Unknown error\n     */\n    Code[Code[\"Unknown\"] = 2] = \"Unknown\";\n    /**\n     * Argument invalid regardless of system state\n     */\n    Code[Code[\"InvalidArgument\"] = 3] = \"InvalidArgument\";\n    /**\n     * Operation expired, may or may not have completed.\n     */\n    Code[Code[\"DeadlineExceeded\"] = 4] = \"DeadlineExceeded\";\n    /**\n     * Entity not found.\n     */\n    Code[Code[\"NotFound\"] = 5] = \"NotFound\";\n    /**\n     * Entity already exists.\n     */\n    Code[Code[\"AlreadyExists\"] = 6] = \"AlreadyExists\";\n    /**\n     * Operation not authorized.\n     */\n    Code[Code[\"PermissionDenied\"] = 7] = \"PermissionDenied\";\n    /**\n     * Quota exhausted.\n     */\n    Code[Code[\"ResourceExhausted\"] = 8] = \"ResourceExhausted\";\n    /**\n     * Argument invalid in current system state.\n     */\n    Code[Code[\"FailedPrecondition\"] = 9] = \"FailedPrecondition\";\n    /**\n     * Operation aborted.\n     */\n    Code[Code[\"Aborted\"] = 10] = \"Aborted\";\n    /**\n     * Out of bounds, use instead of FailedPrecondition.\n     */\n    Code[Code[\"OutOfRange\"] = 11] = \"OutOfRange\";\n    /**\n     * Operation not implemented or disabled.\n     */\n    Code[Code[\"Unimplemented\"] = 12] = \"Unimplemented\";\n    /**\n     * Internal error, reserved for \"serious errors\".\n     */\n    Code[Code[\"Internal\"] = 13] = \"Internal\";\n    /**\n     * Unavailable, client should back off and retry.\n     */\n    Code[Code[\"Unavailable\"] = 14] = \"Unavailable\";\n    /**\n     * Unrecoverable data loss or corruption.\n     */\n    Code[Code[\"DataLoss\"] = 15] = \"DataLoss\";\n    /**\n     * Request isn't authenticated.\n     */\n    Code[Code[\"Unauthenticated\"] = 16] = \"Unauthenticated\";\n})(Code || (Code = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2NvZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vY29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDb25uZWN0IHJlcHJlc2VudHMgY2F0ZWdvcmllcyBvZiBlcnJvcnMgYXMgY29kZXMsIGFuZCBlYWNoIGNvZGUgbWFwcyB0byBhXG4gKiBzcGVjaWZpYyBIVFRQIHN0YXR1cyBjb2RlLiBUaGUgY29kZXMgYW5kIHRoZWlyIHNlbWFudGljcyB3ZXJlIGNob3NlbiB0b1xuICogbWF0Y2ggZ1JQQy4gT25seSB0aGUgY29kZXMgYmVsb3cgYXJlIHZhbGlkIOKAlCB0aGVyZSBhcmUgbm8gdXNlci1kZWZpbmVkXG4gKiBjb2Rlcy5cbiAqXG4gKiBTZWUgdGhlIHNwZWNpZmljYXRpb24gYXQgaHR0cHM6Ly9jb25uZWN0cnBjLmNvbS9kb2NzL3Byb3RvY29sI2Vycm9yLWNvZGVzXG4gKiBmb3IgZGV0YWlscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlO1xuKGZ1bmN0aW9uIChDb2RlKSB7XG4gICAgLyoqXG4gICAgICogQ2FuY2VsZWQsIHVzdWFsbHkgYmUgdGhlIHVzZXJcbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJDYW5jZWxlZFwiXSA9IDFdID0gXCJDYW5jZWxlZFwiO1xuICAgIC8qKlxuICAgICAqIFVua25vd24gZXJyb3JcbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJVbmtub3duXCJdID0gMl0gPSBcIlVua25vd25cIjtcbiAgICAvKipcbiAgICAgKiBBcmd1bWVudCBpbnZhbGlkIHJlZ2FyZGxlc3Mgb2Ygc3lzdGVtIHN0YXRlXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiSW52YWxpZEFyZ3VtZW50XCJdID0gM10gPSBcIkludmFsaWRBcmd1bWVudFwiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbiBleHBpcmVkLCBtYXkgb3IgbWF5IG5vdCBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJEZWFkbGluZUV4Y2VlZGVkXCJdID0gNF0gPSBcIkRlYWRsaW5lRXhjZWVkZWRcIjtcbiAgICAvKipcbiAgICAgKiBFbnRpdHkgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIk5vdEZvdW5kXCJdID0gNV0gPSBcIk5vdEZvdW5kXCI7XG4gICAgLyoqXG4gICAgICogRW50aXR5IGFscmVhZHkgZXhpc3RzLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIkFscmVhZHlFeGlzdHNcIl0gPSA2XSA9IFwiQWxyZWFkeUV4aXN0c1wiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbiBub3QgYXV0aG9yaXplZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJQZXJtaXNzaW9uRGVuaWVkXCJdID0gN10gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcbiAgICAvKipcbiAgICAgKiBRdW90YSBleGhhdXN0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiUmVzb3VyY2VFeGhhdXN0ZWRcIl0gPSA4XSA9IFwiUmVzb3VyY2VFeGhhdXN0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBBcmd1bWVudCBpbnZhbGlkIGluIGN1cnJlbnQgc3lzdGVtIHN0YXRlLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIkZhaWxlZFByZWNvbmRpdGlvblwiXSA9IDldID0gXCJGYWlsZWRQcmVjb25kaXRpb25cIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gYWJvcnRlZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJBYm9ydGVkXCJdID0gMTBdID0gXCJBYm9ydGVkXCI7XG4gICAgLyoqXG4gICAgICogT3V0IG9mIGJvdW5kcywgdXNlIGluc3RlYWQgb2YgRmFpbGVkUHJlY29uZGl0aW9uLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIk91dE9mUmFuZ2VcIl0gPSAxMV0gPSBcIk91dE9mUmFuZ2VcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gbm90IGltcGxlbWVudGVkIG9yIGRpc2FibGVkLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlVuaW1wbGVtZW50ZWRcIl0gPSAxMl0gPSBcIlVuaW1wbGVtZW50ZWRcIjtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBlcnJvciwgcmVzZXJ2ZWQgZm9yIFwic2VyaW91cyBlcnJvcnNcIi5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJJbnRlcm5hbFwiXSA9IDEzXSA9IFwiSW50ZXJuYWxcIjtcbiAgICAvKipcbiAgICAgKiBVbmF2YWlsYWJsZSwgY2xpZW50IHNob3VsZCBiYWNrIG9mZiBhbmQgcmV0cnkuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiVW5hdmFpbGFibGVcIl0gPSAxNF0gPSBcIlVuYXZhaWxhYmxlXCI7XG4gICAgLyoqXG4gICAgICogVW5yZWNvdmVyYWJsZSBkYXRhIGxvc3Mgb3IgY29ycnVwdGlvbi5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJEYXRhTG9zc1wiXSA9IDE1XSA9IFwiRGF0YUxvc3NcIjtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGlzbid0IGF1dGhlbnRpY2F0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiVW5hdXRoZW50aWNhdGVkXCJdID0gMTZdID0gXCJVbmF1dGhlbnRpY2F0ZWRcIjtcbn0pKENvZGUgfHwgKENvZGUgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/connect-error.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectError: () => (/* binding */ ConnectError)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/create.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/from-binary.js\");\n/* harmony import */ var _protocol_connect_code_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./protocol-connect/code-string.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * ConnectError captures four pieces of information: a Code, an error\n * message, an optional cause of the error, and an optional collection of\n * arbitrary Protobuf messages called  \"details\".\n *\n * Because developer tools typically show just the error message, we prefix\n * it with the status code, so that the most important information is always\n * visible immediately.\n *\n * Error details are wrapped with google.protobuf.Any on the wire, so that\n * a server or middleware can attach arbitrary data to an error. Use the\n * method findDetails() to retrieve the details.\n */\nclass ConnectError extends Error {\n    /**\n     * Create a new ConnectError.\n     * If no code is provided, code \"unknown\" is used.\n     * Outgoing details are only relevant for the server side - a service may\n     * raise an error with details, and it is up to the protocol implementation\n     * to encode and send the details along with error.\n     */\n    constructor(message, code = _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown, metadata, outgoingDetails, cause) {\n        super(createMessage(message, code));\n        this.name = \"ConnectError\";\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.rawMessage = message;\n        this.code = code;\n        this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});\n        this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];\n        this.cause = cause;\n    }\n    /**\n     * Convert any value - typically a caught error into a ConnectError,\n     * following these rules:\n     * - If the value is already a ConnectError, return it as is.\n     * - If the value is an AbortError from the fetch API, return the message\n     *   of the AbortError with code Canceled.\n     * - For other Errors, return the error message with code Unknown by default.\n     * - For other values, return the values String representation as a message,\n     *   with the code Unknown by default.\n     * The original value will be used for the \"cause\" property for the new\n     * ConnectError.\n     */\n    static from(reason, code = _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown) {\n        if (reason instanceof ConnectError) {\n            return reason;\n        }\n        if (reason instanceof Error) {\n            if (reason.name == \"AbortError\") {\n                // Fetch requests can only be canceled with an AbortController.\n                // We detect that condition by looking at the name of the raised\n                // error object, and translate to the appropriate status code.\n                return new ConnectError(reason.message, _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Canceled);\n            }\n            return new ConnectError(reason.message, code, undefined, undefined, reason);\n        }\n        return new ConnectError(String(reason), code, undefined, undefined, reason);\n    }\n    static [Symbol.hasInstance](v) {\n        if (!(v instanceof Error)) {\n            return false;\n        }\n        if (Object.getPrototypeOf(v) === ConnectError.prototype) {\n            return true;\n        }\n        return (v.name === \"ConnectError\" &&\n            \"code\" in v &&\n            typeof v.code === \"number\" &&\n            \"metadata\" in v &&\n            \"details\" in v &&\n            Array.isArray(v.details) &&\n            \"rawMessage\" in v &&\n            typeof v.rawMessage == \"string\" &&\n            \"cause\" in v);\n    }\n    findDetails(typeOrRegistry) {\n        const registry = typeOrRegistry.kind === \"message\"\n            ? {\n                getMessage: (typeName) => typeName === typeOrRegistry.typeName ? typeOrRegistry : undefined,\n            }\n            : typeOrRegistry;\n        const details = [];\n        for (const data of this.details) {\n            if (\"desc\" in data) {\n                if (registry.getMessage(data.desc.typeName)) {\n                    details.push((0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.create)(data.desc, data.value));\n                }\n                continue;\n            }\n            const desc = registry.getMessage(data.type);\n            if (desc) {\n                try {\n                    details.push((0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__.fromBinary)(desc, data.value));\n                }\n                catch (_) {\n                    // We silently give up if we are unable to parse the detail, because\n                    // that appears to be the least worst behavior.\n                    // It is very unlikely that a user surrounds a catch body handling the\n                    // error with another try-catch statement, and we do not want to\n                    // recommend doing so.\n                }\n            }\n        }\n        return details;\n    }\n}\n/**\n * Create an error message, prefixing the given code.\n */\nfunction createMessage(message, code) {\n    return message.length\n        ? `[${(0,_protocol_connect_code_string_js__WEBPACK_IMPORTED_MODULE_3__.codeToString)(code)}] ${message}`\n        : `[${(0,_protocol_connect_code_string_js__WEBPACK_IMPORTED_MODULE_3__.codeToString)(code)}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2Nvbm5lY3QtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQztBQUN1QjtBQUNTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBDQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMENBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOERBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4RUFBWSxPQUFPLElBQUksUUFBUTtBQUM3QyxjQUFjLDhFQUFZLE9BQU87QUFDakMiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vY29ubmVjdC1lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuL2NvZGUuanNcIjtcbmltcG9ydCB7IGNyZWF0ZSwgZnJvbUJpbmFyeSB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IGNvZGVUb1N0cmluZyB9IGZyb20gXCIuL3Byb3RvY29sLWNvbm5lY3QvY29kZS1zdHJpbmcuanNcIjtcbi8qKlxuICogQ29ubmVjdEVycm9yIGNhcHR1cmVzIGZvdXIgcGllY2VzIG9mIGluZm9ybWF0aW9uOiBhIENvZGUsIGFuIGVycm9yXG4gKiBtZXNzYWdlLCBhbiBvcHRpb25hbCBjYXVzZSBvZiB0aGUgZXJyb3IsIGFuZCBhbiBvcHRpb25hbCBjb2xsZWN0aW9uIG9mXG4gKiBhcmJpdHJhcnkgUHJvdG9idWYgbWVzc2FnZXMgY2FsbGVkICBcImRldGFpbHNcIi5cbiAqXG4gKiBCZWNhdXNlIGRldmVsb3BlciB0b29scyB0eXBpY2FsbHkgc2hvdyBqdXN0IHRoZSBlcnJvciBtZXNzYWdlLCB3ZSBwcmVmaXhcbiAqIGl0IHdpdGggdGhlIHN0YXR1cyBjb2RlLCBzbyB0aGF0IHRoZSBtb3N0IGltcG9ydGFudCBpbmZvcm1hdGlvbiBpcyBhbHdheXNcbiAqIHZpc2libGUgaW1tZWRpYXRlbHkuXG4gKlxuICogRXJyb3IgZGV0YWlscyBhcmUgd3JhcHBlZCB3aXRoIGdvb2dsZS5wcm90b2J1Zi5Bbnkgb24gdGhlIHdpcmUsIHNvIHRoYXRcbiAqIGEgc2VydmVyIG9yIG1pZGRsZXdhcmUgY2FuIGF0dGFjaCBhcmJpdHJhcnkgZGF0YSB0byBhbiBlcnJvci4gVXNlIHRoZVxuICogbWV0aG9kIGZpbmREZXRhaWxzKCkgdG8gcmV0cmlldmUgdGhlIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IENvbm5lY3RFcnJvci5cbiAgICAgKiBJZiBubyBjb2RlIGlzIHByb3ZpZGVkLCBjb2RlIFwidW5rbm93blwiIGlzIHVzZWQuXG4gICAgICogT3V0Z29pbmcgZGV0YWlscyBhcmUgb25seSByZWxldmFudCBmb3IgdGhlIHNlcnZlciBzaWRlIC0gYSBzZXJ2aWNlIG1heVxuICAgICAqIHJhaXNlIGFuIGVycm9yIHdpdGggZGV0YWlscywgYW5kIGl0IGlzIHVwIHRvIHRoZSBwcm90b2NvbCBpbXBsZW1lbnRhdGlvblxuICAgICAqIHRvIGVuY29kZSBhbmQgc2VuZCB0aGUgZGV0YWlscyBhbG9uZyB3aXRoIGVycm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUgPSBDb2RlLlVua25vd24sIG1ldGFkYXRhLCBvdXRnb2luZ0RldGFpbHMsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKGNyZWF0ZU1lc3NhZ2UobWVzc2FnZSwgY29kZSkpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkNvbm5lY3RFcnJvclwiO1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItMi5odG1sI2V4YW1wbGVcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5yYXdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBIZWFkZXJzKG1ldGFkYXRhICE9PSBudWxsICYmIG1ldGFkYXRhICE9PSB2b2lkIDAgPyBtZXRhZGF0YSA6IHt9KTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gb3V0Z29pbmdEZXRhaWxzICE9PSBudWxsICYmIG91dGdvaW5nRGV0YWlscyAhPT0gdm9pZCAwID8gb3V0Z29pbmdEZXRhaWxzIDogW107XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbnkgdmFsdWUgLSB0eXBpY2FsbHkgYSBjYXVnaHQgZXJyb3IgaW50byBhIENvbm5lY3RFcnJvcixcbiAgICAgKiBmb2xsb3dpbmcgdGhlc2UgcnVsZXM6XG4gICAgICogLSBJZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBhIENvbm5lY3RFcnJvciwgcmV0dXJuIGl0IGFzIGlzLlxuICAgICAqIC0gSWYgdGhlIHZhbHVlIGlzIGFuIEFib3J0RXJyb3IgZnJvbSB0aGUgZmV0Y2ggQVBJLCByZXR1cm4gdGhlIG1lc3NhZ2VcbiAgICAgKiAgIG9mIHRoZSBBYm9ydEVycm9yIHdpdGggY29kZSBDYW5jZWxlZC5cbiAgICAgKiAtIEZvciBvdGhlciBFcnJvcnMsIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZSB3aXRoIGNvZGUgVW5rbm93biBieSBkZWZhdWx0LlxuICAgICAqIC0gRm9yIG90aGVyIHZhbHVlcywgcmV0dXJuIHRoZSB2YWx1ZXMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIGEgbWVzc2FnZSxcbiAgICAgKiAgIHdpdGggdGhlIGNvZGUgVW5rbm93biBieSBkZWZhdWx0LlxuICAgICAqIFRoZSBvcmlnaW5hbCB2YWx1ZSB3aWxsIGJlIHVzZWQgZm9yIHRoZSBcImNhdXNlXCIgcHJvcGVydHkgZm9yIHRoZSBuZXdcbiAgICAgKiBDb25uZWN0RXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ocmVhc29uLCBjb2RlID0gQ29kZS5Vbmtub3duKSB7XG4gICAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBDb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBpZiAocmVhc29uLm5hbWUgPT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCByZXF1ZXN0cyBjYW4gb25seSBiZSBjYW5jZWxlZCB3aXRoIGFuIEFib3J0Q29udHJvbGxlci5cbiAgICAgICAgICAgICAgICAvLyBXZSBkZXRlY3QgdGhhdCBjb25kaXRpb24gYnkgbG9va2luZyBhdCB0aGUgbmFtZSBvZiB0aGUgcmFpc2VkXG4gICAgICAgICAgICAgICAgLy8gZXJyb3Igb2JqZWN0LCBhbmQgdHJhbnNsYXRlIHRvIHRoZSBhcHByb3ByaWF0ZSBzdGF0dXMgY29kZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbm5lY3RFcnJvcihyZWFzb24ubWVzc2FnZSwgQ29kZS5DYW5jZWxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbm5lY3RFcnJvcihyZWFzb24ubWVzc2FnZSwgY29kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0RXJyb3IoU3RyaW5nKHJlYXNvbiksIGNvZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCByZWFzb24pO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0odikge1xuICAgICAgICBpZiAoISh2IGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2KSA9PT0gQ29ubmVjdEVycm9yLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2Lm5hbWUgPT09IFwiQ29ubmVjdEVycm9yXCIgJiZcbiAgICAgICAgICAgIFwiY29kZVwiIGluIHYgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2LmNvZGUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIiBpbiB2ICYmXG4gICAgICAgICAgICBcImRldGFpbHNcIiBpbiB2ICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHYuZGV0YWlscykgJiZcbiAgICAgICAgICAgIFwicmF3TWVzc2FnZVwiIGluIHYgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2LnJhd01lc3NhZ2UgPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgXCJjYXVzZVwiIGluIHYpO1xuICAgIH1cbiAgICBmaW5kRGV0YWlscyh0eXBlT3JSZWdpc3RyeSkge1xuICAgICAgICBjb25zdCByZWdpc3RyeSA9IHR5cGVPclJlZ2lzdHJ5LmtpbmQgPT09IFwibWVzc2FnZVwiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBnZXRNZXNzYWdlOiAodHlwZU5hbWUpID0+IHR5cGVOYW1lID09PSB0eXBlT3JSZWdpc3RyeS50eXBlTmFtZSA/IHR5cGVPclJlZ2lzdHJ5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB0eXBlT3JSZWdpc3RyeTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdGhpcy5kZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoXCJkZXNjXCIgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeS5nZXRNZXNzYWdlKGRhdGEuZGVzYy50eXBlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGNyZWF0ZShkYXRhLmRlc2MsIGRhdGEudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVnaXN0cnkuZ2V0TWVzc2FnZShkYXRhLnR5cGUpO1xuICAgICAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goZnJvbUJpbmFyeShkZXNjLCBkYXRhLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNpbGVudGx5IGdpdmUgdXAgaWYgd2UgYXJlIHVuYWJsZSB0byBwYXJzZSB0aGUgZGV0YWlsLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYXBwZWFycyB0byBiZSB0aGUgbGVhc3Qgd29yc3QgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIHZlcnkgdW5saWtlbHkgdGhhdCBhIHVzZXIgc3Vycm91bmRzIGEgY2F0Y2ggYm9keSBoYW5kbGluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3Igd2l0aCBhbm90aGVyIHRyeS1jYXRjaCBzdGF0ZW1lbnQsIGFuZCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbW1lbmQgZG9pbmcgc28uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIG1lc3NhZ2UsIHByZWZpeGluZyB0aGUgZ2l2ZW4gY29kZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZShtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoXG4gICAgICAgID8gYFske2NvZGVUb1N0cmluZyhjb2RlKX1dICR7bWVzc2FnZX1gXG4gICAgICAgIDogYFske2NvZGVUb1N0cmluZyhjb2RlKX1dYDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/context-values.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/context-values.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContextKey: () => (/* binding */ createContextKey),\n/* harmony export */   createContextValues: () => (/* binding */ createContextValues)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * createContextValues creates a new ContextValues.\n */\nfunction createContextValues() {\n    return {\n        get(key) {\n            return key.id in this ? this[key.id] : key.defaultValue;\n        },\n        set(key, value) {\n            this[key.id] = value;\n            return this;\n        },\n        delete(key) {\n            delete this[key.id];\n            return this;\n        },\n    };\n}\n/**\n * createContextKey creates a new ContextKey.\n */\nfunction createContextKey(defaultValue, options) {\n    return { id: Symbol(options === null || options === void 0 ? void 0 : options.description), defaultValue };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2NvbnRleHQtdmFsdWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb250ZXh0LXZhbHVlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBjcmVhdGVDb250ZXh0VmFsdWVzIGNyZWF0ZXMgYSBuZXcgQ29udGV4dFZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS5pZCBpbiB0aGlzID8gdGhpc1trZXkuaWRdIDoga2V5LmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNba2V5LmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleS5pZF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBjcmVhdGVDb250ZXh0S2V5IGNyZWF0ZXMgYSBuZXcgQ29udGV4dEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRLZXkoZGVmYXVsdFZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHsgaWQ6IFN5bWJvbChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzY3JpcHRpb24pLCBkZWZhdWx0VmFsdWUgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/context-values.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/http-headers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendHeaders: () => (/* binding */ appendHeaders),\n/* harmony export */   decodeBinaryHeader: () => (/* binding */ decodeBinaryHeader),\n/* harmony export */   encodeBinaryHeader: () => (/* binding */ encodeBinaryHeader)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/to-binary.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/from-binary.js\");\n/* harmony import */ var _bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bufbuild/protobuf/wire */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\nfunction encodeBinaryHeader(value, desc) {\n    let bytes;\n    if (desc !== undefined) {\n        bytes = (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__.toBinary)(desc, value);\n    }\n    else if (typeof value == \"string\") {\n        bytes = new TextEncoder().encode(value);\n    }\n    else {\n        bytes =\n            value instanceof Uint8Array\n                ? value\n                : new Uint8Array(value);\n    }\n    return (0,_bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_1__.base64Encode)(bytes, \"std_raw\");\n}\nfunction decodeBinaryHeader(value, desc, options) {\n    try {\n        const bytes = (0,_bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(value);\n        if (desc) {\n            return (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__.fromBinary)(desc, bytes, options);\n        }\n        return bytes;\n    }\n    catch (e) {\n        throw _connect_error_js__WEBPACK_IMPORTED_MODULE_3__.ConnectError.from(e, _code_js__WEBPACK_IMPORTED_MODULE_4__.Code.DataLoss);\n    }\n}\n/**\n * Merge two or more Headers objects by appending all fields from\n * all inputs to a new Headers object.\n */\nfunction appendHeaders(...headers) {\n    const h = new Headers();\n    for (const e of headers) {\n        e.forEach((value, key) => {\n            h.append(key, value);\n        });\n    }\n    return h;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2h0dHAtaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEO0FBQ1c7QUFDbkI7QUFDakI7QUFDMUI7QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxRUFBWTtBQUN2QjtBQUNPO0FBQ1A7QUFDQSxzQkFBc0IscUVBQVk7QUFDbEM7QUFDQSxtQkFBbUIsOERBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJEQUFZLFNBQVMsMENBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vaHR0cC1oZWFkZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBmcm9tQmluYXJ5LCB0b0JpbmFyeSB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IGJhc2U2NEVuY29kZSwgYmFzZTY0RGVjb2RlIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1Zi93aXJlXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4vY29kZS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJpbmFyeUhlYWRlcih2YWx1ZSwgZGVzYykge1xuICAgIGxldCBieXRlcztcbiAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ5dGVzID0gdG9CaW5hcnkoZGVzYywgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBieXRlcyA9XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoYnl0ZXMsIFwic3RkX3Jhd1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCaW5hcnlIZWFkZXIodmFsdWUsIGRlc2MsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGJhc2U2NERlY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpbmFyeShkZXNjLCBieXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBDb25uZWN0RXJyb3IuZnJvbShlLCBDb2RlLkRhdGFMb3NzKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIHR3byBvciBtb3JlIEhlYWRlcnMgb2JqZWN0cyBieSBhcHBlbmRpbmcgYWxsIGZpZWxkcyBmcm9tXG4gKiBhbGwgaW5wdXRzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kSGVhZGVycyguLi5oZWFkZXJzKSB7XG4gICAgY29uc3QgaCA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBlIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgZS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBoLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/interceptor.js":
/*!******************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/interceptor.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyInterceptors: () => (/* binding */ applyInterceptors)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * applyInterceptors takes the given UnaryFn or ServerStreamingFn, and wraps\n * it with each of the given interceptors, returning a new UnaryFn or\n * ServerStreamingFn.\n */\nfunction applyInterceptors(next, interceptors) {\n    var _a;\n    return ((_a = interceptors === null || interceptors === void 0 ? void 0 : interceptors.concat().reverse().reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    (n, i) => i(n), next)) !== null && _a !== void 0 ? _a : next);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2ludGVyY2VwdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vaW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogYXBwbHlJbnRlcmNlcHRvcnMgdGFrZXMgdGhlIGdpdmVuIFVuYXJ5Rm4gb3IgU2VydmVyU3RyZWFtaW5nRm4sIGFuZCB3cmFwc1xuICogaXQgd2l0aCBlYWNoIG9mIHRoZSBnaXZlbiBpbnRlcmNlcHRvcnMsIHJldHVybmluZyBhIG5ldyBVbmFyeUZuIG9yXG4gKiBTZXJ2ZXJTdHJlYW1pbmdGbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5SW50ZXJjZXB0b3JzKG5leHQsIGludGVyY2VwdG9ycykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IGludGVyY2VwdG9ycyA9PT0gbnVsbCB8fCBpbnRlcmNlcHRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdG9ycy5jb25jYXQoKS5yZXZlcnNlKCkucmVkdWNlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgKG4sIGkpID0+IGkobiksIG5leHQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXh0KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/interceptor.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/promise-client.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/promise-client.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBiDiStreamingFn: () => (/* binding */ createBiDiStreamingFn),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createClientStreamingFn: () => (/* binding */ createClientStreamingFn),\n/* harmony export */   createServerStreamingFn: () => (/* binding */ createServerStreamingFn),\n/* harmony export */   createUnaryFn: () => (/* binding */ createUnaryFn)\n/* harmony export */ });\n/* harmony import */ var _any_client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./any-client.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/any-client.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _protocol_async_iterable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocol/async-iterable.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncDelegator = (undefined && undefined.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n/**\n * Create a Client for the given service, invoking RPCs through the\n * given transport.\n */\nfunction createClient(service, transport) {\n    return (0,_any_client_js__WEBPACK_IMPORTED_MODULE_0__.makeAnyClient)(service, (method) => {\n        switch (method.methodKind) {\n            case \"unary\":\n                return createUnaryFn(transport, method);\n            case \"server_streaming\":\n                return createServerStreamingFn(transport, method);\n            case \"client_streaming\":\n                return createClientStreamingFn(transport, method);\n            case \"bidi_streaming\":\n                return createBiDiStreamingFn(transport, method);\n            default:\n                return null;\n        }\n    });\n}\nfunction createUnaryFn(transport, method) {\n    return async function (input, options) {\n        var _a, _b;\n        const response = await transport.unary(method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, input, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n        (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        return response.message;\n    };\n}\nfunction createServerStreamingFn(transport, method) {\n    return function (input, options) {\n        return handleStreamResponse(transport.stream(method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, (0,_protocol_async_iterable_js__WEBPACK_IMPORTED_MODULE_1__.createAsyncIterable)([input]), options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction createClientStreamingFn(transport, method) {\n    return async function (request, options) {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        const response = await transport.stream(method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_d = options === null || options === void 0 ? void 0 : options.onHeader) === null || _d === void 0 ? void 0 : _d.call(options, response.header);\n        let singleMessage;\n        let count = 0;\n        try {\n            for (var _f = true, _g = __asyncValues(response.message), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                _c = _h.value;\n                _f = false;\n                const message = _c;\n                singleMessage = message;\n                count++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!singleMessage) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(\"protocol error: missing response message\", _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.Unimplemented);\n        }\n        if (count > 1) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(\"protocol error: received extra messages for client streaming method\", _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.Unimplemented);\n        }\n        (_e = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _e === void 0 ? void 0 : _e.call(options, response.trailer);\n        return singleMessage;\n    };\n}\nfunction createBiDiStreamingFn(transport, method) {\n    return function (request, options) {\n        return handleStreamResponse(transport.stream(method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction handleStreamResponse(stream, options) {\n    const it = (function () {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, _b;\n            const response = yield __await(stream);\n            (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n            yield __await(yield* __asyncDelegator(__asyncValues(response.message)));\n            (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        });\n    })()[Symbol.asyncIterator]();\n    // Create a new iterable to omit throw/return.\n    return {\n        [Symbol.asyncIterator]: () => ({\n            next: () => it.next(),\n        }),\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb21pc2UtY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQUksSUFBSSxTQUFJO0FBQ2pDO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUksNEJBQTRCO0FBQ3ZELHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQix1Q0FBdUMsa0JBQWtCO0FBQ3BJO0FBQ0Esd0JBQXdCLFNBQUksSUFBSSxTQUFJO0FBQ3BDO0FBQ0E7QUFDQSwwTUFBME0sY0FBYztBQUN4Tiw4QkFBOEIsc0JBQXNCO0FBQ3BELDBCQUEwQixZQUFZLHNCQUFzQixxQ0FBcUMsMkNBQTJDLE1BQU07QUFDbEosNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ2dEO0FBQ0U7QUFDakI7QUFDa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsNkRBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVRQUF1USxnRkFBbUI7QUFDMVI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSx5Q0FBeUM7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFZLDZDQUE2QywwQ0FBSTtBQUNuRjtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFZLHdFQUF3RSwwQ0FBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvbWlzZS1jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jRGVsZWdhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jRGVsZWdhdG9yKSB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBpLCBwO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn07XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbmltcG9ydCB7IG1ha2VBbnlDbGllbnQgfSBmcm9tIFwiLi9hbnktY2xpZW50LmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNJdGVyYWJsZSB9IGZyb20gXCIuL3Byb3RvY29sL2FzeW5jLWl0ZXJhYmxlLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIENsaWVudCBmb3IgdGhlIGdpdmVuIHNlcnZpY2UsIGludm9raW5nIFJQQ3MgdGhyb3VnaCB0aGVcbiAqIGdpdmVuIHRyYW5zcG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudChzZXJ2aWNlLCB0cmFuc3BvcnQpIHtcbiAgICByZXR1cm4gbWFrZUFueUNsaWVudChzZXJ2aWNlLCAobWV0aG9kKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kLm1ldGhvZEtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmFyeVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVbmFyeUZuKHRyYW5zcG9ydCwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2UgXCJzZXJ2ZXJfc3RyZWFtaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlclN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2UgXCJjbGllbnRfc3RyZWFtaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudFN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNhc2UgXCJiaWRpX3N0cmVhbWluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCaURpU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBtZXRob2QpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuYXJ5Rm4odHJhbnNwb3J0LCBtZXRob2QpIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdHJhbnNwb3J0LnVuYXJ5KG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIGlucHV0LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dFZhbHVlcyk7XG4gICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgcmVzcG9uc2UuaGVhZGVyKTtcbiAgICAgICAgKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uVHJhaWxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgcmVzcG9uc2UudHJhaWxlcik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5tZXNzYWdlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJlYW1SZXNwb25zZSh0cmFuc3BvcnQuc3RyZWFtKG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIGNyZWF0ZUFzeW5jSXRlcmFibGUoW2lucHV0XSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnRTdHJlYW1pbmdGbih0cmFuc3BvcnQsIG1ldGhvZCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydC5zdHJlYW0obWV0aG9kLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dE1zLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycywgcmVxdWVzdCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHRWYWx1ZXMpO1xuICAgICAgICAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IZWFkZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLmhlYWRlcik7XG4gICAgICAgIGxldCBzaW5nbGVNZXNzYWdlO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UubWVzc2FnZSksIF9oOyBfaCA9IGF3YWl0IF9nLm5leHQoKSwgX2EgPSBfaC5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gX2M7XG4gICAgICAgICAgICAgICAgc2luZ2xlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaW5nbGVNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKFwicHJvdG9jb2wgZXJyb3I6IG1pc3NpbmcgcmVzcG9uc2UgbWVzc2FnZVwiLCBDb2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoXCJwcm90b2NvbCBlcnJvcjogcmVjZWl2ZWQgZXh0cmEgbWVzc2FnZXMgZm9yIGNsaWVudCBzdHJlYW1pbmcgbWV0aG9kXCIsIENvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uVHJhaWxlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwob3B0aW9ucywgcmVzcG9uc2UudHJhaWxlcik7XG4gICAgICAgIHJldHVybiBzaW5nbGVNZXNzYWdlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmlEaVN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJlYW1SZXNwb25zZSh0cmFuc3BvcnQuc3RyZWFtKG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIHJlcXVlc3QsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVN0cmVhbVJlc3BvbnNlKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChzdHJlYW0pO1xuICAgICAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uSGVhZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCByZXNwb25zZS5oZWFkZXIpO1xuICAgICAgICAgICAgeWllbGQgX19hd2FpdCh5aWVsZCogX19hc3luY0RlbGVnYXRvcihfX2FzeW5jVmFsdWVzKHJlc3BvbnNlLm1lc3NhZ2UpKSk7XG4gICAgICAgICAgICAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25UcmFpbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCByZXNwb25zZS50cmFpbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfSkoKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAvLyBDcmVhdGUgYSBuZXcgaXRlcmFibGUgdG8gb21pdCB0aHJvdy9yZXR1cm4uXG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gKHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IGl0Lm5leHQoKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/promise-client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeFromString: () => (/* binding */ codeFromString),\n/* harmony export */   codeToString: () => (/* binding */ codeToString)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * codeToString returns the string representation of a Code.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeToString(value) {\n    const name = _code_js__WEBPACK_IMPORTED_MODULE_0__.Code[value];\n    if (typeof name != \"string\") {\n        return value.toString();\n    }\n    return (name[0].toLowerCase() +\n        name.substring(1).replace(/[A-Z]/g, (c) => \"_\" + c.toLowerCase()));\n}\nlet stringToCode;\n/**\n * codeFromString parses the string representation of a Code in snake_case.\n * For example, the string \"permission_denied\" parses into Code.PermissionDenied.\n *\n * If the given string cannot be parsed, the function returns undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeFromString(value) {\n    if (!stringToCode) {\n        stringToCode = {};\n        for (const value of Object.values(_code_js__WEBPACK_IMPORTED_MODULE_0__.Code)) {\n            if (typeof value == \"string\") {\n                continue;\n            }\n            stringToCode[codeToString(value)] = value;\n        }\n    }\n    return stringToCode[value];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvY29kZS1zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLDBDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBDQUEwQywwQ0FBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvY29kZS1zdHJpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuLyoqXG4gKiBjb2RlVG9TdHJpbmcgcmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29kZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVUb1N0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IG5hbWUgPSBDb2RlW3ZhbHVlXTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIChuYW1lWzBdLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICBuYW1lLnN1YnN0cmluZygxKS5yZXBsYWNlKC9bQS1aXS9nLCAoYykgPT4gXCJfXCIgKyBjLnRvTG93ZXJDYXNlKCkpKTtcbn1cbmxldCBzdHJpbmdUb0NvZGU7XG4vKipcbiAqIGNvZGVGcm9tU3RyaW5nIHBhcnNlcyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29kZSBpbiBzbmFrZV9jYXNlLlxuICogRm9yIGV4YW1wbGUsIHRoZSBzdHJpbmcgXCJwZXJtaXNzaW9uX2RlbmllZFwiIHBhcnNlcyBpbnRvIENvZGUuUGVybWlzc2lvbkRlbmllZC5cbiAqXG4gKiBJZiB0aGUgZ2l2ZW4gc3RyaW5nIGNhbm5vdCBiZSBwYXJzZWQsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVGcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCFzdHJpbmdUb0NvZGUpIHtcbiAgICAgICAgc3RyaW5nVG9Db2RlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhDb2RlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmdUb0NvZGVbY29kZVRvU3RyaW5nKHZhbHVlKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVG9Db2RlW3ZhbHVlXTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   contentTypeRegExp: () => (/* binding */ contentTypeRegExp),\n/* harmony export */   contentTypeStreamJson: () => (/* binding */ contentTypeStreamJson),\n/* harmony export */   contentTypeStreamProto: () => (/* binding */ contentTypeStreamProto),\n/* harmony export */   contentTypeStreamRegExp: () => (/* binding */ contentTypeStreamRegExp),\n/* harmony export */   contentTypeUnaryJson: () => (/* binding */ contentTypeUnaryJson),\n/* harmony export */   contentTypeUnaryProto: () => (/* binding */ contentTypeUnaryProto),\n/* harmony export */   contentTypeUnaryRegExp: () => (/* binding */ contentTypeUnaryRegExp),\n/* harmony export */   parseContentType: () => (/* binding */ parseContentType),\n/* harmony export */   parseEncodingQuery: () => (/* binding */ parseEncodingQuery)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid Connect Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeRegExp = /^application\\/(connect\\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i;\n/**\n * Regular Expression that matches a Connect unary Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeUnaryRegExp = /^application\\/(?:json(?:; ?charset=utf-?8)?|proto)$/i;\n/**\n * Regular Expression that matches a Connect streaming Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeStreamRegExp = /^application\\/connect\\+?(?:json(?:; ?charset=utf-?8)?|proto)$/i;\nconst contentTypeUnaryProto = \"application/proto\";\nconst contentTypeUnaryJson = \"application/json\";\nconst contentTypeStreamProto = \"application/connect+proto\";\nconst contentTypeStreamJson = \"application/connect+json\";\nconst encodingProto = \"proto\";\nconst encodingJson = \"json\";\n/**\n * Parse a Connect Content-Type header.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const stream = !!match[1];\n    const binary = !!match[3];\n    return { stream, binary };\n}\n/**\n * Parse a Connect Get encoding query parameter.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction parseEncodingQuery(encoding) {\n    switch (encoding) {\n        case encodingProto:\n            return { stream: false, binary: true };\n        case encodingJson:\n            return { stream: false, binary: false };\n        default:\n            return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvY29udGVudC10eXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1FQUFtRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMERBQTBEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2NvbnRlbnQtdHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZWd1bGFyIEV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFueSB2YWxpZCBDb25uZWN0IENvbnRlbnQtVHlwZSBoZWFkZXIgdmFsdWUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVJlZ0V4cCA9IC9eYXBwbGljYXRpb25cXC8oY29ubmVjdFxcKyk/KD86KGpzb24pKD86OyA/Y2hhcnNldD11dGYtPzgpP3wocHJvdG8pKSQvaTtcbi8qKlxuICogUmVndWxhciBFeHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIENvbm5lY3QgdW5hcnkgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlVW5hcnlSZWdFeHAgPSAvXmFwcGxpY2F0aW9uXFwvKD86anNvbig/OjsgP2NoYXJzZXQ9dXRmLT84KT98cHJvdG8pJC9pO1xuLyoqXG4gKiBSZWd1bGFyIEV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgQ29ubmVjdCBzdHJlYW1pbmcgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlU3RyZWFtUmVnRXhwID0gL15hcHBsaWNhdGlvblxcL2Nvbm5lY3RcXCs/KD86anNvbig/OjsgP2NoYXJzZXQ9dXRmLT84KT98cHJvdG8pJC9pO1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlVW5hcnlQcm90byA9IFwiYXBwbGljYXRpb24vcHJvdG9cIjtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVVuYXJ5SnNvbiA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlU3RyZWFtUHJvdG8gPSBcImFwcGxpY2F0aW9uL2Nvbm5lY3QrcHJvdG9cIjtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVN0cmVhbUpzb24gPSBcImFwcGxpY2F0aW9uL2Nvbm5lY3QranNvblwiO1xuY29uc3QgZW5jb2RpbmdQcm90byA9IFwicHJvdG9cIjtcbmNvbnN0IGVuY29kaW5nSnNvbiA9IFwianNvblwiO1xuLyoqXG4gKiBQYXJzZSBhIENvbm5lY3QgQ29udGVudC1UeXBlIGhlYWRlci5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFR5cGUoY29udGVudFR5cGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IGNvbnRlbnRUeXBlID09PSBudWxsIHx8IGNvbnRlbnRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50VHlwZS5tYXRjaChjb250ZW50VHlwZVJlZ0V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSAhIW1hdGNoWzFdO1xuICAgIGNvbnN0IGJpbmFyeSA9ICEhbWF0Y2hbM107XG4gICAgcmV0dXJuIHsgc3RyZWFtLCBiaW5hcnkgfTtcbn1cbi8qKlxuICogUGFyc2UgYSBDb25uZWN0IEdldCBlbmNvZGluZyBxdWVyeSBwYXJhbWV0ZXIuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVuY29kaW5nUXVlcnkoZW5jb2RpbmcpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgZW5jb2RpbmdQcm90bzpcbiAgICAgICAgICAgIHJldHVybiB7IHN0cmVhbTogZmFsc2UsIGJpbmFyeTogdHJ1ZSB9O1xuICAgICAgICBjYXNlIGVuY29kaW5nSnNvbjpcbiAgICAgICAgICAgIHJldHVybiB7IHN0cmVhbTogZmFsc2UsIGJpbmFyeTogZmFsc2UgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEndStreamSerialization: () => (/* binding */ createEndStreamSerialization),\n/* harmony export */   endStreamFlag: () => (/* binding */ endStreamFlag),\n/* harmony export */   endStreamFromJson: () => (/* binding */ endStreamFromJson),\n/* harmony export */   endStreamToJson: () => (/* binding */ endStreamToJson)\n/* harmony export */ });\n/* harmony import */ var _error_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./error-json.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js\");\n/* harmony import */ var _http_headers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../http-headers.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * endStreamFlag indicates that the data in a EnvelopedMessage\n * is a EndStreamResponse of the Connect protocol.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst endStreamFlag = 0b00000010;\n/**\n * Parse an EndStreamResponse of the Connect protocol.\n * Throws a ConnectError on malformed input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction endStreamFromJson(data) {\n    const parseErr = new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"invalid end stream\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Unknown);\n    let jsonValue;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        jsonValue = JSON.parse(typeof data == \"string\" ? data : new TextDecoder().decode(data));\n    }\n    catch (e) {\n        throw parseErr;\n    }\n    if (typeof jsonValue != \"object\" ||\n        jsonValue == null ||\n        Array.isArray(jsonValue)) {\n        throw parseErr;\n    }\n    const metadata = new Headers();\n    if (\"metadata\" in jsonValue) {\n        if (typeof jsonValue.metadata != \"object\" ||\n            jsonValue.metadata == null ||\n            Array.isArray(jsonValue.metadata)) {\n            throw parseErr;\n        }\n        for (const [key, values] of Object.entries(jsonValue.metadata)) {\n            if (!Array.isArray(values) ||\n                values.some((value) => typeof value != \"string\")) {\n                throw parseErr;\n            }\n            for (const value of values) {\n                metadata.append(key, value);\n            }\n        }\n    }\n    const error = \"error\" in jsonValue && jsonValue.error != null\n        ? (0,_error_json_js__WEBPACK_IMPORTED_MODULE_2__.errorFromJson)(jsonValue.error, metadata, parseErr)\n        : undefined;\n    return { metadata, error };\n}\n/**\n * Serialize the given EndStreamResponse to JSON.\n *\n * The JSON serialization options are required to produce the optional\n * human-readable representation of error details if the detail uses\n * google.protobuf.Any.\n *\n * See https://connectrpc.com/docs/protocol#error-end-stream\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction endStreamToJson(metadata, error, jsonWriteOptions) {\n    const es = {};\n    if (error !== undefined) {\n        es.error = (0,_error_json_js__WEBPACK_IMPORTED_MODULE_2__.errorToJson)(error, jsonWriteOptions);\n        metadata = (0,_http_headers_js__WEBPACK_IMPORTED_MODULE_3__.appendHeaders)(metadata, error.metadata);\n    }\n    let hasMetadata = false;\n    const md = {};\n    metadata.forEach((value, key) => {\n        hasMetadata = true;\n        md[key] = [value];\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (hasMetadata) {\n        es.metadata = md;\n    }\n    return es;\n}\n/**\n * Create a Serialization object that serializes a Connect EndStreamResponse.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createEndStreamSerialization(options) {\n    const textEncoder = new TextEncoder();\n    return {\n        serialize(data) {\n            try {\n                const jsonObject = endStreamToJson(data.metadata, data.error, options);\n                const jsonString = JSON.stringify(jsonObject);\n                return textEncoder.encode(jsonString);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`failed to serialize EndStreamResponse: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n            }\n        },\n        parse(data) {\n            try {\n                return endStreamFromJson(data);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`failed to parse EndStreamResponse: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n            }\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZW5kLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1Y7QUFDQTtBQUNqQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUJBQXlCLDJEQUFZLHVCQUF1QiwwQ0FBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkRBQWE7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLDJEQUFXO0FBQzlCLG1CQUFtQiwrREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVksMkNBQTJDLEVBQUUsR0FBRywwQ0FBSTtBQUMxRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVksdUNBQXVDLEVBQUUsR0FBRywwQ0FBSTtBQUN0RjtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZW5kLXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgZXJyb3JGcm9tSnNvbiwgZXJyb3JUb0pzb24gfSBmcm9tIFwiLi9lcnJvci1qc29uLmpzXCI7XG5pbXBvcnQgeyBhcHBlbmRIZWFkZXJzIH0gZnJvbSBcIi4uL2h0dHAtaGVhZGVycy5qc1wiO1xuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuLyoqXG4gKiBlbmRTdHJlYW1GbGFnIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGluIGEgRW52ZWxvcGVkTWVzc2FnZVxuICogaXMgYSBFbmRTdHJlYW1SZXNwb25zZSBvZiB0aGUgQ29ubmVjdCBwcm90b2NvbC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuZFN0cmVhbUZsYWcgPSAwYjAwMDAwMDEwO1xuLyoqXG4gKiBQYXJzZSBhbiBFbmRTdHJlYW1SZXNwb25zZSBvZiB0aGUgQ29ubmVjdCBwcm90b2NvbC5cbiAqIFRocm93cyBhIENvbm5lY3RFcnJvciBvbiBtYWxmb3JtZWQgaW5wdXQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRTdHJlYW1Gcm9tSnNvbihkYXRhKSB7XG4gICAgY29uc3QgcGFyc2VFcnIgPSBuZXcgQ29ubmVjdEVycm9yKFwiaW52YWxpZCBlbmQgc3RyZWFtXCIsIENvZGUuVW5rbm93bik7XG4gICAgbGV0IGpzb25WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBwYXJzZUVycjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBqc29uVmFsdWUgPT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgcGFyc2VFcnI7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAoXCJtZXRhZGF0YVwiIGluIGpzb25WYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb25WYWx1ZS5tZXRhZGF0YSAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICBqc29uVmFsdWUubWV0YWRhdGEgPT0gbnVsbCB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShqc29uVmFsdWUubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXJzZUVycjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoanNvblZhbHVlLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZXMuc29tZSgodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHBhcnNlRXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBcImVycm9yXCIgaW4ganNvblZhbHVlICYmIGpzb25WYWx1ZS5lcnJvciAhPSBudWxsXG4gICAgICAgID8gZXJyb3JGcm9tSnNvbihqc29uVmFsdWUuZXJyb3IsIG1ldGFkYXRhLCBwYXJzZUVycilcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgbWV0YWRhdGEsIGVycm9yIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gRW5kU3RyZWFtUmVzcG9uc2UgdG8gSlNPTi5cbiAqXG4gKiBUaGUgSlNPTiBzZXJpYWxpemF0aW9uIG9wdGlvbnMgYXJlIHJlcXVpcmVkIHRvIHByb2R1Y2UgdGhlIG9wdGlvbmFsXG4gKiBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBlcnJvciBkZXRhaWxzIGlmIHRoZSBkZXRhaWwgdXNlc1xuICogZ29vZ2xlLnByb3RvYnVmLkFueS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9jb25uZWN0cnBjLmNvbS9kb2NzL3Byb3RvY29sI2Vycm9yLWVuZC1zdHJlYW1cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZFN0cmVhbVRvSnNvbihtZXRhZGF0YSwgZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpIHtcbiAgICBjb25zdCBlcyA9IHt9O1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVzLmVycm9yID0gZXJyb3JUb0pzb24oZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpO1xuICAgICAgICBtZXRhZGF0YSA9IGFwcGVuZEhlYWRlcnMobWV0YWRhdGEsIGVycm9yLm1ldGFkYXRhKTtcbiAgICB9XG4gICAgbGV0IGhhc01ldGFkYXRhID0gZmFsc2U7XG4gICAgY29uc3QgbWQgPSB7fTtcbiAgICBtZXRhZGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhhc01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgbWRba2V5XSA9IFt2YWx1ZV07XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoaGFzTWV0YWRhdGEpIHtcbiAgICAgICAgZXMubWV0YWRhdGEgPSBtZDtcbiAgICB9XG4gICAgcmV0dXJuIGVzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBTZXJpYWxpemF0aW9uIG9iamVjdCB0aGF0IHNlcmlhbGl6ZXMgYSBDb25uZWN0IEVuZFN0cmVhbVJlc3BvbnNlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW5kU3RyZWFtU2VyaWFsaXphdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uT2JqZWN0ID0gZW5kU3RyZWFtVG9Kc29uKGRhdGEubWV0YWRhdGEsIGRhdGEuZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShqc29uT2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGpzb25TdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYGZhaWxlZCB0byBzZXJpYWxpemUgRW5kU3RyZWFtUmVzcG9uc2U6ICR7bX1gLCBDb2RlLkludGVybmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2UoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kU3RyZWFtRnJvbUpzb24oZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgZmFpbGVkIHRvIHBhcnNlIEVuZFN0cmVhbVJlc3BvbnNlOiAke219YCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   errorFromJson: () => (/* binding */ errorFromJson),\n/* harmony export */   errorFromJsonBytes: () => (/* binding */ errorFromJsonBytes),\n/* harmony export */   errorToJson: () => (/* binding */ errorToJson),\n/* harmony export */   errorToJsonBytes: () => (/* binding */ errorToJsonBytes)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bufbuild/protobuf/wire */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/create.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/to-binary.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/to-json.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-string.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\n\n/**\n * Parse a Connect error from a JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorFromJson(jsonValue, metadata, fallback) {\n    var _a;\n    if (metadata) {\n        new Headers(metadata).forEach((value, key) => fallback.metadata.append(key, value));\n    }\n    if (typeof jsonValue !== \"object\" ||\n        jsonValue == null ||\n        Array.isArray(jsonValue)) {\n        throw fallback;\n    }\n    let code = fallback.code;\n    if (\"code\" in jsonValue && typeof jsonValue.code === \"string\") {\n        code = (_a = (0,_code_string_js__WEBPACK_IMPORTED_MODULE_0__.codeFromString)(jsonValue.code)) !== null && _a !== void 0 ? _a : code;\n    }\n    const message = jsonValue.message;\n    if (message != null && typeof message !== \"string\") {\n        throw fallback;\n    }\n    const error = new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(message !== null && message !== void 0 ? message : \"\", code, metadata);\n    if (\"details\" in jsonValue && Array.isArray(jsonValue.details)) {\n        for (const detail of jsonValue.details) {\n            if (detail === null ||\n                typeof detail != \"object\" ||\n                Array.isArray(detail) ||\n                typeof detail.type != \"string\" ||\n                typeof detail.value != \"string\") {\n                throw fallback;\n            }\n            try {\n                error.details.push({\n                    type: detail.type,\n                    value: (0,_bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_2__.base64Decode)(detail.value),\n                    debug: detail.debug,\n                });\n            }\n            catch (e) {\n                throw fallback;\n            }\n        }\n    }\n    return error;\n}\n/**\n * Parse a Connect error from a serialized JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorFromJsonBytes(bytes, metadata, fallback) {\n    let jsonValue;\n    try {\n        jsonValue = JSON.parse(new TextDecoder().decode(bytes));\n    }\n    catch (e) {\n        throw fallback;\n    }\n    return errorFromJson(jsonValue, metadata, fallback);\n}\n/**\n * Serialize the given error to JSON.\n *\n * The JSON serialization options are required to produce the optional\n * human-readable representation in the \"debug\" key if the detail uses\n * google.protobuf.Any. If serialization of the \"debug\" value fails, it\n * is silently disregarded.\n *\n * See https://connectrpc.com/docs/protocol#error-end-stream\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorToJson(error, jsonWriteOptions) {\n    const o = {\n        code: (0,_code_string_js__WEBPACK_IMPORTED_MODULE_0__.codeToString)(error.code),\n    };\n    if (error.rawMessage.length > 0) {\n        o.message = error.rawMessage;\n    }\n    if (error.details.length > 0) {\n        o.details = error.details\n            .map((detail) => {\n            if (\"desc\" in detail) {\n                const msg = (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_3__.create)(detail.desc, detail.value);\n                const i = {\n                    type: detail.desc.typeName,\n                    value: (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__.toBinary)(detail.desc, msg),\n                };\n                try {\n                    i.debug = (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_5__.toJson)(detail.desc, msg, jsonWriteOptions);\n                }\n                catch (e) {\n                    // We deliberately ignore errors that may occur when serializing\n                    // a message to JSON (the message contains an Any).\n                    // The rationale is that we are only trying to provide optional\n                    // debug information.\n                }\n                return i;\n            }\n            return detail;\n        })\n            .map((_a) => {\n            var { value } = _a, rest = __rest(_a, [\"value\"]);\n            return (Object.assign(Object.assign({}, rest), { value: (0,_bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(value, \"std_raw\") }));\n        });\n    }\n    return o;\n}\n/**\n * Serialize the given error to JSON. This calls errorToJson(), but stringifies\n * the result, and converts it into a UInt8Array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorToJsonBytes(error, jsonWriteOptions) {\n    const textEncoder = new TextEncoder();\n    try {\n        const jsonObject = errorToJson(error, jsonWriteOptions);\n        const jsonString = JSON.stringify(jsonObject);\n        return textEncoder.encode(jsonString);\n    }\n    catch (e) {\n        const m = e instanceof Error ? e.message : String(e);\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`failed to serialize Connect Error: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_6__.Code.Internal);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZXJyb3ItanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUU7QUFDUDtBQUM1QjtBQUNpQjtBQUNhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxRUFBWTtBQUN2QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsY0FBYyw2REFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFNO0FBQ2xDO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVE7QUFDbkM7QUFDQTtBQUNBLDhCQUE4QiwwREFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGtEQUFrRCxXQUFXLE9BQU8scUVBQVksb0JBQW9CO0FBQ3BHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQVksdUNBQXVDLEVBQUUsR0FBRywwQ0FBSTtBQUM5RTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZXJyb3ItanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL3dpcmVcIjtcbmltcG9ydCB7IGNyZWF0ZSwgdG9CaW5hcnksIHRvSnNvbiB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IGNvZGVGcm9tU3RyaW5nLCBjb2RlVG9TdHJpbmcgfSBmcm9tIFwiLi9jb2RlLXN0cmluZy5qc1wiO1xuLyoqXG4gKiBQYXJzZSBhIENvbm5lY3QgZXJyb3IgZnJvbSBhIEpTT04gdmFsdWUuXG4gKiBXaWxsIHJldHVybiBhIENvbm5lY3RFcnJvciwgYW5kIHRocm93IHRoZSBwcm92aWRlZCBmYWxsYmFjayBpZiBwYXJzaW5nIGZhaWxlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRnJvbUpzb24oanNvblZhbHVlLCBtZXRhZGF0YSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIG5ldyBIZWFkZXJzKG1ldGFkYXRhKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBmYWxsYmFjay5tZXRhZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb25WYWx1ZSAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBqc29uVmFsdWUgPT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgfVxuICAgIGxldCBjb2RlID0gZmFsbGJhY2suY29kZTtcbiAgICBpZiAoXCJjb2RlXCIgaW4ganNvblZhbHVlICYmIHR5cGVvZiBqc29uVmFsdWUuY29kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb2RlID0gKF9hID0gY29kZUZyb21TdHJpbmcoanNvblZhbHVlLmNvZGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2RlO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0ganNvblZhbHVlLm1lc3NhZ2U7XG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBmYWxsYmFjaztcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgQ29ubmVjdEVycm9yKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IFwiXCIsIGNvZGUsIG1ldGFkYXRhKTtcbiAgICBpZiAoXCJkZXRhaWxzXCIgaW4ganNvblZhbHVlICYmIEFycmF5LmlzQXJyYXkoanNvblZhbHVlLmRldGFpbHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGV0YWlsIG9mIGpzb25WYWx1ZS5kZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoZGV0YWlsID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGRldGFpbCAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkZXRhaWwpIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGRldGFpbC50eXBlICE9IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGV0YWlsLnZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGV0YWlsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiYXNlNjREZWNvZGUoZGV0YWlsLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IGRldGFpbC5kZWJ1ZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiBQYXJzZSBhIENvbm5lY3QgZXJyb3IgZnJvbSBhIHNlcmlhbGl6ZWQgSlNPTiB2YWx1ZS5cbiAqIFdpbGwgcmV0dXJuIGEgQ29ubmVjdEVycm9yLCBhbmQgdGhyb3cgdGhlIHByb3ZpZGVkIGZhbGxiYWNrIGlmIHBhcnNpbmcgZmFpbGVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JGcm9tSnNvbkJ5dGVzKGJ5dGVzLCBtZXRhZGF0YSwgZmFsbGJhY2spIHtcbiAgICBsZXQganNvblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb25WYWx1ZSA9IEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JGcm9tSnNvbihqc29uVmFsdWUsIG1ldGFkYXRhLCBmYWxsYmFjayk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gZXJyb3IgdG8gSlNPTi5cbiAqXG4gKiBUaGUgSlNPTiBzZXJpYWxpemF0aW9uIG9wdGlvbnMgYXJlIHJlcXVpcmVkIHRvIHByb2R1Y2UgdGhlIG9wdGlvbmFsXG4gKiBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBpbiB0aGUgXCJkZWJ1Z1wiIGtleSBpZiB0aGUgZGV0YWlsIHVzZXNcbiAqIGdvb2dsZS5wcm90b2J1Zi5BbnkuIElmIHNlcmlhbGl6YXRpb24gb2YgdGhlIFwiZGVidWdcIiB2YWx1ZSBmYWlscywgaXRcbiAqIGlzIHNpbGVudGx5IGRpc3JlZ2FyZGVkLlxuICpcbiAqIFNlZSBodHRwczovL2Nvbm5lY3RycGMuY29tL2RvY3MvcHJvdG9jb2wjZXJyb3ItZW5kLXN0cmVhbVxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JUb0pzb24oZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpIHtcbiAgICBjb25zdCBvID0ge1xuICAgICAgICBjb2RlOiBjb2RlVG9TdHJpbmcoZXJyb3IuY29kZSksXG4gICAgfTtcbiAgICBpZiAoZXJyb3IucmF3TWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG8ubWVzc2FnZSA9IGVycm9yLnJhd01lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChlcnJvci5kZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgby5kZXRhaWxzID0gZXJyb3IuZGV0YWlsc1xuICAgICAgICAgICAgLm1hcCgoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJkZXNjXCIgaW4gZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gY3JlYXRlKGRldGFpbC5kZXNjLCBkZXRhaWwudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGRldGFpbC5kZXNjLnR5cGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9CaW5hcnkoZGV0YWlsLmRlc2MsIG1zZyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpLmRlYnVnID0gdG9Kc29uKGRldGFpbC5kZXNjLCBtc2csIGpzb25Xcml0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkZWxpYmVyYXRlbHkgaWdub3JlIGVycm9ycyB0aGF0IG1heSBvY2N1ciB3aGVuIHNlcmlhbGl6aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbWVzc2FnZSB0byBKU09OICh0aGUgbWVzc2FnZSBjb250YWlucyBhbiBBbnkpLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF0aW9uYWxlIGlzIHRoYXQgd2UgYXJlIG9ubHkgdHJ5aW5nIHRvIHByb3ZpZGUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVidWcgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoKF9hKSA9PiB7XG4gICAgICAgICAgICB2YXIgeyB2YWx1ZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInZhbHVlXCJdKTtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyB2YWx1ZTogYmFzZTY0RW5jb2RlKHZhbHVlLCBcInN0ZF9yYXdcIikgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gZXJyb3IgdG8gSlNPTi4gVGhpcyBjYWxscyBlcnJvclRvSnNvbigpLCBidXQgc3RyaW5naWZpZXNcbiAqIHRoZSByZXN1bHQsIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgVUludDhBcnJheS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yVG9Kc29uQnl0ZXMoZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb25PYmplY3QgPSBlcnJvclRvSnNvbihlcnJvciwganNvbldyaXRlT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShqc29uT2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShqc29uU3RyaW5nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgZmFpbGVkIHRvIHNlcmlhbGl6ZSBDb25uZWN0IEVycm9yOiAke219YCwgQ29kZS5JbnRlcm5hbCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transformConnectPostToGetRequest: () => (/* binding */ transformConnectPostToGetRequest)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bufbuild/protobuf/wire */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js\");\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./headers.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\nconst contentTypePrefix = \"application/\";\nfunction encodeMessageForUrl(message, useBase64) {\n    if (useBase64) {\n        return (0,_bufbuild_protobuf_wire__WEBPACK_IMPORTED_MODULE_0__.base64Encode)(message, \"url\");\n    }\n    else {\n        return encodeURIComponent(new TextDecoder().decode(message));\n    }\n}\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformConnectPostToGetRequest(request, message, useBase64) {\n    let query = `?connect=v${_version_js__WEBPACK_IMPORTED_MODULE_1__.protocolVersion}`;\n    const contentType = request.header.get(_headers_js__WEBPACK_IMPORTED_MODULE_2__.headerContentType);\n    if ((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(contentTypePrefix)) === 0) {\n        query +=\n            \"&encoding=\" +\n                encodeURIComponent(contentType.slice(contentTypePrefix.length));\n    }\n    const compression = request.header.get(_headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryEncoding);\n    if (compression !== null && compression !== \"identity\") {\n        query += \"&compression=\" + encodeURIComponent(compression);\n        // Force base64 for compressed payloads.\n        useBase64 = true;\n    }\n    if (useBase64) {\n        query += \"&base64=1\";\n    }\n    query += \"&message=\" + encodeMessageForUrl(message, useBase64);\n    const url = request.url + query;\n    // Omit headers that are not used for unary GET requests.\n    const header = new Headers(request.header);\n    [\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerProtocolVersion,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerContentType,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryContentLength,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryEncoding,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryAcceptEncoding,\n    ].forEach((h) => header.delete(h));\n    return Object.assign(Object.assign({}, request), { requestMethod: \"GET\", url,\n        header });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZ2V0LXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQzRGO0FBQ3BHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUVBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHdEQUFlLENBQUM7QUFDN0MsMkNBQTJDLDBEQUFpQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDREQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQXFCO0FBQzdCLFFBQVEsMERBQWlCO0FBQ3pCLFFBQVEsaUVBQXdCO0FBQ2hDLFFBQVEsNERBQW1CO0FBQzNCLFFBQVEsa0VBQXlCO0FBQ2pDO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZ2V0LXJlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGJhc2U2NEVuY29kZSB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWYvd2lyZVwiO1xuaW1wb3J0IHsgaGVhZGVyQ29udGVudFR5cGUsIGhlYWRlclByb3RvY29sVmVyc2lvbiwgaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZywgaGVhZGVyVW5hcnlDb250ZW50TGVuZ3RoLCBoZWFkZXJVbmFyeUVuY29kaW5nLCB9IGZyb20gXCIuL2hlYWRlcnMuanNcIjtcbmltcG9ydCB7IHByb3RvY29sVmVyc2lvbiB9IGZyb20gXCIuL3ZlcnNpb24uanNcIjtcbmNvbnN0IGNvbnRlbnRUeXBlUHJlZml4ID0gXCJhcHBsaWNhdGlvbi9cIjtcbmZ1bmN0aW9uIGVuY29kZU1lc3NhZ2VGb3JVcmwobWVzc2FnZSwgdXNlQmFzZTY0KSB7XG4gICAgaWYgKHVzZUJhc2U2NCkge1xuICAgICAgICByZXR1cm4gYmFzZTY0RW5jb2RlKG1lc3NhZ2UsIFwidXJsXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobWVzc2FnZSkpO1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Db25uZWN0UG9zdFRvR2V0UmVxdWVzdChyZXF1ZXN0LCBtZXNzYWdlLCB1c2VCYXNlNjQpIHtcbiAgICBsZXQgcXVlcnkgPSBgP2Nvbm5lY3Q9diR7cHJvdG9jb2xWZXJzaW9ufWA7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlci5nZXQoaGVhZGVyQ29udGVudFR5cGUpO1xuICAgIGlmICgoY29udGVudFR5cGUgPT09IG51bGwgfHwgY29udGVudFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLmluZGV4T2YoY29udGVudFR5cGVQcmVmaXgpKSA9PT0gMCkge1xuICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgXCImZW5jb2Rpbmc9XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChjb250ZW50VHlwZS5zbGljZShjb250ZW50VHlwZVByZWZpeC5sZW5ndGgpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHJlc3Npb24gPSByZXF1ZXN0LmhlYWRlci5nZXQoaGVhZGVyVW5hcnlFbmNvZGluZyk7XG4gICAgaWYgKGNvbXByZXNzaW9uICE9PSBudWxsICYmIGNvbXByZXNzaW9uICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICAgICAgcXVlcnkgKz0gXCImY29tcHJlc3Npb249XCIgKyBlbmNvZGVVUklDb21wb25lbnQoY29tcHJlc3Npb24pO1xuICAgICAgICAvLyBGb3JjZSBiYXNlNjQgZm9yIGNvbXByZXNzZWQgcGF5bG9hZHMuXG4gICAgICAgIHVzZUJhc2U2NCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1c2VCYXNlNjQpIHtcbiAgICAgICAgcXVlcnkgKz0gXCImYmFzZTY0PTFcIjtcbiAgICB9XG4gICAgcXVlcnkgKz0gXCImbWVzc2FnZT1cIiArIGVuY29kZU1lc3NhZ2VGb3JVcmwobWVzc2FnZSwgdXNlQmFzZTY0KTtcbiAgICBjb25zdCB1cmwgPSByZXF1ZXN0LnVybCArIHF1ZXJ5O1xuICAgIC8vIE9taXQgaGVhZGVycyB0aGF0IGFyZSBub3QgdXNlZCBmb3IgdW5hcnkgR0VUIHJlcXVlc3RzLlxuICAgIGNvbnN0IGhlYWRlciA9IG5ldyBIZWFkZXJzKHJlcXVlc3QuaGVhZGVyKTtcbiAgICBbXG4gICAgICAgIGhlYWRlclByb3RvY29sVmVyc2lvbixcbiAgICAgICAgaGVhZGVyQ29udGVudFR5cGUsXG4gICAgICAgIGhlYWRlclVuYXJ5Q29udGVudExlbmd0aCxcbiAgICAgICAgaGVhZGVyVW5hcnlFbmNvZGluZyxcbiAgICAgICAgaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZyxcbiAgICBdLmZvckVhY2goKGgpID0+IGhlYWRlci5kZWxldGUoaCkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IHJlcXVlc3RNZXRob2Q6IFwiR0VUXCIsIHVybCxcbiAgICAgICAgaGVhZGVyIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerContentType: () => (/* binding */ headerContentType),\n/* harmony export */   headerProtocolVersion: () => (/* binding */ headerProtocolVersion),\n/* harmony export */   headerStreamAcceptEncoding: () => (/* binding */ headerStreamAcceptEncoding),\n/* harmony export */   headerStreamEncoding: () => (/* binding */ headerStreamEncoding),\n/* harmony export */   headerTimeout: () => (/* binding */ headerTimeout),\n/* harmony export */   headerUnaryAcceptEncoding: () => (/* binding */ headerUnaryAcceptEncoding),\n/* harmony export */   headerUnaryContentLength: () => (/* binding */ headerUnaryContentLength),\n/* harmony export */   headerUnaryEncoding: () => (/* binding */ headerUnaryEncoding),\n/* harmony export */   headerUserAgent: () => (/* binding */ headerUserAgent)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nconst headerContentType = \"Content-Type\";\nconst headerUnaryContentLength = \"Content-Length\";\nconst headerUnaryEncoding = \"Content-Encoding\";\nconst headerStreamEncoding = \"Connect-Content-Encoding\";\nconst headerUnaryAcceptEncoding = \"Accept-Encoding\";\nconst headerStreamAcceptEncoding = \"Connect-Accept-Encoding\";\nconst headerTimeout = \"Connect-Timeout-Ms\";\nconst headerProtocolVersion = \"Connect-Protocol-Version\";\nconst headerUserAgent = \"User-Agent\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2hlYWRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBoZWFkZXJDb250ZW50VHlwZSA9IFwiQ29udGVudC1UeXBlXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVW5hcnlDb250ZW50TGVuZ3RoID0gXCJDb250ZW50LUxlbmd0aFwiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclVuYXJ5RW5jb2RpbmcgPSBcIkNvbnRlbnQtRW5jb2RpbmdcIjtcbmV4cG9ydCBjb25zdCBoZWFkZXJTdHJlYW1FbmNvZGluZyA9IFwiQ29ubmVjdC1Db250ZW50LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZyA9IFwiQWNjZXB0LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyU3RyZWFtQWNjZXB0RW5jb2RpbmcgPSBcIkNvbm5lY3QtQWNjZXB0LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVGltZW91dCA9IFwiQ29ubmVjdC1UaW1lb3V0LU1zXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyUHJvdG9jb2xWZXJzaW9uID0gXCJDb25uZWN0LVByb3RvY29sLVZlcnNpb25cIjtcbmV4cG9ydCBjb25zdCBoZWFkZXJVc2VyQWdlbnQgPSBcIlVzZXItQWdlbnRcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeFromHttpStatus: () => (/* binding */ codeFromHttpStatus),\n/* harmony export */   codeToHttpStatus: () => (/* binding */ codeToHttpStatus)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Determine the Connect error code for the given HTTP status code.\n * See https://connectrpc.com/docs/protocol/#http-to-error-code\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeFromHttpStatus(httpStatus) {\n    switch (httpStatus) {\n        case 400: // Bad Request\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Internal;\n        case 401: // Unauthorized\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unauthenticated;\n        case 403: // Forbidden\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.PermissionDenied;\n        case 404: // Not Found\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unimplemented;\n        case 429: // Too Many Requests\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        case 502: // Bad Gateway\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        case 503: // Service Unavailable\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        case 504: // Gateway Timeout\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        default:\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown;\n    }\n}\n/**\n * Returns a HTTP status code for the given Connect code.\n * See https://connectrpc.com/docs/protocol#error-codes\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeToHttpStatus(code) {\n    switch (code) {\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Canceled:\n            return 499; // Client Closed Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown:\n            return 500; // Internal Server Error\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.InvalidArgument:\n            return 400; // Bad Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.DeadlineExceeded:\n            return 504; // Gateway Timeout\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.NotFound:\n            return 404; // Not Found\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.AlreadyExists:\n            return 409; // Conflict\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.PermissionDenied:\n            return 403; // Forbidden\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.ResourceExhausted:\n            return 429; // Too Many Requests\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.FailedPrecondition:\n            return 400; // Bad Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Aborted:\n            return 409; // Conflict\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.OutOfRange:\n            return 400; // Bad Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unimplemented:\n            return 501; // Not Implemented\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Internal:\n            return 500; // Internal Server Error\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable:\n            return 503; // Service Unavailable\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.DataLoss:\n            return 500; // Internal Server Error\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unauthenticated:\n            return 401; // Unauthorized\n        default:\n            return 500; // same as CodeUnknown\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvaHR0cC1zdGF0dXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEIsYUFBYSwwQ0FBSTtBQUNqQix3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2h0dHAtc3RhdHVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBDb25uZWN0IGVycm9yIGNvZGUgZm9yIHRoZSBnaXZlbiBIVFRQIHN0YXR1cyBjb2RlLlxuICogU2VlIGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbC8jaHR0cC10by1lcnJvci1jb2RlXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlRnJvbUh0dHBTdGF0dXMoaHR0cFN0YXR1cykge1xuICAgIHN3aXRjaCAoaHR0cFN0YXR1cykge1xuICAgICAgICBjYXNlIDQwMDogLy8gQmFkIFJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkludGVybmFsO1xuICAgICAgICBjYXNlIDQwMTogLy8gVW5hdXRob3JpemVkXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VbmF1dGhlbnRpY2F0ZWQ7XG4gICAgICAgIGNhc2UgNDAzOiAvLyBGb3JiaWRkZW5cbiAgICAgICAgICAgIHJldHVybiBDb2RlLlBlcm1pc3Npb25EZW5pZWQ7XG4gICAgICAgIGNhc2UgNDA0OiAvLyBOb3QgRm91bmRcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVuaW1wbGVtZW50ZWQ7XG4gICAgICAgIGNhc2UgNDI5OiAvLyBUb28gTWFueSBSZXF1ZXN0c1xuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5hdmFpbGFibGU7XG4gICAgICAgIGNhc2UgNTAyOiAvLyBCYWQgR2F0ZXdheVxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5hdmFpbGFibGU7XG4gICAgICAgIGNhc2UgNTAzOiAvLyBTZXJ2aWNlIFVuYXZhaWxhYmxlXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VbmF2YWlsYWJsZTtcbiAgICAgICAgY2FzZSA1MDQ6IC8vIEdhdGV3YXkgVGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5hdmFpbGFibGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5Vbmtub3duO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIEhUVFAgc3RhdHVzIGNvZGUgZm9yIHRoZSBnaXZlbiBDb25uZWN0IGNvZGUuXG4gKiBTZWUgaHR0cHM6Ly9jb25uZWN0cnBjLmNvbS9kb2NzL3Byb3RvY29sI2Vycm9yLWNvZGVzXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlVG9IdHRwU3RhdHVzKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBDb2RlLkNhbmNlbGVkOlxuICAgICAgICAgICAgcmV0dXJuIDQ5OTsgLy8gQ2xpZW50IENsb3NlZCBSZXF1ZXN0XG4gICAgICAgIGNhc2UgQ29kZS5Vbmtub3duOlxuICAgICAgICAgICAgcmV0dXJuIDUwMDsgLy8gSW50ZXJuYWwgU2VydmVyIEVycm9yXG4gICAgICAgIGNhc2UgQ29kZS5JbnZhbGlkQXJndW1lbnQ6XG4gICAgICAgICAgICByZXR1cm4gNDAwOyAvLyBCYWQgUmVxdWVzdFxuICAgICAgICBjYXNlIENvZGUuRGVhZGxpbmVFeGNlZWRlZDpcbiAgICAgICAgICAgIHJldHVybiA1MDQ7IC8vIEdhdGV3YXkgVGltZW91dFxuICAgICAgICBjYXNlIENvZGUuTm90Rm91bmQ6XG4gICAgICAgICAgICByZXR1cm4gNDA0OyAvLyBOb3QgRm91bmRcbiAgICAgICAgY2FzZSBDb2RlLkFscmVhZHlFeGlzdHM6XG4gICAgICAgICAgICByZXR1cm4gNDA5OyAvLyBDb25mbGljdFxuICAgICAgICBjYXNlIENvZGUuUGVybWlzc2lvbkRlbmllZDpcbiAgICAgICAgICAgIHJldHVybiA0MDM7IC8vIEZvcmJpZGRlblxuICAgICAgICBjYXNlIENvZGUuUmVzb3VyY2VFeGhhdXN0ZWQ6XG4gICAgICAgICAgICByZXR1cm4gNDI5OyAvLyBUb28gTWFueSBSZXF1ZXN0c1xuICAgICAgICBjYXNlIENvZGUuRmFpbGVkUHJlY29uZGl0aW9uOlxuICAgICAgICAgICAgcmV0dXJuIDQwMDsgLy8gQmFkIFJlcXVlc3RcbiAgICAgICAgY2FzZSBDb2RlLkFib3J0ZWQ6XG4gICAgICAgICAgICByZXR1cm4gNDA5OyAvLyBDb25mbGljdFxuICAgICAgICBjYXNlIENvZGUuT3V0T2ZSYW5nZTpcbiAgICAgICAgICAgIHJldHVybiA0MDA7IC8vIEJhZCBSZXF1ZXN0XG4gICAgICAgIGNhc2UgQ29kZS5VbmltcGxlbWVudGVkOlxuICAgICAgICAgICAgcmV0dXJuIDUwMTsgLy8gTm90IEltcGxlbWVudGVkXG4gICAgICAgIGNhc2UgQ29kZS5JbnRlcm5hbDpcbiAgICAgICAgICAgIHJldHVybiA1MDA7IC8vIEludGVybmFsIFNlcnZlciBFcnJvclxuICAgICAgICBjYXNlIENvZGUuVW5hdmFpbGFibGU6XG4gICAgICAgICAgICByZXR1cm4gNTAzOyAvLyBTZXJ2aWNlIFVuYXZhaWxhYmxlXG4gICAgICAgIGNhc2UgQ29kZS5EYXRhTG9zczpcbiAgICAgICAgICAgIHJldHVybiA1MDA7IC8vIEludGVybmFsIFNlcnZlciBFcnJvclxuICAgICAgICBjYXNlIENvZGUuVW5hdXRoZW50aWNhdGVkOlxuICAgICAgICAgICAgcmV0dXJuIDQwMTsgLy8gVW5hdXRob3JpemVkXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gNTAwOyAvLyBzYW1lIGFzIENvZGVVbmtub3duXG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   paramBase64: () => (/* binding */ paramBase64),\n/* harmony export */   paramCompression: () => (/* binding */ paramCompression),\n/* harmony export */   paramConnectVersion: () => (/* binding */ paramConnectVersion),\n/* harmony export */   paramEncoding: () => (/* binding */ paramEncoding),\n/* harmony export */   paramMessage: () => (/* binding */ paramMessage)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nconst paramConnectVersion = \"connect\";\nconst paramEncoding = \"encoding\";\nconst paramCompression = \"compression\";\nconst paramBase64 = \"base64\";\nconst paramMessage = \"message\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvcXVlcnktcGFyYW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvcXVlcnktcGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgcGFyYW1Db25uZWN0VmVyc2lvbiA9IFwiY29ubmVjdFwiO1xuZXhwb3J0IGNvbnN0IHBhcmFtRW5jb2RpbmcgPSBcImVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgcGFyYW1Db21wcmVzc2lvbiA9IFwiY29tcHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBwYXJhbUJhc2U2NCA9IFwiYmFzZTY0XCI7XG5leHBvcnQgY29uc3QgcGFyYW1NZXNzYWdlID0gXCJtZXNzYWdlXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requestHeader: () => (/* binding */ requestHeader),\n/* harmony export */   requestHeaderWithCompression: () => (/* binding */ requestHeaderWithCompression)\n/* harmony export */ });\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js\");\n/* harmony import */ var _content_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content-type.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Creates headers for a Connect request.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    if (timeoutMs !== undefined) {\n        result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerTimeout, `${timeoutMs}`);\n    }\n    result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerContentType, methodKind == \"unary\"\n        ? useBinaryFormat\n            ? _content_type_js__WEBPACK_IMPORTED_MODULE_1__.contentTypeUnaryProto\n            : _content_type_js__WEBPACK_IMPORTED_MODULE_1__.contentTypeUnaryJson\n        : useBinaryFormat\n            ? _content_type_js__WEBPACK_IMPORTED_MODULE_1__.contentTypeStreamProto\n            : _content_type_js__WEBPACK_IMPORTED_MODULE_1__.contentTypeStreamJson);\n    result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion, _version_js__WEBPACK_IMPORTED_MODULE_2__.protocolVersion);\n    if (!result.has(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUserAgent) && setUserAgent) {\n        // Note that we do not strictly comply with gRPC user agents.\n        // We use \"connect-es/1.2.3\" where gRPC would use \"grpc-es/1.2.3\".\n        // See https://github.com/grpc/grpc/blob/c462bb8d485fc1434ecfae438823ca8d14cf3154/doc/PROTOCOL-HTTP2.md#user-agents\n        result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUserAgent, \"connect-es/2.0.0-rc.3\");\n    }\n    return result;\n}\n/**\n * Creates headers for a Connect request with compression.\n *\n * Note that we always set the Content-Encoding header for unary methods.\n * It is up to the caller to decide whether to apply compression - and remove\n * the header if compression is not used, for example because the payload is\n * too small to make compression effective.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requestHeaderWithCompression(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, acceptCompression, sendCompression, setUserAgent) {\n    const result = requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent);\n    if (sendCompression != null) {\n        const name = methodKind == \"unary\" ? _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUnaryEncoding : _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerStreamEncoding;\n        result.set(name, sendCompression.name);\n    }\n    if (acceptCompression.length > 0) {\n        const name = methodKind == \"unary\"\n            ? _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUnaryAcceptEncoding\n            : _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerStreamAcceptEncoding;\n        result.set(name, acceptCompression.map((c) => c.name).join(\",\"));\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvcmVxdWVzdC1oZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyTTtBQUM1SjtBQUNpRjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3SEFBd0g7QUFDeEg7QUFDQSxtQkFBbUIsc0RBQWEsS0FBSyxVQUFVO0FBQy9DO0FBQ0EsZUFBZSwwREFBaUI7QUFDaEM7QUFDQSxjQUFjLG1FQUFxQjtBQUNuQyxjQUFjLGtFQUFvQjtBQUNsQztBQUNBLGNBQWMsb0VBQXNCO0FBQ3BDLGNBQWMsbUVBQXFCO0FBQ25DLGVBQWUsOERBQXFCLEVBQUUsd0RBQWU7QUFDckQsb0JBQW9CLHdEQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2Qyw0REFBbUIsR0FBRyw2REFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUF5QjtBQUN2QyxjQUFjLG1FQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3JlcXVlc3QtaGVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBoZWFkZXJDb250ZW50VHlwZSwgaGVhZGVyU3RyZWFtQWNjZXB0RW5jb2RpbmcsIGhlYWRlclN0cmVhbUVuY29kaW5nLCBoZWFkZXJVbmFyeUFjY2VwdEVuY29kaW5nLCBoZWFkZXJVbmFyeUVuY29kaW5nLCBoZWFkZXJUaW1lb3V0LCBoZWFkZXJQcm90b2NvbFZlcnNpb24sIGhlYWRlclVzZXJBZ2VudCwgfSBmcm9tIFwiLi9oZWFkZXJzLmpzXCI7XG5pbXBvcnQgeyBwcm90b2NvbFZlcnNpb24gfSBmcm9tIFwiLi92ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBjb250ZW50VHlwZVN0cmVhbUpzb24sIGNvbnRlbnRUeXBlU3RyZWFtUHJvdG8sIGNvbnRlbnRUeXBlVW5hcnlKc29uLCBjb250ZW50VHlwZVVuYXJ5UHJvdG8sIH0gZnJvbSBcIi4vY29udGVudC10eXBlLmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgaGVhZGVycyBmb3IgYSBDb25uZWN0IHJlcXVlc3QuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0SGVhZGVyKG1ldGhvZEtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgdGltZW91dE1zLCB1c2VyUHJvdmlkZWRIZWFkZXJzLCBzZXRVc2VyQWdlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgSGVhZGVycyh1c2VyUHJvdmlkZWRIZWFkZXJzICE9PSBudWxsICYmIHVzZXJQcm92aWRlZEhlYWRlcnMgIT09IHZvaWQgMCA/IHVzZXJQcm92aWRlZEhlYWRlcnMgOiB7fSk7XG4gICAgaWYgKHRpbWVvdXRNcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaGVhZGVyVGltZW91dCwgYCR7dGltZW91dE1zfWApO1xuICAgIH1cbiAgICByZXN1bHQuc2V0KGhlYWRlckNvbnRlbnRUeXBlLCBtZXRob2RLaW5kID09IFwidW5hcnlcIlxuICAgICAgICA/IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICAgICAgPyBjb250ZW50VHlwZVVuYXJ5UHJvdG9cbiAgICAgICAgICAgIDogY29udGVudFR5cGVVbmFyeUpzb25cbiAgICAgICAgOiB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgICAgID8gY29udGVudFR5cGVTdHJlYW1Qcm90b1xuICAgICAgICAgICAgOiBjb250ZW50VHlwZVN0cmVhbUpzb24pO1xuICAgIHJlc3VsdC5zZXQoaGVhZGVyUHJvdG9jb2xWZXJzaW9uLCBwcm90b2NvbFZlcnNpb24pO1xuICAgIGlmICghcmVzdWx0LmhhcyhoZWFkZXJVc2VyQWdlbnQpICYmIHNldFVzZXJBZ2VudCkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gbm90IHN0cmljdGx5IGNvbXBseSB3aXRoIGdSUEMgdXNlciBhZ2VudHMuXG4gICAgICAgIC8vIFdlIHVzZSBcImNvbm5lY3QtZXMvMS4yLjNcIiB3aGVyZSBnUlBDIHdvdWxkIHVzZSBcImdycGMtZXMvMS4yLjNcIi5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9jNDYyYmI4ZDQ4NWZjMTQzNGVjZmFlNDM4ODIzY2E4ZDE0Y2YzMTU0L2RvYy9QUk9UT0NPTC1IVFRQMi5tZCN1c2VyLWFnZW50c1xuICAgICAgICByZXN1bHQuc2V0KGhlYWRlclVzZXJBZ2VudCwgXCJjb25uZWN0LWVzLzIuMC4wLXJjLjNcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENyZWF0ZXMgaGVhZGVycyBmb3IgYSBDb25uZWN0IHJlcXVlc3Qgd2l0aCBjb21wcmVzc2lvbi5cbiAqXG4gKiBOb3RlIHRoYXQgd2UgYWx3YXlzIHNldCB0aGUgQ29udGVudC1FbmNvZGluZyBoZWFkZXIgZm9yIHVuYXJ5IG1ldGhvZHMuXG4gKiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGFwcGx5IGNvbXByZXNzaW9uIC0gYW5kIHJlbW92ZVxuICogdGhlIGhlYWRlciBpZiBjb21wcmVzc2lvbiBpcyBub3QgdXNlZCwgZm9yIGV4YW1wbGUgYmVjYXVzZSB0aGUgcGF5bG9hZCBpc1xuICogdG9vIHNtYWxsIHRvIG1ha2UgY29tcHJlc3Npb24gZWZmZWN0aXZlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEhlYWRlcldpdGhDb21wcmVzc2lvbihtZXRob2RLaW5kLCB1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgdXNlclByb3ZpZGVkSGVhZGVycywgYWNjZXB0Q29tcHJlc3Npb24sIHNlbmRDb21wcmVzc2lvbiwgc2V0VXNlckFnZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVxdWVzdEhlYWRlcihtZXRob2RLaW5kLCB1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgdXNlclByb3ZpZGVkSGVhZGVycywgc2V0VXNlckFnZW50KTtcbiAgICBpZiAoc2VuZENvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG1ldGhvZEtpbmQgPT0gXCJ1bmFyeVwiID8gaGVhZGVyVW5hcnlFbmNvZGluZyA6IGhlYWRlclN0cmVhbUVuY29kaW5nO1xuICAgICAgICByZXN1bHQuc2V0KG5hbWUsIHNlbmRDb21wcmVzc2lvbi5uYW1lKTtcbiAgICB9XG4gICAgaWYgKGFjY2VwdENvbXByZXNzaW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG1ldGhvZEtpbmQgPT0gXCJ1bmFyeVwiXG4gICAgICAgICAgICA/IGhlYWRlclVuYXJ5QWNjZXB0RW5jb2RpbmdcbiAgICAgICAgICAgIDogaGVhZGVyU3RyZWFtQWNjZXB0RW5jb2Rpbmc7XG4gICAgICAgIHJlc3VsdC5zZXQobmFtZSwgYWNjZXB0Q29tcHJlc3Npb24ubWFwKChjKSA9PiBjLm5hbWUpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trailerDemux: () => (/* binding */ trailerDemux),\n/* harmony export */   trailerMux: () => (/* binding */ trailerMux)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function demuxes headers and trailers into two separate Headers\n * objects.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction trailerDemux(header) {\n    const h = new Headers(), t = new Headers();\n    header.forEach((value, key) => {\n        if (key.toLowerCase().startsWith(\"trailer-\")) {\n            t.append(key.substring(8), value);\n        }\n        else {\n            h.append(key, value);\n        }\n    });\n    return [h, t];\n}\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function muxes a header and a trailer into a single Headers object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction trailerMux(header, trailer) {\n    const h = new Headers(header);\n    trailer.forEach((value, key) => {\n        h.append(`trailer-${key}`, value);\n    });\n    return h;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdHJhaWxlci1tdXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdHJhaWxlci1tdXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogSW4gdW5hcnkgUlBDcywgQ29ubmVjdCB0cmFuc3BvcnRzIHRyYWlsaW5nIG1ldGFkYXRhIGFzIHJlc3BvbnNlIGhlYWRlclxuICogZmllbGRzLCBwcmVmaXhlZCB3aXRoIFwidHJhaWxlci1cIi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRlbXV4ZXMgaGVhZGVycyBhbmQgdHJhaWxlcnMgaW50byB0d28gc2VwYXJhdGUgSGVhZGVyc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWlsZXJEZW11eChoZWFkZXIpIHtcbiAgICBjb25zdCBoID0gbmV3IEhlYWRlcnMoKSwgdCA9IG5ldyBIZWFkZXJzKCk7XG4gICAgaGVhZGVyLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJ0cmFpbGVyLVwiKSkge1xuICAgICAgICAgICAgdC5hcHBlbmQoa2V5LnN1YnN0cmluZyg4KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaC5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW2gsIHRdO1xufVxuLyoqXG4gKiBJbiB1bmFyeSBSUENzLCBDb25uZWN0IHRyYW5zcG9ydHMgdHJhaWxpbmcgbWV0YWRhdGEgYXMgcmVzcG9uc2UgaGVhZGVyXG4gKiBmaWVsZHMsIHByZWZpeGVkIHdpdGggXCJ0cmFpbGVyLVwiLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbXV4ZXMgYSBoZWFkZXIgYW5kIGEgdHJhaWxlciBpbnRvIGEgc2luZ2xlIEhlYWRlcnMgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhaWxlck11eChoZWFkZXIsIHRyYWlsZXIpIHtcbiAgICBjb25zdCBoID0gbmV3IEhlYWRlcnMoaGVhZGVyKTtcbiAgICB0cmFpbGVyLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaC5hcHBlbmQoYHRyYWlsZXItJHtrZXl9YCwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBoO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateResponse: () => (/* binding */ validateResponse),\n/* harmony export */   validateResponseWithCompression: () => (/* binding */ validateResponseWithCompression)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _http_status_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./http-status.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _content_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content-type.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js\");\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n/**\n * Validates response status and header for the Connect protocol.\n * Throws a ConnectError if the header indicates an error, or if\n * the content type is unexpected, with the following exception:\n * For unary RPCs with an HTTP error status, this returns an error\n * derived from the HTTP status instead of throwing it, giving an\n * implementation a chance to parse a Connect error from the wire.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateResponse(methodKind, useBinaryFormat, status, headers) {\n    const mimeType = headers.get(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerContentType);\n    const parsedType = (0,_content_type_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(mimeType);\n    if (status !== 200) {\n        const errorFromStatus = new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`HTTP ${status}`, (0,_http_status_js__WEBPACK_IMPORTED_MODULE_3__.codeFromHttpStatus)(status), headers);\n        // If parsedType is defined and it is not binary, then this is a unary JSON response\n        if (methodKind == \"unary\" && parsedType && !parsedType.binary) {\n            return { isUnaryError: true, unaryError: errorFromStatus };\n        }\n        throw errorFromStatus;\n    }\n    const allowedContentType = {\n        binary: useBinaryFormat,\n        stream: methodKind !== \"unary\",\n    };\n    if ((parsedType === null || parsedType === void 0 ? void 0 : parsedType.binary) !== allowedContentType.binary ||\n        parsedType.stream !== allowedContentType.stream) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`unsupported content type ${mimeType}`, parsedType === undefined ? _code_js__WEBPACK_IMPORTED_MODULE_4__.Code.Unknown : _code_js__WEBPACK_IMPORTED_MODULE_4__.Code.Internal, headers);\n    }\n    return { isUnaryError: false };\n}\n/**\n * Validates response status and header for the Connect protocol.\n * This function is identical to validateResponse(), but also verifies\n * that a given encoding header is acceptable.\n *\n * @private\n */\nfunction validateResponseWithCompression(methodKind, acceptCompression, useBinaryFormat, status, headers) {\n    let compression;\n    const encoding = headers.get(methodKind == \"unary\" ? _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUnaryEncoding : _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerStreamEncoding);\n    if (encoding != null && encoding.toLowerCase() !== \"identity\") {\n        compression = acceptCompression.find((c) => c.name === encoding);\n        if (!compression) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`unsupported response encoding \"${encoding}\"`, _code_js__WEBPACK_IMPORTED_MODULE_4__.Code.Internal, headers);\n        }\n    }\n    return Object.assign({ compression }, validateResponse(methodKind, useBinaryFormat, status, headers));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdmFsaWRhdGUtcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ29CO0FBQ0g7QUFDRTtBQUN3QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLDBEQUFpQjtBQUNsRCx1QkFBdUIsa0VBQWdCO0FBQ3ZDO0FBQ0Esb0NBQW9DLDJEQUFZLFNBQVMsT0FBTyxHQUFHLG1FQUFrQjtBQUNyRjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBWSw2QkFBNkIsU0FBUyw4QkFBOEIsMENBQUksV0FBVywwQ0FBSTtBQUNySDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlEQUF5RCw0REFBbUIsR0FBRyw2REFBb0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFZLG1DQUFtQyxTQUFTLElBQUksMENBQUk7QUFDdEY7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdmFsaWRhdGUtcmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgY29kZUZyb21IdHRwU3RhdHVzIH0gZnJvbSBcIi4vaHR0cC1zdGF0dXMuanNcIjtcbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUNvbnRlbnRUeXBlIH0gZnJvbSBcIi4vY29udGVudC10eXBlLmpzXCI7XG5pbXBvcnQgeyBoZWFkZXJDb250ZW50VHlwZSwgaGVhZGVyU3RyZWFtRW5jb2RpbmcsIGhlYWRlclVuYXJ5RW5jb2RpbmcsIH0gZnJvbSBcIi4vaGVhZGVycy5qc1wiO1xuLyoqXG4gKiBWYWxpZGF0ZXMgcmVzcG9uc2Ugc3RhdHVzIGFuZCBoZWFkZXIgZm9yIHRoZSBDb25uZWN0IHByb3RvY29sLlxuICogVGhyb3dzIGEgQ29ubmVjdEVycm9yIGlmIHRoZSBoZWFkZXIgaW5kaWNhdGVzIGFuIGVycm9yLCBvciBpZlxuICogdGhlIGNvbnRlbnQgdHlwZSBpcyB1bmV4cGVjdGVkLCB3aXRoIHRoZSBmb2xsb3dpbmcgZXhjZXB0aW9uOlxuICogRm9yIHVuYXJ5IFJQQ3Mgd2l0aCBhbiBIVFRQIGVycm9yIHN0YXR1cywgdGhpcyByZXR1cm5zIGFuIGVycm9yXG4gKiBkZXJpdmVkIGZyb20gdGhlIEhUVFAgc3RhdHVzIGluc3RlYWQgb2YgdGhyb3dpbmcgaXQsIGdpdmluZyBhblxuICogaW1wbGVtZW50YXRpb24gYSBjaGFuY2UgdG8gcGFyc2UgYSBDb25uZWN0IGVycm9yIGZyb20gdGhlIHdpcmUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlKG1ldGhvZEtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgc3RhdHVzLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXJzLmdldChoZWFkZXJDb250ZW50VHlwZSk7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHBhcnNlQ29udGVudFR5cGUobWltZVR5cGUpO1xuICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBjb25zdCBlcnJvckZyb21TdGF0dXMgPSBuZXcgQ29ubmVjdEVycm9yKGBIVFRQICR7c3RhdHVzfWAsIGNvZGVGcm9tSHR0cFN0YXR1cyhzdGF0dXMpLCBoZWFkZXJzKTtcbiAgICAgICAgLy8gSWYgcGFyc2VkVHlwZSBpcyBkZWZpbmVkIGFuZCBpdCBpcyBub3QgYmluYXJ5LCB0aGVuIHRoaXMgaXMgYSB1bmFyeSBKU09OIHJlc3BvbnNlXG4gICAgICAgIGlmIChtZXRob2RLaW5kID09IFwidW5hcnlcIiAmJiBwYXJzZWRUeXBlICYmICFwYXJzZWRUeXBlLmJpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNVbmFyeUVycm9yOiB0cnVlLCB1bmFyeUVycm9yOiBlcnJvckZyb21TdGF0dXMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvckZyb21TdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRDb250ZW50VHlwZSA9IHtcbiAgICAgICAgYmluYXJ5OiB1c2VCaW5hcnlGb3JtYXQsXG4gICAgICAgIHN0cmVhbTogbWV0aG9kS2luZCAhPT0gXCJ1bmFyeVwiLFxuICAgIH07XG4gICAgaWYgKChwYXJzZWRUeXBlID09PSBudWxsIHx8IHBhcnNlZFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFR5cGUuYmluYXJ5KSAhPT0gYWxsb3dlZENvbnRlbnRUeXBlLmJpbmFyeSB8fFxuICAgICAgICBwYXJzZWRUeXBlLnN0cmVhbSAhPT0gYWxsb3dlZENvbnRlbnRUeXBlLnN0cmVhbSkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGB1bnN1cHBvcnRlZCBjb250ZW50IHR5cGUgJHttaW1lVHlwZX1gLCBwYXJzZWRUeXBlID09PSB1bmRlZmluZWQgPyBDb2RlLlVua25vd24gOiBDb2RlLkludGVybmFsLCBoZWFkZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNVbmFyeUVycm9yOiBmYWxzZSB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgcmVzcG9uc2Ugc3RhdHVzIGFuZCBoZWFkZXIgZm9yIHRoZSBDb25uZWN0IHByb3RvY29sLlxuICogVGhpcyBmdW5jdGlvbiBpcyBpZGVudGljYWwgdG8gdmFsaWRhdGVSZXNwb25zZSgpLCBidXQgYWxzbyB2ZXJpZmllc1xuICogdGhhdCBhIGdpdmVuIGVuY29kaW5nIGhlYWRlciBpcyBhY2NlcHRhYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlV2l0aENvbXByZXNzaW9uKG1ldGhvZEtpbmQsIGFjY2VwdENvbXByZXNzaW9uLCB1c2VCaW5hcnlGb3JtYXQsIHN0YXR1cywgaGVhZGVycykge1xuICAgIGxldCBjb21wcmVzc2lvbjtcbiAgICBjb25zdCBlbmNvZGluZyA9IGhlYWRlcnMuZ2V0KG1ldGhvZEtpbmQgPT0gXCJ1bmFyeVwiID8gaGVhZGVyVW5hcnlFbmNvZGluZyA6IGhlYWRlclN0cmVhbUVuY29kaW5nKTtcbiAgICBpZiAoZW5jb2RpbmcgIT0gbnVsbCAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICAgICAgY29tcHJlc3Npb24gPSBhY2NlcHRDb21wcmVzc2lvbi5maW5kKChjKSA9PiBjLm5hbWUgPT09IGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgdW5zdXBwb3J0ZWQgcmVzcG9uc2UgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCwgQ29kZS5JbnRlcm5hbCwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBjb21wcmVzc2lvbiB9LCB2YWxpZGF0ZVJlc3BvbnNlKG1ldGhvZEtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgc3RhdHVzLCBoZWFkZXJzKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   requireProtocolVersionHeader: () => (/* binding */ requireProtocolVersionHeader),\n/* harmony export */   requireProtocolVersionParam: () => (/* binding */ requireProtocolVersionParam)\n/* harmony export */ });\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n/* harmony import */ var _query_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./query-params.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * The only know value for the header Connect-Protocol-Version.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst protocolVersion = \"1\";\n/**\n * Requires the Connect-Protocol-Version header to be present with the expected\n * value. Raises a ConnectError with Code.InvalidArgument otherwise.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requireProtocolVersionHeader(requestHeader) {\n    const v = requestHeader.get(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion);\n    if (v === null) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`missing required header: set ${_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion} to \"${protocolVersion}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n    else if (v !== protocolVersion) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`${_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion} must be \"${protocolVersion}\": got \"${v}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n}\n/**\n * Requires the connect query parameter to be present with the expected value.\n * Raises a ConnectError with Code.InvalidArgument otherwise.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requireProtocolVersionParam(queryParams) {\n    const v = queryParams.get(_query_params_js__WEBPACK_IMPORTED_MODULE_3__.paramConnectVersion);\n    if (v === null) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`missing required parameter: set ${_query_params_js__WEBPACK_IMPORTED_MODULE_3__.paramConnectVersion} to \"v${protocolVersion}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n    else if (v !== `v${protocolVersion}`) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`${_query_params_js__WEBPACK_IMPORTED_MODULE_3__.paramConnectVersion} must be \"v${protocolVersion}\": got \"${v}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUQ7QUFDRztBQUNMO0FBQ2pCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDLDhEQUFxQjtBQUNyRDtBQUNBLGtCQUFrQiwyREFBWSxpQ0FBaUMsOERBQXFCLEVBQUUsTUFBTSxnQkFBZ0IsSUFBSSwwQ0FBSTtBQUNwSDtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFZLElBQUksOERBQXFCLEVBQUUsV0FBVyxnQkFBZ0IsVUFBVSxFQUFFLElBQUksMENBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsOEJBQThCLGlFQUFtQjtBQUNqRDtBQUNBLGtCQUFrQiwyREFBWSxvQ0FBb0MsaUVBQW1CLEVBQUUsT0FBTyxnQkFBZ0IsSUFBSSwwQ0FBSTtBQUN0SDtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkMsa0JBQWtCLDJEQUFZLElBQUksaUVBQW1CLEVBQUUsWUFBWSxnQkFBZ0IsVUFBVSxFQUFFLElBQUksMENBQUk7QUFDdkc7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGhlYWRlclByb3RvY29sVmVyc2lvbiB9IGZyb20gXCIuL2hlYWRlcnMuanNcIjtcbmltcG9ydCB7IHBhcmFtQ29ubmVjdFZlcnNpb24gfSBmcm9tIFwiLi9xdWVyeS1wYXJhbXMuanNcIjtcbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogVGhlIG9ubHkga25vdyB2YWx1ZSBmb3IgdGhlIGhlYWRlciBDb25uZWN0LVByb3RvY29sLVZlcnNpb24uXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBwcm90b2NvbFZlcnNpb24gPSBcIjFcIjtcbi8qKlxuICogUmVxdWlyZXMgdGhlIENvbm5lY3QtUHJvdG9jb2wtVmVyc2lvbiBoZWFkZXIgdG8gYmUgcHJlc2VudCB3aXRoIHRoZSBleHBlY3RlZFxuICogdmFsdWUuIFJhaXNlcyBhIENvbm5lY3RFcnJvciB3aXRoIENvZGUuSW52YWxpZEFyZ3VtZW50IG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVQcm90b2NvbFZlcnNpb25IZWFkZXIocmVxdWVzdEhlYWRlcikge1xuICAgIGNvbnN0IHYgPSByZXF1ZXN0SGVhZGVyLmdldChoZWFkZXJQcm90b2NvbFZlcnNpb24pO1xuICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYG1pc3NpbmcgcmVxdWlyZWQgaGVhZGVyOiBzZXQgJHtoZWFkZXJQcm90b2NvbFZlcnNpb259IHRvIFwiJHtwcm90b2NvbFZlcnNpb259XCJgLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgIT09IHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGAke2hlYWRlclByb3RvY29sVmVyc2lvbn0gbXVzdCBiZSBcIiR7cHJvdG9jb2xWZXJzaW9ufVwiOiBnb3QgXCIke3Z9XCJgLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXF1aXJlcyB0aGUgY29ubmVjdCBxdWVyeSBwYXJhbWV0ZXIgdG8gYmUgcHJlc2VudCB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAqIFJhaXNlcyBhIENvbm5lY3RFcnJvciB3aXRoIENvZGUuSW52YWxpZEFyZ3VtZW50IG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVQcm90b2NvbFZlcnNpb25QYXJhbShxdWVyeVBhcmFtcykge1xuICAgIGNvbnN0IHYgPSBxdWVyeVBhcmFtcy5nZXQocGFyYW1Db25uZWN0VmVyc2lvbik7XG4gICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IHNldCAke3BhcmFtQ29ubmVjdFZlcnNpb259IHRvIFwidiR7cHJvdG9jb2xWZXJzaW9ufVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ICE9PSBgdiR7cHJvdG9jb2xWZXJzaW9ufWApIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgJHtwYXJhbUNvbm5lY3RWZXJzaW9ufSBtdXN0IGJlIFwidiR7cHJvdG9jb2xWZXJzaW9ufVwiOiBnb3QgXCIke3Z9XCJgLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAsyncIterable: () => (/* binding */ createAsyncIterable),\n/* harmony export */   createWritableIterable: () => (/* binding */ createWritableIterable),\n/* harmony export */   makeIterableAbortable: () => (/* binding */ makeIterableAbortable),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   pipeTo: () => (/* binding */ pipeTo),\n/* harmony export */   readAllBytes: () => (/* binding */ readAllBytes),\n/* harmony export */   sinkAll: () => (/* binding */ sinkAll),\n/* harmony export */   sinkAllBytes: () => (/* binding */ sinkAllBytes),\n/* harmony export */   transformAppend: () => (/* binding */ transformAppend),\n/* harmony export */   transformCatch: () => (/* binding */ transformCatch),\n/* harmony export */   transformCatchFinally: () => (/* binding */ transformCatchFinally),\n/* harmony export */   transformCompressEnvelope: () => (/* binding */ transformCompressEnvelope),\n/* harmony export */   transformDecompressEnvelope: () => (/* binding */ transformDecompressEnvelope),\n/* harmony export */   transformJoinEnvelopes: () => (/* binding */ transformJoinEnvelopes),\n/* harmony export */   transformParseEnvelope: () => (/* binding */ transformParseEnvelope),\n/* harmony export */   transformPrepend: () => (/* binding */ transformPrepend),\n/* harmony export */   transformReadAllBytes: () => (/* binding */ transformReadAllBytes),\n/* harmony export */   transformSerializeEnvelope: () => (/* binding */ transformSerializeEnvelope),\n/* harmony export */   transformSplitEnvelope: () => (/* binding */ transformSplitEnvelope),\n/* harmony export */   untilFirst: () => (/* binding */ untilFirst)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _envelope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./envelope.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\");\n/* harmony import */ var _limit_io_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./limit-io.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncDelegator = (undefined && undefined.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\n\n\n\n\nfunction pipeTo(source, ...rest) {\n    const [transforms, sink, opt] = pickTransformsAndSink(rest);\n    let iterable = source;\n    let abortable;\n    if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n        iterable = abortable = makeIterableAbortable(iterable);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    iterable = pipe(iterable, ...transforms, { propagateDownStreamError: false });\n    return sink(iterable).catch((reason) => {\n        if (abortable) {\n            return abortable.abort(reason).then(() => Promise.reject(reason));\n        }\n        return Promise.reject(reason);\n    });\n}\n// pick transforms, the sink, and options from the pipeTo() rest parameter\nfunction pickTransformsAndSink(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    const sink = rest.pop();\n    return [rest, sink, opt];\n}\n/**\n * Creates an AsyncIterableSink that concatenates all elements from the input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction sinkAll() {\n    return async function (iterable) {\n        var _a, e_1, _b, _c;\n        const all = [];\n        try {\n            for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), _a = iterable_1_1.done, !_a; _d = true) {\n                _c = iterable_1_1.value;\n                _d = false;\n                const chunk = _c;\n                all.push(chunk);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = iterable_1.return)) await _b.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return all;\n    };\n}\n/**\n * Creates an AsyncIterableSink that concatenates all chunks from the input into\n * a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction sinkAllBytes(readMaxBytes, lengthHint) {\n    return async function (iterable) {\n        return await readAllBytes(iterable, readMaxBytes, lengthHint);\n    };\n}\nfunction pipe(source, ...rest) {\n    return __asyncGenerator(this, arguments, function* pipe_1() {\n        var _a;\n        const [transforms, opt] = pickTransforms(rest);\n        let abortable;\n        const sourceIt = source[Symbol.asyncIterator]();\n        const cachedSource = {\n            [Symbol.asyncIterator]() {\n                return sourceIt;\n            },\n        };\n        let iterable = cachedSource;\n        if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n            iterable = abortable = makeIterableAbortable(iterable);\n        }\n        for (const t of transforms) {\n            iterable = t(iterable);\n        }\n        const it = iterable[Symbol.asyncIterator]();\n        try {\n            for (;;) {\n                const r = yield __await(it.next());\n                if (r.done === true) {\n                    break;\n                }\n                if (!abortable) {\n                    yield yield __await(r.value);\n                    continue;\n                }\n                try {\n                    yield yield __await(r.value);\n                }\n                catch (e) {\n                    yield __await(abortable.abort(e)); // propagate downstream error to the source\n                    throw e;\n                }\n            }\n        }\n        finally {\n            if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n                // Call return on the source iterable to indicate\n                // that we will no longer consume it and it should\n                // cleanup any allocated resources.\n                (_a = sourceIt.return) === null || _a === void 0 ? void 0 : _a.call(sourceIt).catch(() => {\n                    // return returns a promise, which we don't care about.\n                    //\n                    // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                    // this is to ensure error is caught and ignored.\n                });\n            }\n        }\n    });\n}\nfunction pickTransforms(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    return [rest, opt];\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given catchError function.\n *\n * The catchError function may return a final value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCatch(catchError) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    const caught = yield __await(catchError(e));\n                    if (caught !== undefined) {\n                        yield yield __await(caught);\n                    }\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given function. Unlike transformCatch(), the given function\n * is also called when no error is raised.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCatchFinally(catchFinally) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            let err;\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    err = e;\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n            const caught = yield __await(catchFinally(err));\n            if (caught !== undefined) {\n                yield yield __await(caught);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that appends a value.\n *\n * The element to append is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformAppend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_2, _b, _c;\n            try {\n                for (var _d = true, iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield __await(iterable_2.next()), _a = iterable_2_1.done, !_a; _d = true) {\n                    _c = iterable_2_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_2.return)) yield __await(_b.call(iterable_2));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            const append = yield __await(provide());\n            if (append !== undefined) {\n                yield yield __await(append);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that prepends an element.\n *\n * The element to prepend is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformPrepend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_3, _b, _c;\n            const prepend = yield __await(provide());\n            if (prepend !== undefined) {\n                yield yield __await(prepend);\n            }\n            try {\n                for (var _d = true, iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield __await(iterable_3.next()), _a = iterable_3_1.done, !_a; _d = true) {\n                    _c = iterable_3_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_3.return)) yield __await(_b.call(iterable_3));\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that reads all bytes from the input, and\n * concatenates them to a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformReadAllBytes(readMaxBytes, lengthHint) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            yield yield __await(yield __await(readAllBytes(iterable, readMaxBytes, lengthHint)));\n        });\n    };\n}\nfunction transformSerializeEnvelope(serialization, endStreamFlag, endSerialization) {\n    if (endStreamFlag === undefined || endSerialization === undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_4, _b, _c;\n                try {\n                    for (var _d = true, iterable_4 = __asyncValues(iterable), iterable_4_1; iterable_4_1 = yield __await(iterable_4.next()), _a = iterable_4_1.done, !_a; _d = true) {\n                        _c = iterable_4_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        const data = serialization.serialize(chunk);\n                        yield yield __await({ flags: 0, data });\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_4.return)) yield __await(_b.call(iterable_4));\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            });\n        };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_5, _b, _c;\n            try {\n                for (var _d = true, iterable_5 = __asyncValues(iterable), iterable_5_1; iterable_5_1 = yield __await(iterable_5.next()), _a = iterable_5_1.done, !_a; _d = true) {\n                    _c = iterable_5_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    let data;\n                    let flags = 0;\n                    if (chunk.end) {\n                        flags = flags | endStreamFlag;\n                        data = endSerialization.serialize(chunk.value);\n                    }\n                    else {\n                        data = serialization.serialize(chunk.value);\n                    }\n                    yield yield __await({ flags, data });\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_5.return)) yield __await(_b.call(iterable_5));\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n        });\n    };\n}\nfunction transformParseEnvelope(serialization, endStreamFlag, endSerialization) {\n    // code path always yields ParsedEnvelopedMessage<T, E>\n    if (endSerialization && endStreamFlag !== undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_6, _b, _c;\n                try {\n                    for (var _d = true, iterable_6 = __asyncValues(iterable), iterable_6_1; iterable_6_1 = yield __await(iterable_6.next()), _a = iterable_6_1.done, !_a; _d = true) {\n                        _c = iterable_6_1.value;\n                        _d = false;\n                        const { flags, data } = _c;\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            yield yield __await({ value: endSerialization.parse(data), end: true });\n                        }\n                        else {\n                            yield yield __await({ value: serialization.parse(data), end: false });\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_6.return)) yield __await(_b.call(iterable_6));\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            });\n        };\n    }\n    // code path always yields T\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_7, _b, _c;\n            try {\n                for (var _d = true, iterable_7 = __asyncValues(iterable), iterable_7_1; iterable_7_1 = yield __await(iterable_7.next()), _a = iterable_7_1.done, !_a; _d = true) {\n                    _c = iterable_7_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    if (endStreamFlag !== undefined &&\n                        (flags & endStreamFlag) === endStreamFlag) {\n                        if (endSerialization === null) {\n                            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"unexpected end flag\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n                        }\n                        // skips end-of-stream envelope\n                        continue;\n                    }\n                    yield yield __await(serialization.parse(data));\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_7.return)) yield __await(_b.call(iterable_7));\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and compresses them if they are larger than compressMinBytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCompressEnvelope(compression, compressMinBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_8, _b, _c;\n            try {\n                for (var _d = true, iterable_8 = __asyncValues(iterable), iterable_8_1; iterable_8_1 = yield __await(iterable_8.next()), _a = iterable_8_1.done, !_a; _d = true) {\n                    _c = iterable_8_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await((0,_envelope_js__WEBPACK_IMPORTED_MODULE_2__.envelopeCompress)(env, compression, compressMinBytes)));\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_8.return)) yield __await(_b.call(iterable_8));\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and decompresses them using the given compression.\n *\n * The iterable raises an error if the decompressed payload of an enveloped\n * message is larger than readMaxBytes, or if no compression is provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformDecompressEnvelope(compression, readMaxBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_9, _b, _c;\n            try {\n                for (var _d = true, iterable_9 = __asyncValues(iterable), iterable_9_1; iterable_9_1 = yield __await(iterable_9.next()), _a = iterable_9_1.done, !_a; _d = true) {\n                    _c = iterable_9_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await((0,_envelope_js__WEBPACK_IMPORTED_MODULE_2__.envelopeDecompress)(env, compression, readMaxBytes)));\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_9.return)) yield __await(_b.call(iterable_9));\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes enveloped messages as a source,\n * and joins them into a stream of raw bytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformJoinEnvelopes() {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_10, _b, _c;\n            try {\n                for (var _d = true, iterable_10 = __asyncValues(iterable), iterable_10_1; iterable_10_1 = yield __await(iterable_10.next()), _a = iterable_10_1.done, !_a; _d = true) {\n                    _c = iterable_10_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    yield yield __await((0,_envelope_js__WEBPACK_IMPORTED_MODULE_2__.encodeEnvelope)(flags, data));\n                }\n            }\n            catch (e_10_1) { e_10 = { error: e_10_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_10.return)) yield __await(_b.call(iterable_10));\n                }\n                finally { if (e_10) throw e_10.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes raw bytes as a source, and splits\n * them into enveloped messages.\n *\n * The iterable raises an error\n * - if the payload of an enveloped message is larger than readMaxBytes,\n * - if the stream ended before an enveloped message fully arrived,\n * - or if the stream ended with extraneous data.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformSplitEnvelope(readMaxBytes) {\n    // append chunk to buffer, returning updated buffer\n    function append(buffer, chunk) {\n        const n = new Uint8Array(buffer.byteLength + chunk.byteLength);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        return n;\n    }\n    // tuple 0: envelope, or undefined if incomplete\n    // tuple 1: remainder of the buffer\n    function shiftEnvelope(buffer, header) {\n        if (buffer.byteLength < 5 + header.length) {\n            return [undefined, buffer];\n        }\n        return [\n            { flags: header.flags, data: buffer.subarray(5, 5 + header.length) },\n            buffer.subarray(5 + header.length),\n        ];\n    }\n    // undefined: header is incomplete\n    function peekHeader(buffer) {\n        if (buffer.byteLength < 5) {\n            return undefined;\n        }\n        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n        const length = view.getUint32(1); // 4 bytes message length\n        const flags = view.getUint8(0); // first byte is flags\n        return { length, flags };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_11, _b, _c;\n            let buffer = new Uint8Array(0);\n            try {\n                for (var _d = true, iterable_11 = __asyncValues(iterable), iterable_11_1; iterable_11_1 = yield __await(iterable_11.next()), _a = iterable_11_1.done, !_a; _d = true) {\n                    _c = iterable_11_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffer = append(buffer, chunk);\n                    for (;;) {\n                        const header = peekHeader(buffer);\n                        if (!header) {\n                            break;\n                        }\n                        (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_3__.assertReadMaxBytes)(readMaxBytes, header.length, true);\n                        let env;\n                        [env, buffer] = shiftEnvelope(buffer, header);\n                        if (!env) {\n                            break;\n                        }\n                        yield yield __await(env);\n                    }\n                }\n            }\n            catch (e_11_1) { e_11 = { error: e_11_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_11.return)) yield __await(_b.call(iterable_11));\n                }\n                finally { if (e_11) throw e_11.error; }\n            }\n            if (buffer.byteLength > 0) {\n                const header = peekHeader(buffer);\n                let message = \"protocol error: incomplete envelope\";\n                if (header) {\n                    message = `protocol error: promised ${header.length} bytes in enveloped message, got ${buffer.byteLength - 5} bytes`;\n                }\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(message, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n            }\n        });\n    };\n}\n/**\n * Reads all bytes from the source, and concatenates them to a single Uint8Array.\n *\n * Raises an error if:\n * - more than readMaxBytes are read\n * - lengthHint is a positive integer, but larger than readMaxBytes\n * - lengthHint is a positive integer, and the source contains more or less bytes\n *   than promised\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function readAllBytes(iterable, readMaxBytes, lengthHint) {\n    var _a, e_12, _b, _c, _d, e_13, _e, _f;\n    const [ok, hint] = parseLengthHint(lengthHint);\n    if (ok) {\n        if (hint > readMaxBytes) {\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_3__.assertReadMaxBytes)(readMaxBytes, hint, true);\n        }\n        const buffer = new Uint8Array(hint);\n        let offset = 0;\n        try {\n            for (var _g = true, iterable_12 = __asyncValues(iterable), iterable_12_1; iterable_12_1 = await iterable_12.next(), _a = iterable_12_1.done, !_a; _g = true) {\n                _c = iterable_12_1.value;\n                _g = false;\n                const chunk = _c;\n                if (offset + chunk.byteLength > hint) {\n                    throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`protocol error: promised ${hint} bytes, received ${offset + chunk.byteLength}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n                }\n                buffer.set(chunk, offset);\n                offset += chunk.byteLength;\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (!_g && !_a && (_b = iterable_12.return)) await _b.call(iterable_12);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n        if (offset < hint) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`protocol error: promised ${hint} bytes, received ${offset}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n        }\n        return buffer;\n    }\n    const chunks = [];\n    let count = 0;\n    try {\n        for (var _h = true, iterable_13 = __asyncValues(iterable), iterable_13_1; iterable_13_1 = await iterable_13.next(), _d = iterable_13_1.done, !_d; _h = true) {\n            _f = iterable_13_1.value;\n            _h = false;\n            const chunk = _f;\n            count += chunk.byteLength;\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_3__.assertReadMaxBytes)(readMaxBytes, count);\n            chunks.push(chunk);\n        }\n    }\n    catch (e_13_1) { e_13 = { error: e_13_1 }; }\n    finally {\n        try {\n            if (!_h && !_d && (_e = iterable_13.return)) await _e.call(iterable_13);\n        }\n        finally { if (e_13) throw e_13.error; }\n    }\n    const all = new Uint8Array(count);\n    let offset = 0;\n    for (let chunk = chunks.shift(); chunk; chunk = chunks.shift()) {\n        all.set(chunk, offset);\n        offset += chunk.byteLength;\n    }\n    return all;\n}\n// parse the lengthHint argument of readAllBytes()\nfunction parseLengthHint(lengthHint) {\n    if (lengthHint === undefined || lengthHint === null) {\n        return [false, 0];\n    }\n    const n = typeof lengthHint == \"string\" ? parseInt(lengthHint, 10) : lengthHint;\n    if (!Number.isSafeInteger(n) || n < 0) {\n        return [false, n];\n    }\n    return [true, n];\n}\n/**\n * Wait for the first element of an iterable without modifying the iterable.\n * This consumes the first element, but pushes it back on the stack.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function untilFirst(iterable) {\n    const it = iterable[Symbol.asyncIterator]();\n    let first = await it.next();\n    return {\n        [Symbol.asyncIterator]() {\n            const w = {\n                async next() {\n                    if (first !== null) {\n                        const n = first;\n                        first = null;\n                        return n;\n                    }\n                    return await it.next();\n                },\n            };\n            if (it.throw !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- can't handle mutated object sensibly\n                w.throw = (e) => it.throw(e);\n            }\n            if (it.return !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-explicit-any -- can't handle mutated object sensibly\n                w.return = (value) => it.return(value);\n            }\n            return w;\n        },\n    };\n}\n/**\n * Wrap the given iterable and return an iterable with an abort() method.\n *\n * This function exists purely for convenience. Where one would typically have\n * to access the iterator directly, advance through all elements, and call\n * AsyncIterator.throw() to notify the upstream iterable, this function allows\n * to use convenient for-await loops and still notify the upstream iterable:\n *\n * ```ts\n * const abortable = makeIterableAbortable(iterable);\n * for await (const ele of abortable) {\n *   await abortable.abort(\"ERR\");\n * }\n * ```\n * There are a couple of limitations of this function:\n * - the given async iterable must implement throw\n * - the async iterable cannot be re-use\n * - if source catches errors and yields values for them, they are ignored, and\n *   the source may still dangle\n *\n * There are four possible ways an async function* can handle yield errors:\n * 1. don't catch errors at all - Abortable.abort() will resolve \"rethrown\"\n * 2. catch errors and rethrow - Abortable.abort() will resolve \"rethrown\"\n * 3. catch errors and return - Abortable.abort() will resolve \"completed\"\n * 4. catch errors and yield a value - Abortable.abort() will resolve \"caught\"\n *\n * Note that catching errors and yielding a value is problematic, and it should\n * be documented that this may leave the source in a dangling state.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction makeIterableAbortable(iterable) {\n    const innerCandidate = iterable[Symbol.asyncIterator]();\n    if (innerCandidate.throw === undefined) {\n        throw new Error(\"AsyncIterable does not implement throw\");\n    }\n    const inner = innerCandidate;\n    let aborted;\n    let resultPromise;\n    let it = {\n        next() {\n            resultPromise = inner.next().finally(() => {\n                resultPromise = undefined;\n            });\n            return resultPromise;\n        },\n        throw(e) {\n            return inner.throw(e);\n        },\n    };\n    if (innerCandidate.return !== undefined) {\n        it = Object.assign(Object.assign({}, it), { return(value) {\n                return inner.return(value);\n            } });\n    }\n    let used = false;\n    return {\n        abort(reason) {\n            if (aborted) {\n                return aborted.state;\n            }\n            const f = () => {\n                return inner.throw(reason).then((r) => (r.done === true ? \"completed\" : \"caught\"), () => \"rethrown\");\n            };\n            if (resultPromise) {\n                aborted = { reason, state: resultPromise.then(f, f) };\n                return aborted.state;\n            }\n            aborted = { reason, state: f() };\n            return aborted.state;\n        },\n        [Symbol.asyncIterator]() {\n            if (used) {\n                throw new Error(\"AsyncIterable cannot be re-used\");\n            }\n            used = true;\n            return it;\n        },\n    };\n}\n/**\n * Create a new WritableIterable.\n */\nfunction createWritableIterable() {\n    // We start with two queues to capture the read and write attempts.\n    //\n    // The writes and reads each check of their counterpart is\n    // already available and either interact/add themselves to the queue.\n    const readQueue = [];\n    const writeQueue = [];\n    let err = undefined;\n    let nextResolve;\n    let nextReject;\n    let nextPromise = new Promise((resolve, reject) => {\n        nextResolve = resolve;\n        nextReject = reject;\n    });\n    let closed = false;\n    // drain the readQueue in case of error/writer is closed by sending a\n    // done result.\n    function drain() {\n        for (const next of readQueue.splice(0, readQueue.length)) {\n            next({ done: true, value: undefined });\n        }\n    }\n    return {\n        close() {\n            closed = true;\n            drain();\n        },\n        async write(payload) {\n            if (closed) {\n                throw err !== null && err !== void 0 ? err : new Error(\"cannot write, WritableIterable already closed\");\n            }\n            const read = readQueue.shift();\n            if (read === undefined) {\n                // We didn't find a pending read so we add the payload to the write queue.\n                writeQueue.push(payload);\n            }\n            else {\n                // We found a pending read so we respond with the payload.\n                read({ done: false, value: payload });\n                if (readQueue.length > 0) {\n                    // If there are more in the read queue we can mark the write as complete.\n                    // as the error reporting is not guaranteed to be sequential and therefore cannot\n                    // to linked to a specific write.\n                    return;\n                }\n            }\n            // We await the next call for as many times as there are items in the queue + 1\n            //\n            // If there are no items in the write queue that means write happened and we just have\n            // to wait for one more call likewise if we are the nth write in the queue we\n            // have to wait for n writes to complete and one more.\n            const limit = writeQueue.length + 1;\n            for (let i = 0; i < limit; i++) {\n                await nextPromise;\n            }\n        },\n        [Symbol.asyncIterator]() {\n            return {\n                next() {\n                    // Resolve the nextPromise to indicate\n                    // pending writes that a read attempt has been made\n                    // after their write.\n                    //\n                    // We also need to reset the promise for future writes.\n                    nextResolve();\n                    nextPromise = new Promise((resolve, reject) => {\n                        nextResolve = resolve;\n                        nextReject = reject;\n                    });\n                    const write = writeQueue.shift();\n                    if (write !== undefined) {\n                        // We found a pending write so response with the payload.\n                        return Promise.resolve({ done: false, value: write });\n                    }\n                    if (closed) {\n                        return Promise.resolve({ done: true, value: undefined });\n                    }\n                    // We return a promise immediately that is either resolved/rejected\n                    // as writes happen.\n                    let readResolve;\n                    const readPromise = new Promise((resolve) => (readResolve = resolve));\n                    readQueue.push(readResolve); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                    return readPromise;\n                },\n                throw(throwErr) {\n                    err = throwErr;\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    // This will reject all pending writes.\n                    nextReject(err);\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n                return() {\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    // Resolve once for the write awaiting confirmation.\n                    nextResolve();\n                    // Reject all future writes.\n                    nextPromise = Promise.reject(new Error(\"cannot write, consumer called return\"));\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n            };\n        },\n    };\n}\n/**\n * Create an asynchronous iterable from an array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nfunction createAsyncIterable(items) {\n    return __asyncGenerator(this, arguments, function* createAsyncIterable_1() {\n        yield __await(yield* __asyncDelegator(__asyncValues(items)));\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2FzeW5jLWl0ZXJhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQUksSUFBSSxTQUFJO0FBQ2pDO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUksNEJBQTRCO0FBQ3ZELHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBO0FBQ0EsME1BQTBNLGNBQWM7QUFDeE4sOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBLHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQix1Q0FBdUMsa0JBQWtCO0FBQ3BJO0FBQ2tDO0FBQ2lCO0FBQ21DO0FBQ25DO0FBQzVDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFFQUFxRTtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw4RUFBOEU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsOEVBQThFO0FBQzFLO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBLGtEQUFrRCxnREFBZ0Q7QUFDbEc7QUFDQTtBQUNBLGtEQUFrRCw4Q0FBOEM7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkRBQVksd0JBQXdCLDBDQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4REFBZ0I7QUFDdEU7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDhFQUE4RTtBQUN0SztBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0VBQWtCO0FBQ3hFO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpRkFBaUY7QUFDM0s7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLHdDQUF3Qyw0REFBYztBQUN0RDtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUFrRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsd0NBQXdDO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsaUZBQWlGO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGVBQWUsa0NBQWtDLHVCQUF1QjtBQUNsSTtBQUNBLDBCQUEwQiwyREFBWSxVQUFVLDBDQUFJO0FBQ3BEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHdFQUF3RTtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBWSw2QkFBNkIsTUFBTSxrQkFBa0IsMEJBQTBCLEdBQUcsMENBQUk7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVksNkJBQTZCLE1BQU0sa0JBQWtCLE9BQU8sR0FBRywwQ0FBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysd0VBQXdFO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTtBQUNBO0FBQ0EsaURBQWlELDhCQUE4QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2FzeW5jLWl0ZXJhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbnZhciBfX2FzeW5jRGVsZWdhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jRGVsZWdhdG9yKSB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBpLCBwO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn07XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVFbnZlbG9wZSwgZW52ZWxvcGVDb21wcmVzcywgZW52ZWxvcGVEZWNvbXByZXNzLCB9IGZyb20gXCIuL2VudmVsb3BlLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRSZWFkTWF4Qnl0ZXMgfSBmcm9tIFwiLi9saW1pdC1pby5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBpcGVUbyhzb3VyY2UsIC4uLnJlc3QpIHtcbiAgICBjb25zdCBbdHJhbnNmb3Jtcywgc2luaywgb3B0XSA9IHBpY2tUcmFuc2Zvcm1zQW5kU2luayhyZXN0KTtcbiAgICBsZXQgaXRlcmFibGUgPSBzb3VyY2U7XG4gICAgbGV0IGFib3J0YWJsZTtcbiAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5wcm9wYWdhdGVEb3duU3RyZWFtRXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYWJvcnRhYmxlID0gbWFrZUl0ZXJhYmxlQWJvcnRhYmxlKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpdGVyYWJsZSA9IHBpcGUoaXRlcmFibGUsIC4uLnRyYW5zZm9ybXMsIHsgcHJvcGFnYXRlRG93blN0cmVhbUVycm9yOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gc2luayhpdGVyYWJsZSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAoYWJvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRhYmxlLmFib3J0KHJlYXNvbikudGhlbigoKSA9PiBQcm9taXNlLnJlamVjdChyZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbn1cbi8vIHBpY2sgdHJhbnNmb3JtcywgdGhlIHNpbmssIGFuZCBvcHRpb25zIGZyb20gdGhlIHBpcGVUbygpIHJlc3QgcGFyYW1ldGVyXG5mdW5jdGlvbiBwaWNrVHJhbnNmb3Jtc0FuZFNpbmsocmVzdCkge1xuICAgIGxldCBvcHQ7XG4gICAgaWYgKHR5cGVvZiByZXN0W3Jlc3QubGVuZ3RoIC0gMV0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdCA9IHJlc3QucG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IHNpbmsgPSByZXN0LnBvcCgpO1xuICAgIHJldHVybiBbcmVzdCwgc2luaywgb3B0XTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlU2luayB0aGF0IGNvbmNhdGVuYXRlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgaW5wdXQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5rQWxsKCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzEgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMV8xOyBpdGVyYWJsZV8xXzEgPSBhd2FpdCBpdGVyYWJsZV8xLm5leHQoKSwgX2EgPSBpdGVyYWJsZV8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgYWxsLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xLnJldHVybikpIGF3YWl0IF9iLmNhbGwoaXRlcmFibGVfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVTaW5rIHRoYXQgY29uY2F0ZW5hdGVzIGFsbCBjaHVua3MgZnJvbSB0aGUgaW5wdXQgaW50b1xuICogYSBzaW5nbGUgVWludDhBcnJheS5cbiAqXG4gKiBUaGUgaXRlcmFibGUgcmFpc2VzIGFuIGVycm9yIGlmIHRoZSBtb3JlIHRoYW4gcmVhZE1heEJ5dGVzIGFyZSByZWFkLlxuICpcbiAqIEFuIG9wdGlvbmFsIGxlbmd0aCBoaW50IGNhbiBiZSBwcm92aWRlZCB0byBvcHRpbWl6ZSBhbGxvY2F0aW9uIGFuZCB2YWxpZGF0aW9uLlxuICogSWYgbW9yZSBvciBsZXNzIGJ5dGVzIGFyZSBwcmVzZW50IGluIHRoZSBzb3VyY2UgdGhhdCB0aGUgbGVuZ3RoIGhpbnQgaW5kaWNhdGVzLFxuICogYW5kIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBpdCBpcyBpZ25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lua0FsbEJ5dGVzKHJlYWRNYXhCeXRlcywgbGVuZ3RoSGludCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRBbGxCeXRlcyhpdGVyYWJsZSwgcmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpcGUoc291cmNlLCAuLi5yZXN0KSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcGlwZV8xKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IFt0cmFuc2Zvcm1zLCBvcHRdID0gcGlja1RyYW5zZm9ybXMocmVzdCk7XG4gICAgICAgIGxldCBhYm9ydGFibGU7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ID0gc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICBjb25zdCBjYWNoZWRTb3VyY2UgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VJdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpdGVyYWJsZSA9IGNhY2hlZFNvdXJjZTtcbiAgICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQucHJvcGFnYXRlRG93blN0cmVhbUVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaXRlcmFibGUgPSBhYm9ydGFibGUgPSBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICBpdGVyYWJsZSA9IHQoaXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoci5kb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWFib3J0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19hd2FpdChhYm9ydGFibGUuYWJvcnQoZSkpOyAvLyBwcm9wYWdhdGUgZG93bnN0cmVhbSBlcnJvciB0byB0aGUgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQucHJvcGFnYXRlRG93blN0cmVhbUVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgcmV0dXJuIG9uIHRoZSBzb3VyY2UgaXRlcmFibGUgdG8gaW5kaWNhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIHdpbGwgbm8gbG9uZ2VyIGNvbnN1bWUgaXQgYW5kIGl0IHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYW55IGFsbG9jYXRlZCByZXNvdXJjZXMuXG4gICAgICAgICAgICAgICAgKF9hID0gc291cmNlSXQucmV0dXJuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzb3VyY2VJdCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuY2F1Z2h0IHByb21pc2VzIGFyZSB0aHJvd24gYXQgc29tZXRpbWUvc29tZXdoZXJlIGJ5IHRoZSBldmVudCBsb29wLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBlcnJvciBpcyBjYXVnaHQgYW5kIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBpY2tUcmFuc2Zvcm1zKHJlc3QpIHtcbiAgICBsZXQgb3B0O1xuICAgIGlmICh0eXBlb2YgcmVzdFtyZXN0Lmxlbmd0aCAtIDFdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvcHQgPSByZXN0LnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3QsIG9wdF07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IGNhdGNoZXMgYW55IGVycm9yIGZyb20gdGhlIGlucHV0LCBhbmRcbiAqIHBhc3NlcyBpdCB0byB0aGUgZ2l2ZW4gY2F0Y2hFcnJvciBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgY2F0Y2hFcnJvciBmdW5jdGlvbiBtYXkgcmV0dXJuIGEgZmluYWwgdmFsdWUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1DYXRjaChjYXRjaEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB3ZSBkZWxpYmVyYXRlIGF2b2lkIGEgZm9yLWF3YWl0IGxvb3AgYmVjYXVzZSB3ZSBvbmx5IHdhbnQgdG8gY2F0Y2ggdXBzdHJlYW1cbiAgICAgICAgICAgIC8vIGVycm9ycywgbm90IGRvd25zdHJlYW0gZXJyb3JzICh5aWVsZCkuXG4gICAgICAgICAgICBjb25zdCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCByO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSB5aWVsZCBfX2F3YWl0KGl0Lm5leHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdWdodCA9IHlpZWxkIF9fYXdhaXQoY2F0Y2hFcnJvcihlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXVnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjYXVnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5kb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCBjYXRjaGVzIGFueSBlcnJvciBmcm9tIHRoZSBpbnB1dCwgYW5kXG4gKiBwYXNzZXMgaXQgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uLiBVbmxpa2UgdHJhbnNmb3JtQ2F0Y2goKSwgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gKiBpcyBhbHNvIGNhbGxlZCB3aGVuIG5vIGVycm9yIGlzIHJhaXNlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNhdGNoRmluYWxseShjYXRjaEZpbmFsbHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRlbGliZXJhdGUgYXZvaWQgYSBmb3ItYXdhaXQgbG9vcCBiZWNhdXNlIHdlIG9ubHkgd2FudCB0byBjYXRjaCB1cHN0cmVhbVxuICAgICAgICAgICAgLy8gZXJyb3JzLCBub3QgZG93bnN0cmVhbSBlcnJvcnMgKHlpZWxkKS5cbiAgICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgICBjb25zdCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCByO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSB5aWVsZCBfX2F3YWl0KGl0Lm5leHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5kb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2F1Z2h0ID0geWllbGQgX19hd2FpdChjYXRjaEZpbmFsbHkoZXJyKSk7XG4gICAgICAgICAgICBpZiAoY2F1Z2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNhdWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IGFwcGVuZHMgYSB2YWx1ZS5cbiAqXG4gKiBUaGUgZWxlbWVudCB0byBhcHBlbmQgaXMgcHJvdmlkZWQgYnkgYSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqIHVuZGVmaW5lZCwgbm8gZWxlbWVudCBpcyBhcHBlbmRlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUFwcGVuZChwcm92aWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzIgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMl8xOyBpdGVyYWJsZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzIubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8yLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZCA9IHlpZWxkIF9fYXdhaXQocHJvdmlkZSgpKTtcbiAgICAgICAgICAgIGlmIChhcHBlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoYXBwZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgcHJlcGVuZHMgYW4gZWxlbWVudC5cbiAqXG4gKiBUaGUgZWxlbWVudCB0byBwcmVwZW5kIGlzIHByb3ZpZGVkIGJ5IGEgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiB1bmRlZmluZWQsIG5vIGVsZW1lbnQgaXMgYXBwZW5kZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1QcmVwZW5kKHByb3ZpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBwcmVwZW5kID0geWllbGQgX19hd2FpdChwcm92aWRlKCkpO1xuICAgICAgICAgICAgaWYgKHByZXBlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocHJlcGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfMyA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8zXzE7IGl0ZXJhYmxlXzNfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfMy5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzNfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzMucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCByZWFkcyBhbGwgYnl0ZXMgZnJvbSB0aGUgaW5wdXQsIGFuZFxuICogY29uY2F0ZW5hdGVzIHRoZW0gdG8gYSBzaW5nbGUgVWludDhBcnJheS5cbiAqXG4gKiBUaGUgaXRlcmFibGUgcmFpc2VzIGFuIGVycm9yIGlmIHRoZSBtb3JlIHRoYW4gcmVhZE1heEJ5dGVzIGFyZSByZWFkLlxuICpcbiAqIEFuIG9wdGlvbmFsIGxlbmd0aCBoaW50IGNhbiBiZSBwcm92aWRlZCB0byBvcHRpbWl6ZSBhbGxvY2F0aW9uIGFuZCB2YWxpZGF0aW9uLlxuICogSWYgbW9yZSBvciBsZXNzIGJ5dGVzIGFyZSBwcmVzZW50IGluIHRoZSBzb3VyY2UgdGhhdCB0aGUgbGVuZ3RoIGhpbnQgaW5kaWNhdGVzLFxuICogYW5kIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqIElmIHRoZSBsZW5ndGggaGludCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBpdCBpcyBpZ25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUmVhZEFsbEJ5dGVzKHJlYWRNYXhCeXRlcywgbGVuZ3RoSGludCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZCBfX2F3YWl0KHJlYWRBbGxCeXRlcyhpdGVyYWJsZSwgcmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVNlcmlhbGl6ZUVudmVsb3BlKHNlcmlhbGl6YXRpb24sIGVuZFN0cmVhbUZsYWcsIGVuZFNlcmlhbGl6YXRpb24pIHtcbiAgICBpZiAoZW5kU3RyZWFtRmxhZyA9PT0gdW5kZWZpbmVkIHx8IGVuZFNlcmlhbGl6YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBlXzQsIF9iLCBfYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzQgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfNF8xOyBpdGVyYWJsZV80XzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzQubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV80XzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfNF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gc2VyaWFsaXphdGlvbi5zZXJpYWxpemUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IGZsYWdzOiAwLCBkYXRhIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV80LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV80KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV81LCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfNSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV81XzE7IGl0ZXJhYmxlXzVfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfNS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzVfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzVfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gZmxhZ3MgfCBlbmRTdHJlYW1GbGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGVuZFNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGNodW5rLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzZXJpYWxpemF0aW9uLnNlcmlhbGl6ZShjaHVuay52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IGZsYWdzLCBkYXRhIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV81LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV81KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1QYXJzZUVudmVsb3BlKHNlcmlhbGl6YXRpb24sIGVuZFN0cmVhbUZsYWcsIGVuZFNlcmlhbGl6YXRpb24pIHtcbiAgICAvLyBjb2RlIHBhdGggYWx3YXlzIHlpZWxkcyBQYXJzZWRFbnZlbG9wZWRNZXNzYWdlPFQsIEU+XG4gICAgaWYgKGVuZFNlcmlhbGl6YXRpb24gJiYgZW5kU3RyZWFtRmxhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfNiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfNiA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV82XzE7IGl0ZXJhYmxlXzZfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfNi5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzZfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV82XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmbGFncywgZGF0YSB9ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgZW5kU3RyZWFtRmxhZykgPT09IGVuZFN0cmVhbUZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHsgdmFsdWU6IGVuZFNlcmlhbGl6YXRpb24ucGFyc2UoZGF0YSksIGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeyB2YWx1ZTogc2VyaWFsaXphdGlvbi5wYXJzZShkYXRhKSwgZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfNi5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfNikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gY29kZSBwYXRoIGFsd2F5cyB5aWVsZHMgVFxuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzcsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV83ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzdfMTsgaXRlcmFibGVfN18xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV83Lm5leHQoKSksIF9hID0gaXRlcmFibGVfN18xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfN18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsYWdzLCBkYXRhIH0gPSBfYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFN0cmVhbUZsYWcgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgZW5kU3RyZWFtRmxhZykgPT09IGVuZFN0cmVhbUZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRTZXJpYWxpemF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihcInVuZXhwZWN0ZWQgZW5kIGZsYWdcIiwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcHMgZW5kLW9mLXN0cmVhbSBlbnZlbG9wZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChzZXJpYWxpemF0aW9uLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV83XzEpIHsgZV83ID0geyBlcnJvcjogZV83XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfNy5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfNykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNykgdGhyb3cgZV83LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHRha2VzIGVudmVsb3BlZCBtZXNzYWdlcyBhcyBhIHNvdXJjZSxcbiAqIGFuZCBjb21wcmVzc2VzIHRoZW0gaWYgdGhleSBhcmUgbGFyZ2VyIHRoYW4gY29tcHJlc3NNaW5CeXRlcy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNvbXByZXNzRW52ZWxvcGUoY29tcHJlc3Npb24sIGNvbXByZXNzTWluQnl0ZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV84LCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfOCA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV84XzE7IGl0ZXJhYmxlXzhfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfOC5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzhfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzhfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW52ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeWllbGQgX19hd2FpdChlbnZlbG9wZUNvbXByZXNzKGVudiwgY29tcHJlc3Npb24sIGNvbXByZXNzTWluQnl0ZXMpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfOF8xKSB7IGVfOCA9IHsgZXJyb3I6IGVfOF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzgucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCB0YWtlcyBlbnZlbG9wZWQgbWVzc2FnZXMgYXMgYSBzb3VyY2UsXG4gKiBhbmQgZGVjb21wcmVzc2VzIHRoZW0gdXNpbmcgdGhlIGdpdmVuIGNvbXByZXNzaW9uLlxuICpcbiAqIFRoZSBpdGVyYWJsZSByYWlzZXMgYW4gZXJyb3IgaWYgdGhlIGRlY29tcHJlc3NlZCBwYXlsb2FkIG9mIGFuIGVudmVsb3BlZFxuICogbWVzc2FnZSBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsIG9yIGlmIG5vIGNvbXByZXNzaW9uIGlzIHByb3ZpZGVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRGVjb21wcmVzc0VudmVsb3BlKGNvbXByZXNzaW9uLCByZWFkTWF4Qnl0ZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV85LCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfOSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV85XzE7IGl0ZXJhYmxlXzlfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfOS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzlfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzlfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW52ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeWllbGQgX19hd2FpdChlbnZlbG9wZURlY29tcHJlc3MoZW52LCBjb21wcmVzc2lvbiwgcmVhZE1heEJ5dGVzKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzlfMSkgeyBlXzkgPSB7IGVycm9yOiBlXzlfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV85LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV85KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV85KSB0aHJvdyBlXzkuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCB0YWtlcyBlbnZlbG9wZWQgbWVzc2FnZXMgYXMgYSBzb3VyY2UsXG4gKiBhbmQgam9pbnMgdGhlbSBpbnRvIGEgc3RyZWFtIG9mIHJhdyBieXRlcy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUpvaW5FbnZlbG9wZXMoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMTAsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV8xMCA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xMF8xOyBpdGVyYWJsZV8xMF8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV8xMC5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzEwXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8xMF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsYWdzLCBkYXRhIH0gPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChlbmNvZGVFbnZlbG9wZShmbGFncywgZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzEwXzEpIHsgZV8xMCA9IHsgZXJyb3I6IGVfMTBfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xMC5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfMTApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEwKSB0aHJvdyBlXzEwLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgdGFrZXMgcmF3IGJ5dGVzIGFzIGEgc291cmNlLCBhbmQgc3BsaXRzXG4gKiB0aGVtIGludG8gZW52ZWxvcGVkIG1lc3NhZ2VzLlxuICpcbiAqIFRoZSBpdGVyYWJsZSByYWlzZXMgYW4gZXJyb3JcbiAqIC0gaWYgdGhlIHBheWxvYWQgb2YgYW4gZW52ZWxvcGVkIG1lc3NhZ2UgaXMgbGFyZ2VyIHRoYW4gcmVhZE1heEJ5dGVzLFxuICogLSBpZiB0aGUgc3RyZWFtIGVuZGVkIGJlZm9yZSBhbiBlbnZlbG9wZWQgbWVzc2FnZSBmdWxseSBhcnJpdmVkLFxuICogLSBvciBpZiB0aGUgc3RyZWFtIGVuZGVkIHdpdGggZXh0cmFuZW91cyBkYXRhLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtU3BsaXRFbnZlbG9wZShyZWFkTWF4Qnl0ZXMpIHtcbiAgICAvLyBhcHBlbmQgY2h1bmsgdG8gYnVmZmVyLCByZXR1cm5pbmcgdXBkYXRlZCBidWZmZXJcbiAgICBmdW5jdGlvbiBhcHBlbmQoYnVmZmVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBuID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ5dGVMZW5ndGggKyBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbi5zZXQoYnVmZmVyKTtcbiAgICAgICAgbi5zZXQoY2h1bmssIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgLy8gdHVwbGUgMDogZW52ZWxvcGUsIG9yIHVuZGVmaW5lZCBpZiBpbmNvbXBsZXRlXG4gICAgLy8gdHVwbGUgMTogcmVtYWluZGVyIG9mIHRoZSBidWZmZXJcbiAgICBmdW5jdGlvbiBzaGlmdEVudmVsb3BlKGJ1ZmZlciwgaGVhZGVyKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA8IDUgKyBoZWFkZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgYnVmZmVyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBmbGFnczogaGVhZGVyLmZsYWdzLCBkYXRhOiBidWZmZXIuc3ViYXJyYXkoNSwgNSArIGhlYWRlci5sZW5ndGgpIH0sXG4gICAgICAgICAgICBidWZmZXIuc3ViYXJyYXkoNSArIGhlYWRlci5sZW5ndGgpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyB1bmRlZmluZWQ6IGhlYWRlciBpcyBpbmNvbXBsZXRlXG4gICAgZnVuY3Rpb24gcGVla0hlYWRlcihidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZpZXcuZ2V0VWludDMyKDEpOyAvLyA0IGJ5dGVzIG1lc3NhZ2UgbGVuZ3RoXG4gICAgICAgIGNvbnN0IGZsYWdzID0gdmlldy5nZXRVaW50OCgwKTsgLy8gZmlyc3QgYnl0ZSBpcyBmbGFnc1xuICAgICAgICByZXR1cm4geyBsZW5ndGgsIGZsYWdzIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzExLCBfYiwgX2M7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfMTEgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMTFfMTsgaXRlcmFibGVfMTFfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfMTEubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV8xMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfMTFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYXBwZW5kKGJ1ZmZlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBwZWVrSGVhZGVyKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0UmVhZE1heEJ5dGVzKHJlYWRNYXhCeXRlcywgaGVhZGVyLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW52O1xuICAgICAgICAgICAgICAgICAgICAgICAgW2VudiwgYnVmZmVyXSA9IHNoaWZ0RW52ZWxvcGUoYnVmZmVyLCBoZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoZW52KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzExXzEpIHsgZV8xMSA9IHsgZXJyb3I6IGVfMTFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfMTEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzExKSB0aHJvdyBlXzExLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gcGVla0hlYWRlcihidWZmZXIpO1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJwcm90b2NvbCBlcnJvcjogaW5jb21wbGV0ZSBlbnZlbG9wZVwiO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBwcm90b2NvbCBlcnJvcjogcHJvbWlzZWQgJHtoZWFkZXIubGVuZ3RofSBieXRlcyBpbiBlbnZlbG9wZWQgbWVzc2FnZSwgZ290ICR7YnVmZmVyLmJ5dGVMZW5ndGggLSA1fSBieXRlc2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IobWVzc2FnZSwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZWFkcyBhbGwgYnl0ZXMgZnJvbSB0aGUgc291cmNlLCBhbmQgY29uY2F0ZW5hdGVzIHRoZW0gdG8gYSBzaW5nbGUgVWludDhBcnJheS5cbiAqXG4gKiBSYWlzZXMgYW4gZXJyb3IgaWY6XG4gKiAtIG1vcmUgdGhhbiByZWFkTWF4Qnl0ZXMgYXJlIHJlYWRcbiAqIC0gbGVuZ3RoSGludCBpcyBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXNcbiAqIC0gbGVuZ3RoSGludCBpcyBhIHBvc2l0aXZlIGludGVnZXIsIGFuZCB0aGUgc291cmNlIGNvbnRhaW5zIG1vcmUgb3IgbGVzcyBieXRlc1xuICogICB0aGFuIHByb21pc2VkXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQWxsQnl0ZXMoaXRlcmFibGUsIHJlYWRNYXhCeXRlcywgbGVuZ3RoSGludCkge1xuICAgIHZhciBfYSwgZV8xMiwgX2IsIF9jLCBfZCwgZV8xMywgX2UsIF9mO1xuICAgIGNvbnN0IFtvaywgaGludF0gPSBwYXJzZUxlbmd0aEhpbnQobGVuZ3RoSGludCk7XG4gICAgaWYgKG9rKSB7XG4gICAgICAgIGlmIChoaW50ID4gcmVhZE1heEJ5dGVzKSB7XG4gICAgICAgICAgICBhc3NlcnRSZWFkTWF4Qnl0ZXMocmVhZE1heEJ5dGVzLCBoaW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShoaW50KTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZyA9IHRydWUsIGl0ZXJhYmxlXzEyID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEyXzE7IGl0ZXJhYmxlXzEyXzEgPSBhd2FpdCBpdGVyYWJsZV8xMi5uZXh0KCksIF9hID0gaXRlcmFibGVfMTJfMS5kb25lLCAhX2E7IF9nID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfMTJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIGNodW5rLmJ5dGVMZW5ndGggPiBoaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHByb3RvY29sIGVycm9yOiBwcm9taXNlZCAke2hpbnR9IGJ5dGVzLCByZWNlaXZlZCAke29mZnNldCArIGNodW5rLmJ5dGVMZW5ndGh9YCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzEyXzEpIHsgZV8xMiA9IHsgZXJyb3I6IGVfMTJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9nICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV8xMi5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKGl0ZXJhYmxlXzEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMikgdGhyb3cgZV8xMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPCBoaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBwcm90b2NvbCBlcnJvcjogcHJvbWlzZWQgJHtoaW50fSBieXRlcywgcmVjZWl2ZWQgJHtvZmZzZXR9YCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2ggPSB0cnVlLCBpdGVyYWJsZV8xMyA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xM18xOyBpdGVyYWJsZV8xM18xID0gYXdhaXQgaXRlcmFibGVfMTMubmV4dCgpLCBfZCA9IGl0ZXJhYmxlXzEzXzEuZG9uZSwgIV9kOyBfaCA9IHRydWUpIHtcbiAgICAgICAgICAgIF9mID0gaXRlcmFibGVfMTNfMS52YWx1ZTtcbiAgICAgICAgICAgIF9oID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IF9mO1xuICAgICAgICAgICAgY291bnQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhyZWFkTWF4Qnl0ZXMsIGNvdW50KTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xM18xKSB7IGVfMTMgPSB7IGVycm9yOiBlXzEzXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaCAmJiAhX2QgJiYgKF9lID0gaXRlcmFibGVfMTMucmV0dXJuKSkgYXdhaXQgX2UuY2FsbChpdGVyYWJsZV8xMyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEzKSB0aHJvdyBlXzEzLmVycm9yOyB9XG4gICAgfVxuICAgIGNvbnN0IGFsbCA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBjaHVuayA9IGNodW5rcy5zaGlmdCgpOyBjaHVuazsgY2h1bmsgPSBjaHVua3Muc2hpZnQoKSkge1xuICAgICAgICBhbGwuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGFsbDtcbn1cbi8vIHBhcnNlIHRoZSBsZW5ndGhIaW50IGFyZ3VtZW50IG9mIHJlYWRBbGxCeXRlcygpXG5mdW5jdGlvbiBwYXJzZUxlbmd0aEhpbnQobGVuZ3RoSGludCkge1xuICAgIGlmIChsZW5ndGhIaW50ID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoSGludCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHR5cGVvZiBsZW5ndGhIaW50ID09IFwic3RyaW5nXCIgPyBwYXJzZUludChsZW5ndGhIaW50LCAxMCkgOiBsZW5ndGhIaW50O1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgbl07XG4gICAgfVxuICAgIHJldHVybiBbdHJ1ZSwgbl07XG59XG4vKipcbiAqIFdhaXQgZm9yIHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGl0ZXJhYmxlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBpdGVyYWJsZS5cbiAqIFRoaXMgY29uc3VtZXMgdGhlIGZpcnN0IGVsZW1lbnQsIGJ1dCBwdXNoZXMgaXQgYmFjayBvbiB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1bnRpbEZpcnN0KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgZmlyc3QgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB7XG4gICAgICAgICAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGl0LnRocm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAtLSBjYW4ndCBoYW5kbGUgbXV0YXRlZCBvYmplY3Qgc2Vuc2libHlcbiAgICAgICAgICAgICAgICB3LnRocm93ID0gKGUpID0+IGl0LnRocm93KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0LnJldHVybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24sQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBjYW4ndCBoYW5kbGUgbXV0YXRlZCBvYmplY3Qgc2Vuc2libHlcbiAgICAgICAgICAgICAgICB3LnJldHVybiA9ICh2YWx1ZSkgPT4gaXQucmV0dXJuKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFdyYXAgdGhlIGdpdmVuIGl0ZXJhYmxlIGFuZCByZXR1cm4gYW4gaXRlcmFibGUgd2l0aCBhbiBhYm9ydCgpIG1ldGhvZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBwdXJlbHkgZm9yIGNvbnZlbmllbmNlLiBXaGVyZSBvbmUgd291bGQgdHlwaWNhbGx5IGhhdmVcbiAqIHRvIGFjY2VzcyB0aGUgaXRlcmF0b3IgZGlyZWN0bHksIGFkdmFuY2UgdGhyb3VnaCBhbGwgZWxlbWVudHMsIGFuZCBjYWxsXG4gKiBBc3luY0l0ZXJhdG9yLnRocm93KCkgdG8gbm90aWZ5IHRoZSB1cHN0cmVhbSBpdGVyYWJsZSwgdGhpcyBmdW5jdGlvbiBhbGxvd3NcbiAqIHRvIHVzZSBjb252ZW5pZW50IGZvci1hd2FpdCBsb29wcyBhbmQgc3RpbGwgbm90aWZ5IHRoZSB1cHN0cmVhbSBpdGVyYWJsZTpcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYWJvcnRhYmxlID0gbWFrZUl0ZXJhYmxlQWJvcnRhYmxlKGl0ZXJhYmxlKTtcbiAqIGZvciBhd2FpdCAoY29uc3QgZWxlIG9mIGFib3J0YWJsZSkge1xuICogICBhd2FpdCBhYm9ydGFibGUuYWJvcnQoXCJFUlJcIik7XG4gKiB9XG4gKiBgYGBcbiAqIFRoZXJlIGFyZSBhIGNvdXBsZSBvZiBsaW1pdGF0aW9ucyBvZiB0aGlzIGZ1bmN0aW9uOlxuICogLSB0aGUgZ2l2ZW4gYXN5bmMgaXRlcmFibGUgbXVzdCBpbXBsZW1lbnQgdGhyb3dcbiAqIC0gdGhlIGFzeW5jIGl0ZXJhYmxlIGNhbm5vdCBiZSByZS11c2VcbiAqIC0gaWYgc291cmNlIGNhdGNoZXMgZXJyb3JzIGFuZCB5aWVsZHMgdmFsdWVzIGZvciB0aGVtLCB0aGV5IGFyZSBpZ25vcmVkLCBhbmRcbiAqICAgdGhlIHNvdXJjZSBtYXkgc3RpbGwgZGFuZ2xlXG4gKlxuICogVGhlcmUgYXJlIGZvdXIgcG9zc2libGUgd2F5cyBhbiBhc3luYyBmdW5jdGlvbiogY2FuIGhhbmRsZSB5aWVsZCBlcnJvcnM6XG4gKiAxLiBkb24ndCBjYXRjaCBlcnJvcnMgYXQgYWxsIC0gQWJvcnRhYmxlLmFib3J0KCkgd2lsbCByZXNvbHZlIFwicmV0aHJvd25cIlxuICogMi4gY2F0Y2ggZXJyb3JzIGFuZCByZXRocm93IC0gQWJvcnRhYmxlLmFib3J0KCkgd2lsbCByZXNvbHZlIFwicmV0aHJvd25cIlxuICogMy4gY2F0Y2ggZXJyb3JzIGFuZCByZXR1cm4gLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJjb21wbGV0ZWRcIlxuICogNC4gY2F0Y2ggZXJyb3JzIGFuZCB5aWVsZCBhIHZhbHVlIC0gQWJvcnRhYmxlLmFib3J0KCkgd2lsbCByZXNvbHZlIFwiY2F1Z2h0XCJcbiAqXG4gKiBOb3RlIHRoYXQgY2F0Y2hpbmcgZXJyb3JzIGFuZCB5aWVsZGluZyBhIHZhbHVlIGlzIHByb2JsZW1hdGljLCBhbmQgaXQgc2hvdWxkXG4gKiBiZSBkb2N1bWVudGVkIHRoYXQgdGhpcyBtYXkgbGVhdmUgdGhlIHNvdXJjZSBpbiBhIGRhbmdsaW5nIHN0YXRlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUl0ZXJhYmxlQWJvcnRhYmxlKGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaW5uZXJDYW5kaWRhdGUgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBpZiAoaW5uZXJDYW5kaWRhdGUudGhyb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luY0l0ZXJhYmxlIGRvZXMgbm90IGltcGxlbWVudCB0aHJvd1wiKTtcbiAgICB9XG4gICAgY29uc3QgaW5uZXIgPSBpbm5lckNhbmRpZGF0ZTtcbiAgICBsZXQgYWJvcnRlZDtcbiAgICBsZXQgcmVzdWx0UHJvbWlzZTtcbiAgICBsZXQgaXQgPSB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICByZXN1bHRQcm9taXNlID0gaW5uZXIubmV4dCgpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICB0aHJvdyhlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5uZXIudGhyb3coZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoaW5uZXJDYW5kaWRhdGUucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0KSwgeyByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXIucmV0dXJuKHZhbHVlKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIGxldCB1c2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWJvcnQocmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhYm9ydGVkLnN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXIudGhyb3cocmVhc29uKS50aGVuKChyKSA9PiAoci5kb25lID09PSB0cnVlID8gXCJjb21wbGV0ZWRcIiA6IFwiY2F1Z2h0XCIpLCAoKSA9PiBcInJldGhyb3duXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRlZCA9IHsgcmVhc29uLCBzdGF0ZTogcmVzdWx0UHJvbWlzZS50aGVuKGYsIGYpIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0ZWQuc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhYm9ydGVkID0geyByZWFzb24sIHN0YXRlOiBmKCkgfTtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydGVkLnN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgaWYgKHVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luY0l0ZXJhYmxlIGNhbm5vdCBiZSByZS11c2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFdyaXRhYmxlSXRlcmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXcml0YWJsZUl0ZXJhYmxlKCkge1xuICAgIC8vIFdlIHN0YXJ0IHdpdGggdHdvIHF1ZXVlcyB0byBjYXB0dXJlIHRoZSByZWFkIGFuZCB3cml0ZSBhdHRlbXB0cy5cbiAgICAvL1xuICAgIC8vIFRoZSB3cml0ZXMgYW5kIHJlYWRzIGVhY2ggY2hlY2sgb2YgdGhlaXIgY291bnRlcnBhcnQgaXNcbiAgICAvLyBhbHJlYWR5IGF2YWlsYWJsZSBhbmQgZWl0aGVyIGludGVyYWN0L2FkZCB0aGVtc2VsdmVzIHRvIHRoZSBxdWV1ZS5cbiAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICBjb25zdCB3cml0ZVF1ZXVlID0gW107XG4gICAgbGV0IGVyciA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbmV4dFJlc29sdmU7XG4gICAgbGV0IG5leHRSZWplY3Q7XG4gICAgbGV0IG5leHRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBuZXh0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIG5leHRSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICAgIC8vIGRyYWluIHRoZSByZWFkUXVldWUgaW4gY2FzZSBvZiBlcnJvci93cml0ZXIgaXMgY2xvc2VkIGJ5IHNlbmRpbmcgYVxuICAgIC8vIGRvbmUgcmVzdWx0LlxuICAgIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5leHQgb2YgcmVhZFF1ZXVlLnNwbGljZSgwLCByZWFkUXVldWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgbmV4dCh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgZHJhaW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgd3JpdGUocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHZvaWQgMCA/IGVyciA6IG5ldyBFcnJvcihcImNhbm5vdCB3cml0ZSwgV3JpdGFibGVJdGVyYWJsZSBhbHJlYWR5IGNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIHBlbmRpbmcgcmVhZCBzbyB3ZSBhZGQgdGhlIHBheWxvYWQgdG8gdGhlIHdyaXRlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIHdyaXRlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgcGVuZGluZyByZWFkIHNvIHdlIHJlc3BvbmQgd2l0aCB0aGUgcGF5bG9hZC5cbiAgICAgICAgICAgICAgICByZWFkKHsgZG9uZTogZmFsc2UsIHZhbHVlOiBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBpbiB0aGUgcmVhZCBxdWV1ZSB3ZSBjYW4gbWFyayB0aGUgd3JpdGUgYXMgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBlcnJvciByZXBvcnRpbmcgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc2VxdWVudGlhbCBhbmQgdGhlcmVmb3JlIGNhbm5vdFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBsaW5rZWQgdG8gYSBzcGVjaWZpYyB3cml0ZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGF3YWl0IHRoZSBuZXh0IGNhbGwgZm9yIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGl0ZW1zIGluIHRoZSBxdWV1ZSArIDFcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaXRlbXMgaW4gdGhlIHdyaXRlIHF1ZXVlIHRoYXQgbWVhbnMgd3JpdGUgaGFwcGVuZWQgYW5kIHdlIGp1c3QgaGF2ZVxuICAgICAgICAgICAgLy8gdG8gd2FpdCBmb3Igb25lIG1vcmUgY2FsbCBsaWtld2lzZSBpZiB3ZSBhcmUgdGhlIG50aCB3cml0ZSBpbiB0aGUgcXVldWUgd2VcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gd2FpdCBmb3IgbiB3cml0ZXMgdG8gY29tcGxldGUgYW5kIG9uZSBtb3JlLlxuICAgICAgICAgICAgY29uc3QgbGltaXQgPSB3cml0ZVF1ZXVlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXh0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgbmV4dFByb21pc2UgdG8gaW5kaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyB3cml0ZXMgdGhhdCBhIHJlYWQgYXR0ZW1wdCBoYXMgYmVlbiBtYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZWlyIHdyaXRlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gcmVzZXQgdGhlIHByb21pc2UgZm9yIGZ1dHVyZSB3cml0ZXMuXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlID0gd3JpdGVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBwZW5kaW5nIHdyaXRlIHNvIHJlc3BvbnNlIHdpdGggdGhlIHBheWxvYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiB3cml0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZXR1cm4gYSBwcm9taXNlIGltbWVkaWF0ZWx5IHRoYXQgaXMgZWl0aGVyIHJlc29sdmVkL3JlamVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHdyaXRlcyBoYXBwZW4uXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWFkUmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKHJlYWRSZXNvbHZlID0gcmVzb2x2ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZWFkUXVldWUucHVzaChyZWFkUmVzb2x2ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJvdyh0aHJvd0Vycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSB0aHJvd0VycjtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVRdWV1ZS5zcGxpY2UoMCwgd3JpdGVRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgbmV4dFByb21pc2UgaXMgYWx3YXlzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJlamVjdCBhbGwgcGVuZGluZyB3cml0ZXMuXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXR1cm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUXVldWUuc3BsaWNlKDAsIHdyaXRlUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBvbmNlIGZvciB0aGUgd3JpdGUgYXdhaXRpbmcgY29uZmlybWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3QgYWxsIGZ1dHVyZSB3cml0ZXMuXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IHdyaXRlLCBjb25zdW1lciBjYWxsZWQgcmV0dXJuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gbWFrZSBzdXJlIHRoYXQgdGhlIG5leHRQcm9taXNlIGlzIGFsd2F5cyByZXNvbHZlZC5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhc3luY2hyb25vdXMgaXRlcmFibGUgZnJvbSBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZShpdGVtcykge1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGNyZWF0ZUFzeW5jSXRlcmFibGVfMSgpIHtcbiAgICAgICAgeWllbGQgX19hd2FpdCh5aWVsZCogX19hc3luY0RlbGVnYXRvcihfX2FzeW5jVmFsdWVzKGl0ZW1zKSkpO1xuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compressedFlag: () => (/* binding */ compressedFlag),\n/* harmony export */   compressionNegotiate: () => (/* binding */ compressionNegotiate)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * compressedFlag indicates that the data in a EnvelopedMessage is\n * compressed. It has the same meaning in the gRPC-Web, gRPC-HTTP2,\n * and Connect protocols.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst compressedFlag = 0b00000001;\n/**\n * Validates the request encoding and determines the accepted response encoding.\n *\n * Returns the request and response compression to use. If the client requested\n * an encoding that is not available, the returned object contains an error that\n * must be used for the response.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction compressionNegotiate(available, requested, // e.g. the value of the Grpc-Encoding header\naccepted, // e.g. the value of the Grpc-Accept-Encoding header\nheaderNameAcceptEncoding) {\n    let request = null;\n    let response = null;\n    let error = undefined;\n    if (requested !== null && requested !== \"identity\") {\n        const found = available.find((c) => c.name === requested);\n        if (found) {\n            request = found;\n        }\n        else {\n            // To comply with https://github.com/grpc/grpc/blob/master/doc/compression.md\n            // and the Connect protocol, we return code \"unimplemented\" and specify\n            // acceptable compression(s).\n            const acceptable = available.map((c) => c.name).join(\",\");\n            error = new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`unknown compression \"${requested}\": supported encodings are ${acceptable}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Unimplemented, {\n                [headerNameAcceptEncoding]: acceptable,\n            });\n        }\n    }\n    if (accepted === null || accepted === \"\") {\n        // Support asymmetric compression. This logic follows\n        // https://github.com/grpc/grpc/blob/master/doc/compression.md and common\n        // sense.\n        response = request;\n    }\n    else {\n        const acceptNames = accepted.split(\",\").map((n) => n.trim());\n        for (const name of acceptNames) {\n            const found = available.find((c) => c.name === name);\n            if (found) {\n                response = found;\n                break;\n            }\n        }\n    }\n    return { request, response, error };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2NvbXByZXNzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNqQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQVkseUJBQXlCLFVBQVUsNkJBQTZCLFdBQVcsR0FBRywwQ0FBSTtBQUN0SDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvY29tcHJlc3Npb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogY29tcHJlc3NlZEZsYWcgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaW4gYSBFbnZlbG9wZWRNZXNzYWdlIGlzXG4gKiBjb21wcmVzc2VkLiBJdCBoYXMgdGhlIHNhbWUgbWVhbmluZyBpbiB0aGUgZ1JQQy1XZWIsIGdSUEMtSFRUUDIsXG4gKiBhbmQgQ29ubmVjdCBwcm90b2NvbHMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wcmVzc2VkRmxhZyA9IDBiMDAwMDAwMDE7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgcmVxdWVzdCBlbmNvZGluZyBhbmQgZGV0ZXJtaW5lcyB0aGUgYWNjZXB0ZWQgcmVzcG9uc2UgZW5jb2RpbmcuXG4gKlxuICogUmV0dXJucyB0aGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgY29tcHJlc3Npb24gdG8gdXNlLiBJZiB0aGUgY2xpZW50IHJlcXVlc3RlZFxuICogYW4gZW5jb2RpbmcgdGhhdCBpcyBub3QgYXZhaWxhYmxlLCB0aGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIGFuIGVycm9yIHRoYXRcbiAqIG11c3QgYmUgdXNlZCBmb3IgdGhlIHJlc3BvbnNlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3Npb25OZWdvdGlhdGUoYXZhaWxhYmxlLCByZXF1ZXN0ZWQsIC8vIGUuZy4gdGhlIHZhbHVlIG9mIHRoZSBHcnBjLUVuY29kaW5nIGhlYWRlclxuYWNjZXB0ZWQsIC8vIGUuZy4gdGhlIHZhbHVlIG9mIHRoZSBHcnBjLUFjY2VwdC1FbmNvZGluZyBoZWFkZXJcbmhlYWRlck5hbWVBY2NlcHRFbmNvZGluZykge1xuICAgIGxldCByZXF1ZXN0ID0gbnVsbDtcbiAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICBpZiAocmVxdWVzdGVkICE9PSBudWxsICYmIHJlcXVlc3RlZCAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gYXZhaWxhYmxlLmZpbmQoKGMpID0+IGMubmFtZSA9PT0gcmVxdWVzdGVkKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUbyBjb21wbHkgd2l0aCBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9jb21wcmVzc2lvbi5tZFxuICAgICAgICAgICAgLy8gYW5kIHRoZSBDb25uZWN0IHByb3RvY29sLCB3ZSByZXR1cm4gY29kZSBcInVuaW1wbGVtZW50ZWRcIiBhbmQgc3BlY2lmeVxuICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSBjb21wcmVzc2lvbihzKS5cbiAgICAgICAgICAgIGNvbnN0IGFjY2VwdGFibGUgPSBhdmFpbGFibGUubWFwKChjKSA9PiBjLm5hbWUpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgQ29ubmVjdEVycm9yKGB1bmtub3duIGNvbXByZXNzaW9uIFwiJHtyZXF1ZXN0ZWR9XCI6IHN1cHBvcnRlZCBlbmNvZGluZ3MgYXJlICR7YWNjZXB0YWJsZX1gLCBDb2RlLlVuaW1wbGVtZW50ZWQsIHtcbiAgICAgICAgICAgICAgICBbaGVhZGVyTmFtZUFjY2VwdEVuY29kaW5nXTogYWNjZXB0YWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhY2NlcHRlZCA9PT0gbnVsbCB8fCBhY2NlcHRlZCA9PT0gXCJcIikge1xuICAgICAgICAvLyBTdXBwb3J0IGFzeW1tZXRyaWMgY29tcHJlc3Npb24uIFRoaXMgbG9naWMgZm9sbG93c1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9jb21wcmVzc2lvbi5tZCBhbmQgY29tbW9uXG4gICAgICAgIC8vIHNlbnNlLlxuICAgICAgICByZXNwb25zZSA9IHJlcXVlc3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhY2NlcHROYW1lcyA9IGFjY2VwdGVkLnNwbGl0KFwiLFwiKS5tYXAoKG4pID0+IG4udHJpbSgpKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFjY2VwdE5hbWVzKSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGF2YWlsYWJsZS5maW5kKChjKSA9PiBjLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZXF1ZXN0LCByZXNwb25zZSwgZXJyb3IgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMethodUrl: () => (/* binding */ createMethodUrl)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a URL for the given RPC. This simply adds the qualified\n * service name, a slash, and the method name to the path of the given\n * baseUrl.\n *\n * For example, the baseUri https://example.com and method \"Say\" from\n * the service example.ElizaService results in:\n * https://example.com/example.ElizaService/Say\n *\n * This format is used by the protocols Connect, gRPC and Twirp.\n *\n * Note that this function also accepts a protocol-relative baseUrl.\n * If given an empty string or \"/\" as a baseUrl, it returns just the\n * path.\n */\nfunction createMethodUrl(baseUrl, method) {\n    return baseUrl\n        .toString()\n        .replace(/\\/?$/, `/${method.parent.typeName}/${method.name}`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2NyZWF0ZS1tZXRob2QtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUIsR0FBRyxZQUFZO0FBQ25FIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2NyZWF0ZS1tZXRob2QtdXJsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhIFVSTCBmb3IgdGhlIGdpdmVuIFJQQy4gVGhpcyBzaW1wbHkgYWRkcyB0aGUgcXVhbGlmaWVkXG4gKiBzZXJ2aWNlIG5hbWUsIGEgc2xhc2gsIGFuZCB0aGUgbWV0aG9kIG5hbWUgdG8gdGhlIHBhdGggb2YgdGhlIGdpdmVuXG4gKiBiYXNlVXJsLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgYmFzZVVyaSBodHRwczovL2V4YW1wbGUuY29tIGFuZCBtZXRob2QgXCJTYXlcIiBmcm9tXG4gKiB0aGUgc2VydmljZSBleGFtcGxlLkVsaXphU2VydmljZSByZXN1bHRzIGluOlxuICogaHR0cHM6Ly9leGFtcGxlLmNvbS9leGFtcGxlLkVsaXphU2VydmljZS9TYXlcbiAqXG4gKiBUaGlzIGZvcm1hdCBpcyB1c2VkIGJ5IHRoZSBwcm90b2NvbHMgQ29ubmVjdCwgZ1JQQyBhbmQgVHdpcnAuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYWxzbyBhY2NlcHRzIGEgcHJvdG9jb2wtcmVsYXRpdmUgYmFzZVVybC5cbiAqIElmIGdpdmVuIGFuIGVtcHR5IHN0cmluZyBvciBcIi9cIiBhcyBhIGJhc2VVcmwsIGl0IHJldHVybnMganVzdCB0aGVcbiAqIHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRob2RVcmwoYmFzZVVybCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGJhc2VVcmxcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1xcLz8kLywgYC8ke21ldGhvZC5wYXJlbnQudHlwZU5hbWV9LyR7bWV0aG9kLm5hbWV9YCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js":
/*!************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEnvelopeReadableStream: () => (/* binding */ createEnvelopeReadableStream),\n/* harmony export */   encodeEnvelope: () => (/* binding */ encodeEnvelope),\n/* harmony export */   encodeEnvelopes: () => (/* binding */ encodeEnvelopes),\n/* harmony export */   envelopeCompress: () => (/* binding */ envelopeCompress),\n/* harmony export */   envelopeDecompress: () => (/* binding */ envelopeDecompress)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _compression_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Create a WHATWG ReadableStream of enveloped messages from a ReadableStream\n * of bytes.\n *\n * Ideally, this would simply be a TransformStream, but ReadableStream.pipeThrough\n * does not have the necessary availability at this time.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createEnvelopeReadableStream(stream) {\n    let reader;\n    let buffer = new Uint8Array(0);\n    function append(chunk) {\n        const n = new Uint8Array(buffer.length + chunk.length);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        buffer = n;\n    }\n    return new ReadableStream({\n        start() {\n            reader = stream.getReader();\n        },\n        async pull(controller) {\n            let header = undefined;\n            for (;;) {\n                if (header === undefined && buffer.byteLength >= 5) {\n                    let length = 0;\n                    for (let i = 1; i < 5; i++) {\n                        length = (length << 8) + buffer[i];\n                    }\n                    header = { flags: buffer[0], length };\n                }\n                if (header !== undefined && buffer.byteLength >= header.length + 5) {\n                    break;\n                }\n                const result = await reader.read();\n                if (result.done) {\n                    break;\n                }\n                append(result.value);\n            }\n            if (header === undefined) {\n                if (buffer.byteLength == 0) {\n                    controller.close();\n                    return;\n                }\n                controller.error(new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"premature end of stream\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.DataLoss));\n                return;\n            }\n            const data = buffer.subarray(5, 5 + header.length);\n            buffer = buffer.subarray(5 + header.length);\n            controller.enqueue({\n                flags: header.flags,\n                data,\n            });\n        },\n    });\n}\n/**\n * Compress an EnvelopedMessage.\n *\n * Raises Internal if an enveloped message is already compressed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function envelopeCompress(envelope, compression, compressMinBytes) {\n    let { flags, data } = envelope;\n    if ((flags & _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) === _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"invalid envelope, already compressed\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n    }\n    if (compression && data.byteLength >= compressMinBytes) {\n        data = await compression.compress(data);\n        flags = flags | _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Decompress an EnvelopedMessage.\n *\n * Raises InvalidArgument if an envelope is compressed, but compression is null.\n *\n * Relies on the provided Compression to raise ResourceExhausted if the\n * *decompressed* message size is larger than readMaxBytes. If the envelope is\n * not compressed, readMaxBytes is not honored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function envelopeDecompress(envelope, compression, readMaxBytes) {\n    let { flags, data } = envelope;\n    if ((flags & _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) === _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) {\n        if (!compression) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"received compressed envelope, but do not know how to decompress\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n        }\n        data = await compression.decompress(data, readMaxBytes);\n        flags = flags ^ _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Encode a single enveloped message.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction encodeEnvelope(flags, data) {\n    const bytes = new Uint8Array(data.length + 5);\n    bytes.set(data, 5);\n    const v = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    v.setUint8(0, flags); // first byte is flags\n    v.setUint32(1, data.length); // 4 bytes message length\n    return bytes;\n}\n/**\n * Encode a set of enveloped messages.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction encodeEnvelopes(...envelopes) {\n    const len = envelopes.reduce((previousValue, currentValue) => previousValue + currentValue.data.length + 5, 0);\n    const bytes = new Uint8Array(len);\n    const v = new DataView(bytes.buffer);\n    let offset = 0;\n    for (const e of envelopes) {\n        v.setUint8(offset, e.flags); // first byte is flags\n        v.setUint32(offset + 1, e.data.length); // 4 bytes message length\n        bytes.set(e.data, offset + 5);\n        offset += e.data.length + 5;\n    }\n    return bytes;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2VudmVsb3BlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDakI7QUFDZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUFZLDRCQUE0QiwwQ0FBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFVBQVUsY0FBYztBQUN4QixpQkFBaUIsMkRBQWMsTUFBTSwyREFBYztBQUNuRCxrQkFBa0IsMkRBQVkseUNBQXlDLDBDQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBYztBQUN0QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFVBQVUsY0FBYztBQUN4QixpQkFBaUIsMkRBQWMsTUFBTSwyREFBYztBQUNuRDtBQUNBLHNCQUFzQiwyREFBWSxvRUFBb0UsMENBQUk7QUFDMUc7QUFDQTtBQUNBLHdCQUF3QiwyREFBYztBQUN0QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvZW52ZWxvcGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbmltcG9ydCB7IGNvbXByZXNzZWRGbGFnIH0gZnJvbSBcIi4vY29tcHJlc3Npb24uanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgV0hBVFdHIFJlYWRhYmxlU3RyZWFtIG9mIGVudmVsb3BlZCBtZXNzYWdlcyBmcm9tIGEgUmVhZGFibGVTdHJlYW1cbiAqIG9mIGJ5dGVzLlxuICpcbiAqIElkZWFsbHksIHRoaXMgd291bGQgc2ltcGx5IGJlIGEgVHJhbnNmb3JtU3RyZWFtLCBidXQgUmVhZGFibGVTdHJlYW0ucGlwZVRocm91Z2hcbiAqIGRvZXMgbm90IGhhdmUgdGhlIG5lY2Vzc2FyeSBhdmFpbGFiaWxpdHkgYXQgdGhpcyB0aW1lLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW52ZWxvcGVSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICBsZXQgcmVhZGVyO1xuICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBmdW5jdGlvbiBhcHBlbmQoY2h1bmspIHtcbiAgICAgICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBuLnNldChidWZmZXIpO1xuICAgICAgICBuLnNldChjaHVuaywgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlciA9IG47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCAmJiBidWZmZXIuYnl0ZUxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSArIGJ1ZmZlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSB7IGZsYWdzOiBidWZmZXJbMF0sIGxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyICE9PSB1bmRlZmluZWQgJiYgYnVmZmVyLmJ5dGVMZW5ndGggPj0gaGVhZGVyLmxlbmd0aCArIDUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBlbmQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBDb25uZWN0RXJyb3IoXCJwcmVtYXR1cmUgZW5kIG9mIHN0cmVhbVwiLCBDb2RlLkRhdGFMb3NzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5zdWJhcnJheSg1LCA1ICsgaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoNSArIGhlYWRlci5sZW5ndGgpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICBmbGFnczogaGVhZGVyLmZsYWdzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3MgYW4gRW52ZWxvcGVkTWVzc2FnZS5cbiAqXG4gKiBSYWlzZXMgSW50ZXJuYWwgaWYgYW4gZW52ZWxvcGVkIG1lc3NhZ2UgaXMgYWxyZWFkeSBjb21wcmVzc2VkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW52ZWxvcGVDb21wcmVzcyhlbnZlbG9wZSwgY29tcHJlc3Npb24sIGNvbXByZXNzTWluQnl0ZXMpIHtcbiAgICBsZXQgeyBmbGFncywgZGF0YSB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKChmbGFncyAmIGNvbXByZXNzZWRGbGFnKSA9PT0gY29tcHJlc3NlZEZsYWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihcImludmFsaWQgZW52ZWxvcGUsIGFscmVhZHkgY29tcHJlc3NlZFwiLCBDb2RlLkludGVybmFsKTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzaW9uICYmIGRhdGEuYnl0ZUxlbmd0aCA+PSBjb21wcmVzc01pbkJ5dGVzKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBjb21wcmVzc2lvbi5jb21wcmVzcyhkYXRhKTtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyB8IGNvbXByZXNzZWRGbGFnO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhLCBmbGFncyB9O1xufVxuLyoqXG4gKiBEZWNvbXByZXNzIGFuIEVudmVsb3BlZE1lc3NhZ2UuXG4gKlxuICogUmFpc2VzIEludmFsaWRBcmd1bWVudCBpZiBhbiBlbnZlbG9wZSBpcyBjb21wcmVzc2VkLCBidXQgY29tcHJlc3Npb24gaXMgbnVsbC5cbiAqXG4gKiBSZWxpZXMgb24gdGhlIHByb3ZpZGVkIENvbXByZXNzaW9uIHRvIHJhaXNlIFJlc291cmNlRXhoYXVzdGVkIGlmIHRoZVxuICogKmRlY29tcHJlc3NlZCogbWVzc2FnZSBzaXplIGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcy4gSWYgdGhlIGVudmVsb3BlIGlzXG4gKiBub3QgY29tcHJlc3NlZCwgcmVhZE1heEJ5dGVzIGlzIG5vdCBob25vcmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW52ZWxvcGVEZWNvbXByZXNzKGVudmVsb3BlLCBjb21wcmVzc2lvbiwgcmVhZE1heEJ5dGVzKSB7XG4gICAgbGV0IHsgZmxhZ3MsIGRhdGEgfSA9IGVudmVsb3BlO1xuICAgIGlmICgoZmxhZ3MgJiBjb21wcmVzc2VkRmxhZykgPT09IGNvbXByZXNzZWRGbGFnKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoXCJyZWNlaXZlZCBjb21wcmVzc2VkIGVudmVsb3BlLCBidXQgZG8gbm90IGtub3cgaG93IHRvIGRlY29tcHJlc3NcIiwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGF3YWl0IGNvbXByZXNzaW9uLmRlY29tcHJlc3MoZGF0YSwgcmVhZE1heEJ5dGVzKTtcbiAgICAgICAgZmxhZ3MgPSBmbGFncyBeIGNvbXByZXNzZWRGbGFnO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhLCBmbGFncyB9O1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZW52ZWxvcGVkIG1lc3NhZ2UuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVFbnZlbG9wZShmbGFncywgZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyA1KTtcbiAgICBieXRlcy5zZXQoZGF0YSwgNSk7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIHYuc2V0VWludDgoMCwgZmxhZ3MpOyAvLyBmaXJzdCBieXRlIGlzIGZsYWdzXG4gICAgdi5zZXRVaW50MzIoMSwgZGF0YS5sZW5ndGgpOyAvLyA0IGJ5dGVzIG1lc3NhZ2UgbGVuZ3RoXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzZXQgb2YgZW52ZWxvcGVkIG1lc3NhZ2VzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRW52ZWxvcGVzKC4uLmVudmVsb3Blcykge1xuICAgIGNvbnN0IGxlbiA9IGVudmVsb3Blcy5yZWR1Y2UoKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkgPT4gcHJldmlvdXNWYWx1ZSArIGN1cnJlbnRWYWx1ZS5kYXRhLmxlbmd0aCArIDUsIDApO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBjb25zdCB2ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBlIG9mIGVudmVsb3Blcykge1xuICAgICAgICB2LnNldFVpbnQ4KG9mZnNldCwgZS5mbGFncyk7IC8vIGZpcnN0IGJ5dGUgaXMgZmxhZ3NcbiAgICAgICAgdi5zZXRVaW50MzIob2Zmc2V0ICsgMSwgZS5kYXRhLmxlbmd0aCk7IC8vIDQgYnl0ZXMgbWVzc2FnZSBsZW5ndGhcbiAgICAgICAgYnl0ZXMuc2V0KGUuZGF0YSwgb2Zmc2V0ICsgNSk7XG4gICAgICAgIG9mZnNldCArPSBlLmRhdGEubGVuZ3RoICsgNTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js":
/*!************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertReadMaxBytes: () => (/* binding */ assertReadMaxBytes),\n/* harmony export */   assertWriteMaxBytes: () => (/* binding */ assertWriteMaxBytes),\n/* harmony export */   validateReadWriteMaxBytes: () => (/* binding */ validateReadWriteMaxBytes)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * At most, allow ~4GiB to be received or sent per message.\n * zlib used by Node.js caps maxOutputLength at this value. It also happens to\n * be the maximum theoretical message size supported by protobuf-es.\n */\nconst maxReadMaxBytes = 0xffffffff;\nconst maxWriteMaxBytes = maxReadMaxBytes;\n/**\n * The default value for the compressMinBytes option. The CPU cost of compressing\n * very small messages usually isn't worth the small reduction in network I/O, so\n * the default value is 1 kibibyte.\n */\nconst defaultCompressMinBytes = 1024;\n/**\n * Asserts that the options writeMaxBytes, readMaxBytes, and compressMinBytes\n * are within sane limits, and returns default values where no value is\n * provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateReadWriteMaxBytes(readMaxBytes, writeMaxBytes, compressMinBytes) {\n    writeMaxBytes !== null && writeMaxBytes !== void 0 ? writeMaxBytes : (writeMaxBytes = maxWriteMaxBytes);\n    readMaxBytes !== null && readMaxBytes !== void 0 ? readMaxBytes : (readMaxBytes = maxReadMaxBytes);\n    compressMinBytes !== null && compressMinBytes !== void 0 ? compressMinBytes : (compressMinBytes = defaultCompressMinBytes);\n    if (writeMaxBytes < 1 || writeMaxBytes > maxWriteMaxBytes) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`writeMaxBytes ${writeMaxBytes} must be >= 1 and <= ${maxWriteMaxBytes}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n    }\n    if (readMaxBytes < 1 || readMaxBytes > maxReadMaxBytes) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`readMaxBytes ${readMaxBytes} must be >= 1 and <= ${maxReadMaxBytes}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n    }\n    return {\n        readMaxBytes,\n        writeMaxBytes,\n        compressMinBytes,\n    };\n}\n/**\n * Raise an error ResourceExhausted if more than writeMaxByte are written.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction assertWriteMaxBytes(writeMaxBytes, bytesWritten) {\n    if (bytesWritten > writeMaxBytes) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`message size ${bytesWritten} is larger than configured writeMaxBytes ${writeMaxBytes}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.ResourceExhausted);\n    }\n}\n/**\n * Raise an error ResourceExhausted if more than readMaxBytes are read.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction assertReadMaxBytes(readMaxBytes, bytesRead, totalSizeKnown = false) {\n    if (bytesRead > readMaxBytes) {\n        let message = `message size is larger than configured readMaxBytes ${readMaxBytes}`;\n        if (totalSizeKnown) {\n            message = `message size ${bytesRead} is larger than configured readMaxBytes ${readMaxBytes}`;\n        }\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(message, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.ResourceExhausted);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2xpbWl0LWlvLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDakI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQVksa0JBQWtCLGVBQWUsc0JBQXNCLGlCQUFpQixHQUFHLDBDQUFJO0FBQzdHO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQVksaUJBQWlCLGNBQWMsc0JBQXNCLGdCQUFnQixHQUFHLDBDQUFJO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsMkRBQVksaUJBQWlCLGNBQWMsMENBQTBDLGNBQWMsR0FBRywwQ0FBSTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw2RUFBNkUsYUFBYTtBQUMxRjtBQUNBLHNDQUFzQyxXQUFXLHlDQUF5QyxhQUFhO0FBQ3ZHO0FBQ0Esa0JBQWtCLDJEQUFZLFVBQVUsMENBQUk7QUFDNUM7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9saW1pdC1pby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuLyoqXG4gKiBBdCBtb3N0LCBhbGxvdyB+NEdpQiB0byBiZSByZWNlaXZlZCBvciBzZW50IHBlciBtZXNzYWdlLlxuICogemxpYiB1c2VkIGJ5IE5vZGUuanMgY2FwcyBtYXhPdXRwdXRMZW5ndGggYXQgdGhpcyB2YWx1ZS4gSXQgYWxzbyBoYXBwZW5zIHRvXG4gKiBiZSB0aGUgbWF4aW11bSB0aGVvcmV0aWNhbCBtZXNzYWdlIHNpemUgc3VwcG9ydGVkIGJ5IHByb3RvYnVmLWVzLlxuICovXG5jb25zdCBtYXhSZWFkTWF4Qnl0ZXMgPSAweGZmZmZmZmZmO1xuY29uc3QgbWF4V3JpdGVNYXhCeXRlcyA9IG1heFJlYWRNYXhCeXRlcztcbi8qKlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb21wcmVzc01pbkJ5dGVzIG9wdGlvbi4gVGhlIENQVSBjb3N0IG9mIGNvbXByZXNzaW5nXG4gKiB2ZXJ5IHNtYWxsIG1lc3NhZ2VzIHVzdWFsbHkgaXNuJ3Qgd29ydGggdGhlIHNtYWxsIHJlZHVjdGlvbiBpbiBuZXR3b3JrIEkvTywgc29cbiAqIHRoZSBkZWZhdWx0IHZhbHVlIGlzIDEga2liaWJ5dGUuXG4gKi9cbmNvbnN0IGRlZmF1bHRDb21wcmVzc01pbkJ5dGVzID0gMTAyNDtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBvcHRpb25zIHdyaXRlTWF4Qnl0ZXMsIHJlYWRNYXhCeXRlcywgYW5kIGNvbXByZXNzTWluQnl0ZXNcbiAqIGFyZSB3aXRoaW4gc2FuZSBsaW1pdHMsIGFuZCByZXR1cm5zIGRlZmF1bHQgdmFsdWVzIHdoZXJlIG5vIHZhbHVlIGlzXG4gKiBwcm92aWRlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVhZFdyaXRlTWF4Qnl0ZXMocmVhZE1heEJ5dGVzLCB3cml0ZU1heEJ5dGVzLCBjb21wcmVzc01pbkJ5dGVzKSB7XG4gICAgd3JpdGVNYXhCeXRlcyAhPT0gbnVsbCAmJiB3cml0ZU1heEJ5dGVzICE9PSB2b2lkIDAgPyB3cml0ZU1heEJ5dGVzIDogKHdyaXRlTWF4Qnl0ZXMgPSBtYXhXcml0ZU1heEJ5dGVzKTtcbiAgICByZWFkTWF4Qnl0ZXMgIT09IG51bGwgJiYgcmVhZE1heEJ5dGVzICE9PSB2b2lkIDAgPyByZWFkTWF4Qnl0ZXMgOiAocmVhZE1heEJ5dGVzID0gbWF4UmVhZE1heEJ5dGVzKTtcbiAgICBjb21wcmVzc01pbkJ5dGVzICE9PSBudWxsICYmIGNvbXByZXNzTWluQnl0ZXMgIT09IHZvaWQgMCA/IGNvbXByZXNzTWluQnl0ZXMgOiAoY29tcHJlc3NNaW5CeXRlcyA9IGRlZmF1bHRDb21wcmVzc01pbkJ5dGVzKTtcbiAgICBpZiAod3JpdGVNYXhCeXRlcyA8IDEgfHwgd3JpdGVNYXhCeXRlcyA+IG1heFdyaXRlTWF4Qnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgd3JpdGVNYXhCeXRlcyAke3dyaXRlTWF4Qnl0ZXN9IG11c3QgYmUgPj0gMSBhbmQgPD0gJHttYXhXcml0ZU1heEJ5dGVzfWAsIENvZGUuSW50ZXJuYWwpO1xuICAgIH1cbiAgICBpZiAocmVhZE1heEJ5dGVzIDwgMSB8fCByZWFkTWF4Qnl0ZXMgPiBtYXhSZWFkTWF4Qnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgcmVhZE1heEJ5dGVzICR7cmVhZE1heEJ5dGVzfSBtdXN0IGJlID49IDEgYW5kIDw9ICR7bWF4UmVhZE1heEJ5dGVzfWAsIENvZGUuSW50ZXJuYWwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkTWF4Qnl0ZXMsXG4gICAgICAgIHdyaXRlTWF4Qnl0ZXMsXG4gICAgICAgIGNvbXByZXNzTWluQnl0ZXMsXG4gICAgfTtcbn1cbi8qKlxuICogUmFpc2UgYW4gZXJyb3IgUmVzb3VyY2VFeGhhdXN0ZWQgaWYgbW9yZSB0aGFuIHdyaXRlTWF4Qnl0ZSBhcmUgd3JpdHRlbi5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFdyaXRlTWF4Qnl0ZXMod3JpdGVNYXhCeXRlcywgYnl0ZXNXcml0dGVuKSB7XG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA+IHdyaXRlTWF4Qnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgbWVzc2FnZSBzaXplICR7Ynl0ZXNXcml0dGVufSBpcyBsYXJnZXIgdGhhbiBjb25maWd1cmVkIHdyaXRlTWF4Qnl0ZXMgJHt3cml0ZU1heEJ5dGVzfWAsIENvZGUuUmVzb3VyY2VFeGhhdXN0ZWQpO1xuICAgIH1cbn1cbi8qKlxuICogUmFpc2UgYW4gZXJyb3IgUmVzb3VyY2VFeGhhdXN0ZWQgaWYgbW9yZSB0aGFuIHJlYWRNYXhCeXRlcyBhcmUgcmVhZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJlYWRNYXhCeXRlcyhyZWFkTWF4Qnl0ZXMsIGJ5dGVzUmVhZCwgdG90YWxTaXplS25vd24gPSBmYWxzZSkge1xuICAgIGlmIChieXRlc1JlYWQgPiByZWFkTWF4Qnl0ZXMpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgbWVzc2FnZSBzaXplIGlzIGxhcmdlciB0aGFuIGNvbmZpZ3VyZWQgcmVhZE1heEJ5dGVzICR7cmVhZE1heEJ5dGVzfWA7XG4gICAgICAgIGlmICh0b3RhbFNpemVLbm93bikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBtZXNzYWdlIHNpemUgJHtieXRlc1JlYWR9IGlzIGxhcmdlciB0aGFuIGNvbmZpZ3VyZWQgcmVhZE1heEJ5dGVzICR7cmVhZE1heEJ5dGVzfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihtZXNzYWdlLCBDb2RlLlJlc291cmNlRXhoYXVzdGVkKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeIterable: () => (/* binding */ normalizeIterable)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/create.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n *  Takes a partial protobuf messages of the\n *  specified message type as input, and returns full instances.\n */\nfunction normalize(desc, message) {\n    return (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__.create)(desc, message);\n}\n/**\n * Takes an AsyncIterable of partial protobuf messages of the\n * specified message type as input, and yields full instances.\n */\nfunction normalizeIterable(desc, input) {\n    function transform(result) {\n        if (result.done === true) {\n            return result;\n        }\n        return {\n            done: result.done,\n            value: normalize(desc, result.value),\n        };\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            const it = input[Symbol.asyncIterator]();\n            const res = {\n                next: () => it.next().then(transform),\n            };\n            if (it.throw !== undefined) {\n                res.throw = (e) => it.throw(e).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            if (it.return !== undefined) {\n                res.return = (v) => it.return(v).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            return res;\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL25vcm1hbGl6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVywwREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ub3JtYWxpemUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbi8qKlxuICogIFRha2VzIGEgcGFydGlhbCBwcm90b2J1ZiBtZXNzYWdlcyBvZiB0aGVcbiAqICBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlIGFzIGlucHV0LCBhbmQgcmV0dXJucyBmdWxsIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShkZXNjLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZShkZXNjLCBtZXNzYWdlKTtcbn1cbi8qKlxuICogVGFrZXMgYW4gQXN5bmNJdGVyYWJsZSBvZiBwYXJ0aWFsIHByb3RvYnVmIG1lc3NhZ2VzIG9mIHRoZVxuICogc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZSBhcyBpbnB1dCwgYW5kIHlpZWxkcyBmdWxsIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUl0ZXJhYmxlKGRlc2MsIGlucHV0KSB7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHJlc3VsdC5kb25lLFxuICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZShkZXNjLCByZXN1bHQudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgY29uc3QgaXQgPSBpbnB1dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoKSA9PiBpdC5uZXh0KCkudGhlbih0cmFuc2Zvcm0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpdC50aHJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzLnRocm93ID0gKGUpID0+IGl0LnRocm93KGUpLnRoZW4odHJhbnNmb3JtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMucmV0dXJuID0gKHYpID0+IGl0LnJldHVybih2KS50aGVuKHRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js":
/*!************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   runStreamingCall: () => (/* binding */ runStreamingCall),\n/* harmony export */   runUnaryCall: () => (/* binding */ runUnaryCall)\n/* harmony export */ });\n/* harmony import */ var _interceptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interceptor.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/interceptor.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signals.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js\");\n/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalize.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * Runs a unary method with the given interceptors. Note that this function\n * is only used when implementing a Transport.\n */\nfunction runUnaryCall(opt) {\n    const next = (0,_interceptor_js__WEBPACK_IMPORTED_MODULE_0__.applyInterceptors)(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: (0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalize)(opt.req.method.input, opt.req.message), signal });\n    return next(req).then((res) => {\n        done();\n        return res;\n    }, abort);\n}\n/**\n * Runs a server-streaming method with the given interceptors. Note that this\n * function is only used when implementing a Transport.\n */\nfunction runStreamingCall(opt) {\n    const next = (0,_interceptor_js__WEBPACK_IMPORTED_MODULE_0__.applyInterceptors)(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: (0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalizeIterable)(opt.req.method.input, opt.req.message), signal });\n    let doneCalled = false;\n    // Call return on the request iterable to indicate\n    // that we will no longer consume it and it should\n    // cleanup any allocated resources.\n    signal.addEventListener(\"abort\", function () {\n        var _a, _b;\n        const it = opt.req.message[Symbol.asyncIterator]();\n        // If the signal is aborted due to an error, we want to throw\n        // the error to the request iterator.\n        if (!doneCalled) {\n            (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, this.reason).catch(() => {\n                // throw returns a promise, which we don't care about.\n                //\n                // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                // this is to ensure error is caught and ignored.\n            });\n        }\n        (_b = it.return) === null || _b === void 0 ? void 0 : _b.call(it).catch(() => {\n            // return returns a promise, which we don't care about.\n            //\n            // Uncaught promises are thrown at sometime/somewhere by the event loop,\n            // this is to ensure error is caught and ignored.\n        });\n    });\n    return next(req).then((res) => {\n        return Object.assign(Object.assign({}, res), { message: {\n                [Symbol.asyncIterator]() {\n                    const it = res.message[Symbol.asyncIterator]();\n                    return {\n                        next() {\n                            return it.next().then((r) => {\n                                if (r.done == true) {\n                                    doneCalled = true;\n                                    done();\n                                }\n                                return r;\n                            }, abort);\n                        },\n                        // We deliberately omit throw/return.\n                    };\n                },\n            } });\n    }, abort);\n}\n/**\n * Create an AbortSignal for Transport implementations. The signal is available\n * in UnaryRequest and StreamingRequest, and is triggered when the call is\n * aborted (via a timeout or explicit cancellation), errored (e.g. when reading\n * an error from the server from the wire), or finished successfully.\n *\n * Transport implementations can pass the signal to HTTP clients to ensure that\n * there are no unused connections leak.\n *\n * Returns a tuple:\n * [0]: The signal, which is also aborted if the optional deadline is reached.\n * [1]: Function to call if the Transport encountered an error.\n * [2]: Function to call if the Transport finished without an error.\n */\nfunction setupSignal(opt) {\n    const { signal, cleanup } = (0,_signals_js__WEBPACK_IMPORTED_MODULE_2__.createDeadlineSignal)(opt.timeoutMs);\n    const controller = (0,_signals_js__WEBPACK_IMPORTED_MODULE_2__.createLinkedAbortController)(opt.signal, signal);\n    return [\n        controller.signal,\n        function abort(reason) {\n            // We peek at the deadline signal because fetch() will throw an error on\n            // abort that discards the signal reason.\n            const e = _connect_error_js__WEBPACK_IMPORTED_MODULE_3__.ConnectError.from(signal.aborted ? (0,_signals_js__WEBPACK_IMPORTED_MODULE_2__.getAbortSignalReason)(signal) : reason);\n            controller.abort(e);\n            cleanup();\n            return Promise.reject(e);\n        },\n        function done() {\n            cleanup();\n            controller.abort();\n        },\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL3J1bi1jYWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NEO0FBQ0g7QUFDcUQ7QUFDMUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixrRUFBaUI7QUFDbEM7QUFDQSw4Q0FBOEMsY0FBYyxTQUFTLHdEQUFTLGlEQUFpRDtBQUMvSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLGtFQUFpQjtBQUNsQztBQUNBLDhDQUE4QyxjQUFjLFNBQVMsZ0VBQWlCLGlEQUFpRDtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQixFQUFFLGlFQUFvQjtBQUNwRCx1QkFBdUIsd0VBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVksdUJBQXVCLGlFQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvcnVuLWNhbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGFwcGx5SW50ZXJjZXB0b3JzIH0gZnJvbSBcIi4uL2ludGVyY2VwdG9yLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlRGVhZGxpbmVTaWduYWwsIGNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlciwgZ2V0QWJvcnRTaWduYWxSZWFzb24sIH0gZnJvbSBcIi4vc2lnbmFscy5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplLCBub3JtYWxpemVJdGVyYWJsZSB9IGZyb20gXCIuL25vcm1hbGl6ZS5qc1wiO1xuLyoqXG4gKiBSdW5zIGEgdW5hcnkgbWV0aG9kIHdpdGggdGhlIGdpdmVuIGludGVyY2VwdG9ycy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb25cbiAqIGlzIG9ubHkgdXNlZCB3aGVuIGltcGxlbWVudGluZyBhIFRyYW5zcG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1blVuYXJ5Q2FsbChvcHQpIHtcbiAgICBjb25zdCBuZXh0ID0gYXBwbHlJbnRlcmNlcHRvcnMob3B0Lm5leHQsIG9wdC5pbnRlcmNlcHRvcnMpO1xuICAgIGNvbnN0IFtzaWduYWwsIGFib3J0LCBkb25lXSA9IHNldHVwU2lnbmFsKG9wdCk7XG4gICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHQucmVxKSwgeyBtZXNzYWdlOiBub3JtYWxpemUob3B0LnJlcS5tZXRob2QuaW5wdXQsIG9wdC5yZXEubWVzc2FnZSksIHNpZ25hbCB9KTtcbiAgICByZXR1cm4gbmV4dChyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgYWJvcnQpO1xufVxuLyoqXG4gKiBSdW5zIGEgc2VydmVyLXN0cmVhbWluZyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJjZXB0b3JzLiBOb3RlIHRoYXQgdGhpc1xuICogZnVuY3Rpb24gaXMgb25seSB1c2VkIHdoZW4gaW1wbGVtZW50aW5nIGEgVHJhbnNwb3J0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuU3RyZWFtaW5nQ2FsbChvcHQpIHtcbiAgICBjb25zdCBuZXh0ID0gYXBwbHlJbnRlcmNlcHRvcnMob3B0Lm5leHQsIG9wdC5pbnRlcmNlcHRvcnMpO1xuICAgIGNvbnN0IFtzaWduYWwsIGFib3J0LCBkb25lXSA9IHNldHVwU2lnbmFsKG9wdCk7XG4gICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHQucmVxKSwgeyBtZXNzYWdlOiBub3JtYWxpemVJdGVyYWJsZShvcHQucmVxLm1ldGhvZC5pbnB1dCwgb3B0LnJlcS5tZXNzYWdlKSwgc2lnbmFsIH0pO1xuICAgIGxldCBkb25lQ2FsbGVkID0gZmFsc2U7XG4gICAgLy8gQ2FsbCByZXR1cm4gb24gdGhlIHJlcXVlc3QgaXRlcmFibGUgdG8gaW5kaWNhdGVcbiAgICAvLyB0aGF0IHdlIHdpbGwgbm8gbG9uZ2VyIGNvbnN1bWUgaXQgYW5kIGl0IHNob3VsZFxuICAgIC8vIGNsZWFudXAgYW55IGFsbG9jYXRlZCByZXNvdXJjZXMuXG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGl0ID0gb3B0LnJlcS5tZXNzYWdlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAvLyBJZiB0aGUgc2lnbmFsIGlzIGFib3J0ZWQgZHVlIHRvIGFuIGVycm9yLCB3ZSB3YW50IHRvIHRocm93XG4gICAgICAgIC8vIHRoZSBlcnJvciB0byB0aGUgcmVxdWVzdCBpdGVyYXRvci5cbiAgICAgICAgaWYgKCFkb25lQ2FsbGVkKSB7XG4gICAgICAgICAgICAoX2EgPSBpdC50aHJvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHRoaXMucmVhc29uKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBVbmNhdWdodCBwcm9taXNlcyBhcmUgdGhyb3duIGF0IHNvbWV0aW1lL3NvbWV3aGVyZSBieSB0aGUgZXZlbnQgbG9vcCxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBlcnJvciBpcyBjYXVnaHQgYW5kIGlnbm9yZWQuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSBpdC5yZXR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGl0KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyByZXR1cm4gcmV0dXJucyBhIHByb21pc2UsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5jYXVnaHQgcHJvbWlzZXMgYXJlIHRocm93biBhdCBzb21ldGltZS9zb21ld2hlcmUgYnkgdGhlIGV2ZW50IGxvb3AsXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBlcnJvciBpcyBjYXVnaHQgYW5kIGlnbm9yZWQuXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcyksIHsgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gcmVzLm1lc3NhZ2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdC5uZXh0KCkudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5kb25lID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFib3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkZWxpYmVyYXRlbHkgb21pdCB0aHJvdy9yZXR1cm4uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfSwgYWJvcnQpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQWJvcnRTaWduYWwgZm9yIFRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbnMuIFRoZSBzaWduYWwgaXMgYXZhaWxhYmxlXG4gKiBpbiBVbmFyeVJlcXVlc3QgYW5kIFN0cmVhbWluZ1JlcXVlc3QsIGFuZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FsbCBpc1xuICogYWJvcnRlZCAodmlhIGEgdGltZW91dCBvciBleHBsaWNpdCBjYW5jZWxsYXRpb24pLCBlcnJvcmVkIChlLmcuIHdoZW4gcmVhZGluZ1xuICogYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyIGZyb20gdGhlIHdpcmUpLCBvciBmaW5pc2hlZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogVHJhbnNwb3J0IGltcGxlbWVudGF0aW9ucyBjYW4gcGFzcyB0aGUgc2lnbmFsIHRvIEhUVFAgY2xpZW50cyB0byBlbnN1cmUgdGhhdFxuICogdGhlcmUgYXJlIG5vIHVudXNlZCBjb25uZWN0aW9ucyBsZWFrLlxuICpcbiAqIFJldHVybnMgYSB0dXBsZTpcbiAqIFswXTogVGhlIHNpZ25hbCwgd2hpY2ggaXMgYWxzbyBhYm9ydGVkIGlmIHRoZSBvcHRpb25hbCBkZWFkbGluZSBpcyByZWFjaGVkLlxuICogWzFdOiBGdW5jdGlvbiB0byBjYWxsIGlmIHRoZSBUcmFuc3BvcnQgZW5jb3VudGVyZWQgYW4gZXJyb3IuXG4gKiBbMl06IEZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhlIFRyYW5zcG9ydCBmaW5pc2hlZCB3aXRob3V0IGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBzZXR1cFNpZ25hbChvcHQpIHtcbiAgICBjb25zdCB7IHNpZ25hbCwgY2xlYW51cCB9ID0gY3JlYXRlRGVhZGxpbmVTaWduYWwob3B0LnRpbWVvdXRNcyk7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlcihvcHQuc2lnbmFsLCBzaWduYWwpO1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIC8vIFdlIHBlZWsgYXQgdGhlIGRlYWRsaW5lIHNpZ25hbCBiZWNhdXNlIGZldGNoKCkgd2lsbCB0aHJvdyBhbiBlcnJvciBvblxuICAgICAgICAgICAgLy8gYWJvcnQgdGhhdCBkaXNjYXJkcyB0aGUgc2lnbmFsIHJlYXNvbi5cbiAgICAgICAgICAgIGNvbnN0IGUgPSBDb25uZWN0RXJyb3IuZnJvbShzaWduYWwuYWJvcnRlZCA/IGdldEFib3J0U2lnbmFsUmVhc29uKHNpZ25hbCkgOiByZWFzb24pO1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydChlKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSxcbiAgICBdO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBinarySerialization: () => (/* binding */ createBinarySerialization),\n/* harmony export */   createClientMethodSerializers: () => (/* binding */ createClientMethodSerializers),\n/* harmony export */   createJsonSerialization: () => (/* binding */ createJsonSerialization),\n/* harmony export */   createMethodSerializationLookup: () => (/* binding */ createMethodSerializationLookup),\n/* harmony export */   getJsonOptions: () => (/* binding */ getJsonOptions),\n/* harmony export */   limitSerialization: () => (/* binding */ limitSerialization)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/from-binary.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/to-binary.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/from-json.js\");\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(action-browser)/./node_modules/@bufbuild/protobuf/dist/esm/to-json.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _limit_io_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limit-io.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * Sets default JSON serialization options for connect-es.\n *\n * With standard protobuf JSON serialization, unknown JSON fields are\n * rejected by default. In connect-es, unknown JSON fields are ignored\n * by default.\n */\nfunction getJsonOptions(options) {\n    var _a;\n    const o = Object.assign({}, options);\n    (_a = o.ignoreUnknownFields) !== null && _a !== void 0 ? _a : (o.ignoreUnknownFields = true);\n    return o;\n}\n/**\n * Create an object that provides convenient access to request and response\n * message serialization for a given method.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createMethodSerializationLookup(method, binaryOptions, jsonOptions, limitOptions) {\n    const inputBinary = limitSerialization(createBinarySerialization(method.input, binaryOptions), limitOptions);\n    const inputJson = limitSerialization(createJsonSerialization(method.input, jsonOptions), limitOptions);\n    const outputBinary = limitSerialization(createBinarySerialization(method.output, binaryOptions), limitOptions);\n    const outputJson = limitSerialization(createJsonSerialization(method.output, jsonOptions), limitOptions);\n    return {\n        getI(useBinaryFormat) {\n            return useBinaryFormat ? inputBinary : inputJson;\n        },\n        getO(useBinaryFormat) {\n            return useBinaryFormat ? outputBinary : outputJson;\n        },\n    };\n}\n/**\n * Returns functions to normalize and serialize the input message\n * of an RPC, and to parse the output message of an RPC.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createClientMethodSerializers(method, useBinaryFormat, jsonOptions, binaryOptions) {\n    const input = useBinaryFormat\n        ? createBinarySerialization(method.input, binaryOptions)\n        : createJsonSerialization(method.input, jsonOptions);\n    const output = useBinaryFormat\n        ? createBinarySerialization(method.output, binaryOptions)\n        : createJsonSerialization(method.output, jsonOptions);\n    return { parse: output.parse, serialize: input.serialize };\n}\n/**\n * Apply I/O limits to a Serialization object, returning a new object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction limitSerialization(serialization, limitOptions) {\n    return {\n        serialize(data) {\n            const bytes = serialization.serialize(data);\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_0__.assertWriteMaxBytes)(limitOptions.writeMaxBytes, bytes.byteLength);\n            return bytes;\n        },\n        parse(data) {\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_0__.assertReadMaxBytes)(limitOptions.readMaxBytes, data.byteLength, true);\n            return serialization.parse(data);\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf binary format.\n */\nfunction createBinarySerialization(desc, options) {\n    return {\n        parse(data) {\n            try {\n                return (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.fromBinary)(desc, data, options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`parse binary: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.Internal);\n            }\n        },\n        serialize(data) {\n            try {\n                return (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__.toBinary)(desc, data, options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`serialize binary: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.Internal);\n            }\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf canonical JSON encoding.\n *\n * By default, unknown fields are ignored.\n */\nfunction createJsonSerialization(desc, options) {\n    var _a, _b;\n    const textEncoder = (_a = options === null || options === void 0 ? void 0 : options.textEncoder) !== null && _a !== void 0 ? _a : new TextEncoder();\n    const textDecoder = (_b = options === null || options === void 0 ? void 0 : options.textDecoder) !== null && _b !== void 0 ? _b : new TextDecoder();\n    const o = getJsonOptions(options);\n    return {\n        parse(data) {\n            try {\n                const json = textDecoder.decode(data);\n                return (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_5__.fromJsonString)(desc, json, o);\n            }\n            catch (e) {\n                throw _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError.from(e, _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.InvalidArgument);\n            }\n        },\n        serialize(data) {\n            try {\n                const json = (0,_bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_6__.toJsonString)(desc, data, o);\n                return textEncoder.encode(json);\n            }\n            catch (e) {\n                throw _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError.from(e, _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.Internal);\n            }\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL3NlcmlhbGl6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lGO0FBQ3RDO0FBQ2pCO0FBQ3NDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBbUI7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLGdFQUFrQjtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVksa0JBQWtCLEVBQUUsR0FBRywwQ0FBSTtBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCLDREQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBWSxzQkFBc0IsRUFBRSxHQUFHLDBDQUFJO0FBQ3JFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWM7QUFDckM7QUFDQTtBQUNBLHNCQUFzQiwyREFBWSxTQUFTLDBDQUFJO0FBQy9DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFZLFNBQVMsMENBQUk7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9zZXJpYWxpemF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBmcm9tQmluYXJ5LCBmcm9tSnNvblN0cmluZywgdG9CaW5hcnksIHRvSnNvblN0cmluZywgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRSZWFkTWF4Qnl0ZXMsIGFzc2VydFdyaXRlTWF4Qnl0ZXMgfSBmcm9tIFwiLi9saW1pdC1pby5qc1wiO1xuLyoqXG4gKiBTZXRzIGRlZmF1bHQgSlNPTiBzZXJpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGNvbm5lY3QtZXMuXG4gKlxuICogV2l0aCBzdGFuZGFyZCBwcm90b2J1ZiBKU09OIHNlcmlhbGl6YXRpb24sIHVua25vd24gSlNPTiBmaWVsZHMgYXJlXG4gKiByZWplY3RlZCBieSBkZWZhdWx0LiBJbiBjb25uZWN0LWVzLCB1bmtub3duIEpTT04gZmllbGRzIGFyZSBpZ25vcmVkXG4gKiBieSBkZWZhdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SnNvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgKF9hID0gby5pZ25vcmVVbmtub3duRmllbGRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoby5pZ25vcmVVbmtub3duRmllbGRzID0gdHJ1ZSk7XG4gICAgcmV0dXJuIG87XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBjb252ZW5pZW50IGFjY2VzcyB0byByZXF1ZXN0IGFuZCByZXNwb25zZVxuICogbWVzc2FnZSBzZXJpYWxpemF0aW9uIGZvciBhIGdpdmVuIG1ldGhvZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZFNlcmlhbGl6YXRpb25Mb29rdXAobWV0aG9kLCBiaW5hcnlPcHRpb25zLCBqc29uT3B0aW9ucywgbGltaXRPcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXRCaW5hcnkgPSBsaW1pdFNlcmlhbGl6YXRpb24oY3JlYXRlQmluYXJ5U2VyaWFsaXphdGlvbihtZXRob2QuaW5wdXQsIGJpbmFyeU9wdGlvbnMpLCBsaW1pdE9wdGlvbnMpO1xuICAgIGNvbnN0IGlucHV0SnNvbiA9IGxpbWl0U2VyaWFsaXphdGlvbihjcmVhdGVKc29uU2VyaWFsaXphdGlvbihtZXRob2QuaW5wdXQsIGpzb25PcHRpb25zKSwgbGltaXRPcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXRCaW5hcnkgPSBsaW1pdFNlcmlhbGl6YXRpb24oY3JlYXRlQmluYXJ5U2VyaWFsaXphdGlvbihtZXRob2Qub3V0cHV0LCBiaW5hcnlPcHRpb25zKSwgbGltaXRPcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXRKc29uID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5vdXRwdXQsIGpzb25PcHRpb25zKSwgbGltaXRPcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJKHVzZUJpbmFyeUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUJpbmFyeUZvcm1hdCA/IGlucHV0QmluYXJ5IDogaW5wdXRKc29uO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPKHVzZUJpbmFyeUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUJpbmFyeUZvcm1hdCA/IG91dHB1dEJpbmFyeSA6IG91dHB1dEpzb247XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBmdW5jdGlvbnMgdG8gbm9ybWFsaXplIGFuZCBzZXJpYWxpemUgdGhlIGlucHV0IG1lc3NhZ2VcbiAqIG9mIGFuIFJQQywgYW5kIHRvIHBhcnNlIHRoZSBvdXRwdXQgbWVzc2FnZSBvZiBhbiBSUEMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRob2RTZXJpYWxpemVycyhtZXRob2QsIHVzZUJpbmFyeUZvcm1hdCwganNvbk9wdGlvbnMsIGJpbmFyeU9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICA/IGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLmlucHV0LCBiaW5hcnlPcHRpb25zKVxuICAgICAgICA6IGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5pbnB1dCwganNvbk9wdGlvbnMpO1xuICAgIGNvbnN0IG91dHB1dCA9IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICA/IGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLm91dHB1dCwgYmluYXJ5T3B0aW9ucylcbiAgICAgICAgOiBjcmVhdGVKc29uU2VyaWFsaXphdGlvbihtZXRob2Qub3V0cHV0LCBqc29uT3B0aW9ucyk7XG4gICAgcmV0dXJuIHsgcGFyc2U6IG91dHB1dC5wYXJzZSwgc2VyaWFsaXplOiBpbnB1dC5zZXJpYWxpemUgfTtcbn1cbi8qKlxuICogQXBwbHkgSS9PIGxpbWl0cyB0byBhIFNlcmlhbGl6YXRpb24gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRTZXJpYWxpemF0aW9uKHNlcmlhbGl6YXRpb24sIGxpbWl0T3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICAgICAgYXNzZXJ0V3JpdGVNYXhCeXRlcyhsaW1pdE9wdGlvbnMud3JpdGVNYXhCeXRlcywgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhsaW1pdE9wdGlvbnMucmVhZE1heEJ5dGVzLCBkYXRhLmJ5dGVMZW5ndGgsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb24ucGFyc2UoZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFNlcmlhbGl6YXRpb24gb2JqZWN0IGZvciBzZXJpYWxpemluZyB0aGUgZ2l2ZW4gcHJvdG9idWYgbWVzc2FnZVxuICogd2l0aCB0aGUgcHJvdG9idWYgYmluYXJ5IGZvcm1hdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24oZGVzYywgb3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaW5hcnkoZGVzYywgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgcGFyc2UgYmluYXJ5OiAke219YCwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0JpbmFyeShkZXNjLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBzZXJpYWxpemUgYmluYXJ5OiAke219YCwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFNlcmlhbGl6YXRpb24gb2JqZWN0IGZvciBzZXJpYWxpemluZyB0aGUgZ2l2ZW4gcHJvdG9idWYgbWVzc2FnZVxuICogd2l0aCB0aGUgcHJvdG9idWYgY2Fub25pY2FsIEpTT04gZW5jb2RpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgdW5rbm93biBmaWVsZHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVKc29uU2VyaWFsaXphdGlvbihkZXNjLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB0ZXh0RW5jb2RlciA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXh0RW5jb2RlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgdGV4dERlY29kZXIgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGV4dERlY29kZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIGNvbnN0IG8gPSBnZXRKc29uT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21Kc29uU3RyaW5nKGRlc2MsIGpzb24sIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDb25uZWN0RXJyb3IuZnJvbShlLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSB0b0pzb25TdHJpbmcoZGVzYywgZGF0YSwgbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29ubmVjdEVycm9yLmZyb20oZSwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeadlineSignal: () => (/* binding */ createDeadlineSignal),\n/* harmony export */   createLinkedAbortController: () => (/* binding */ createLinkedAbortController),\n/* harmony export */   getAbortSignalReason: () => (/* binding */ getAbortSignalReason)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(action-browser)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * Create an AbortController that is automatically aborted if one of the given\n * signals is aborted.\n *\n * For convenience, the linked AbortSignals can be undefined.\n *\n * If the controller or any of the signals is aborted, all event listeners are\n * removed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createLinkedAbortController(...signals) {\n    const controller = new AbortController();\n    const sa = signals.filter((s) => s !== undefined).concat(controller.signal);\n    for (const signal of sa) {\n        if (signal.aborted) {\n            onAbort.apply(signal);\n            break;\n        }\n        signal.addEventListener(\"abort\", onAbort);\n    }\n    function onAbort() {\n        if (!controller.signal.aborted) {\n            controller.abort(getAbortSignalReason(this));\n        }\n        for (const signal of sa) {\n            signal.removeEventListener(\"abort\", onAbort);\n        }\n    }\n    return controller;\n}\n/**\n * Create a deadline signal. The returned object contains an AbortSignal, but\n * also a cleanup function to stop the timer, which must be called once the\n * calling code is no longer interested in the signal.\n *\n * Ideally, we would simply use AbortSignal.timeout(), but it is not widely\n * available yet.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createDeadlineSignal(timeoutMs) {\n    const controller = new AbortController();\n    const listener = () => {\n        controller.abort(new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"the operation timed out\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.DeadlineExceeded));\n    };\n    let timeoutId;\n    if (timeoutMs !== undefined) {\n        if (timeoutMs <= 0)\n            listener();\n        else\n            timeoutId = setTimeout(listener, timeoutMs);\n    }\n    return {\n        signal: controller.signal,\n        cleanup: () => clearTimeout(timeoutId),\n    };\n}\n/**\n * Returns the reason why an AbortSignal was aborted. Returns undefined if the\n * signal has not been aborted.\n *\n * The property AbortSignal.reason is not widely available. This function\n * returns an AbortError if the signal is aborted, but reason is undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction getAbortSignalReason(signal) {\n    if (!signal.aborted) {\n        return undefined;\n    }\n    if (signal.reason !== undefined) {\n        return signal.reason;\n    }\n    // AbortSignal.reason is available in Node.js v16, v18, and later,\n    // and in all browsers since early 2022.\n    const e = new Error(\"This operation was aborted\");\n    e.name = \"AbortError\";\n    return e;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL3NpZ25hbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNqQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkJBQTZCLDJEQUFZLDRCQUE0QiwwQ0FBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL3NpZ25hbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0Q29udHJvbGxlciB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGdpdmVuXG4gKiBzaWduYWxzIGlzIGFib3J0ZWQuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB0aGUgbGlua2VkIEFib3J0U2lnbmFscyBjYW4gYmUgdW5kZWZpbmVkLlxuICpcbiAqIElmIHRoZSBjb250cm9sbGVyIG9yIGFueSBvZiB0aGUgc2lnbmFscyBpcyBhYm9ydGVkLCBhbGwgZXZlbnQgbGlzdGVuZXJzIGFyZVxuICogcmVtb3ZlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpbmtlZEFib3J0Q29udHJvbGxlciguLi5zaWduYWxzKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzYSA9IHNpZ25hbHMuZmlsdGVyKChzKSA9PiBzICE9PSB1bmRlZmluZWQpLmNvbmNhdChjb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2EpIHtcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBvbkFib3J0LmFwcGx5KHNpZ25hbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFib3J0KCkge1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZ2V0QWJvcnRTaWduYWxSZWFzb24odGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNhKSB7XG4gICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBkZWFkbGluZSBzaWduYWwuIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgYW4gQWJvcnRTaWduYWwsIGJ1dFxuICogYWxzbyBhIGNsZWFudXAgZnVuY3Rpb24gdG8gc3RvcCB0aGUgdGltZXIsIHdoaWNoIG11c3QgYmUgY2FsbGVkIG9uY2UgdGhlXG4gKiBjYWxsaW5nIGNvZGUgaXMgbm8gbG9uZ2VyIGludGVyZXN0ZWQgaW4gdGhlIHNpZ25hbC5cbiAqXG4gKiBJZGVhbGx5LCB3ZSB3b3VsZCBzaW1wbHkgdXNlIEFib3J0U2lnbmFsLnRpbWVvdXQoKSwgYnV0IGl0IGlzIG5vdCB3aWRlbHlcbiAqIGF2YWlsYWJsZSB5ZXQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWFkbGluZVNpZ25hbCh0aW1lb3V0TXMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBDb25uZWN0RXJyb3IoXCJ0aGUgb3BlcmF0aW9uIHRpbWVkIG91dFwiLCBDb2RlLkRlYWRsaW5lRXhjZWVkZWQpKTtcbiAgICB9O1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgaWYgKHRpbWVvdXRNcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aW1lb3V0TXMgPD0gMClcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQobGlzdGVuZXIsIHRpbWVvdXRNcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGNsZWFudXA6ICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHJlYXNvbiB3aHkgYW4gQWJvcnRTaWduYWwgd2FzIGFib3J0ZWQuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZVxuICogc2lnbmFsIGhhcyBub3QgYmVlbiBhYm9ydGVkLlxuICpcbiAqIFRoZSBwcm9wZXJ0eSBBYm9ydFNpZ25hbC5yZWFzb24gaXMgbm90IHdpZGVseSBhdmFpbGFibGUuIFRoaXMgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gQWJvcnRFcnJvciBpZiB0aGUgc2lnbmFsIGlzIGFib3J0ZWQsIGJ1dCByZWFzb24gaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWxSZWFzb24oc2lnbmFsKSB7XG4gICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzaWduYWwucmVhc29uO1xuICAgIH1cbiAgICAvLyBBYm9ydFNpZ25hbC5yZWFzb24gaXMgYXZhaWxhYmxlIGluIE5vZGUuanMgdjE2LCB2MTgsIGFuZCBsYXRlcixcbiAgICAvLyBhbmQgaW4gYWxsIGJyb3dzZXJzIHNpbmNlIGVhcmx5IDIwMjIuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIlRoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkXCIpO1xuICAgIGUubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgIHJldHVybiBlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js\n");

/***/ })

};
;